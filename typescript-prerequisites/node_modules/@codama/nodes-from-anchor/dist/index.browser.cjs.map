{"version":3,"sources":["../src/index.ts","../src/defaultVisitor.ts","../src/v00/AccountNode.ts","../src/discriminators.ts","../../../node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/src/utils.ts","../../../node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/src/_md.ts","../../../node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/src/sha2.ts","../../../node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/src/sha256.ts","../src/utils.ts","../src/v00/typeNodes/ArrayTypeNode.ts","../src/v00/typeNodes/TypeNode.ts","../src/v00/typeNodes/EnumTypeNode.ts","../src/v00/typeNodes/EnumEmptyVariantTypeNode.ts","../src/v00/typeNodes/EnumStructVariantTypeNode.ts","../src/v00/typeNodes/StructTypeNode.ts","../src/v00/typeNodes/StructFieldTypeNode.ts","../src/v00/typeNodes/EnumTupleVariantTypeNode.ts","../src/v00/typeNodes/TupleTypeNode.ts","../src/v00/typeNodes/MapTypeNode.ts","../src/v00/typeNodes/OptionTypeNode.ts","../src/v00/typeNodes/SetTypeNode.ts","../src/v00/DefinedTypeNode.ts","../src/v00/ErrorNode.ts","../src/v00/InstructionAccountNode.ts","../src/v00/InstructionArgumentNode.ts","../src/v00/InstructionNode.ts","../src/v00/PdaNode.ts","../src/v00/ProgramNode.ts","../src/v00/RootNode.ts","../src/v01/AccountNode.ts","../src/v01/typeNodes/ArrayTypeNode.ts","../src/v01/typeNodes/TypeNode.ts","../src/v01/typeNodes/EnumTypeNode.ts","../src/v01/typeNodes/EnumEmptyVariantTypeNode.ts","../src/v01/typeNodes/EnumStructVariantTypeNode.ts","../src/v01/typeNodes/StructTypeNode.ts","../src/v01/typeNodes/StructFieldTypeNode.ts","../src/v01/typeNodes/EnumTupleVariantTypeNode.ts","../src/v01/typeNodes/TupleTypeNode.ts","../src/v01/typeNodes/OptionTypeNode.ts","../src/v01/DefinedTypeNode.ts","../src/v01/ErrorNode.ts","../src/v01/InstructionAccountNode.ts","../src/v01/InstructionArgumentNode.ts","../src/v01/InstructionNode.ts","../src/v01/ProgramNode.ts","../src/v01/RootNode.ts"],"sourcesContent":["import { RootNode } from '@codama/nodes';\nimport { visit } from '@codama/visitors';\n\nimport { defaultVisitor } from './defaultVisitor';\nimport { IdlV00, rootNodeFromAnchorV00 } from './v00';\nimport { IdlV01, rootNodeFromAnchorV01 } from './v01';\n\nexport * from './defaultVisitor';\nexport * from './discriminators';\nexport * from './v00';\nexport * from './v01';\n\nexport type AnchorIdl = IdlV00 | IdlV01;\n\nexport function rootNodeFromAnchor(idl: AnchorIdl): RootNode {\n    return visit(rootNodeFromAnchorWithoutDefaultVisitor(idl), defaultVisitor());\n}\n\nexport function rootNodeFromAnchorWithoutDefaultVisitor(idl: AnchorIdl): RootNode {\n    if ((idl.metadata as { spec?: string })?.spec === '0.1.0') {\n        return rootNodeFromAnchorV01(idl as IdlV01);\n    }\n\n    return rootNodeFromAnchorV00(idl as IdlV00);\n}\n","import { assertIsNode, Node, RootNode } from '@codama/nodes';\nimport {\n    deduplicateIdenticalDefinedTypesVisitor,\n    flattenInstructionDataArgumentsVisitor,\n    getCommonInstructionAccountDefaultRules,\n    rootNodeVisitor,\n    setFixedAccountSizesVisitor,\n    setInstructionAccountDefaultValuesVisitor,\n    transformU8ArraysToBytesVisitor,\n    unwrapInstructionArgsDefinedTypesVisitor,\n    visit,\n    Visitor,\n} from '@codama/visitors';\n\nexport function defaultVisitor() {\n    return rootNodeVisitor(currentRoot => {\n        let root: RootNode = currentRoot;\n        const updateRoot = (visitor: Visitor<Node | null, 'rootNode'>) => {\n            const newRoot = visit(root, visitor);\n            assertIsNode(newRoot, 'rootNode');\n            root = newRoot;\n        };\n\n        // Defined types.\n        updateRoot(deduplicateIdenticalDefinedTypesVisitor());\n\n        // Accounts.\n        updateRoot(setFixedAccountSizesVisitor());\n\n        // Instructions.\n        updateRoot(setInstructionAccountDefaultValuesVisitor(getCommonInstructionAccountDefaultRules()));\n        updateRoot(unwrapInstructionArgsDefinedTypesVisitor());\n        updateRoot(flattenInstructionDataArgumentsVisitor());\n\n        // Extras.\n        updateRoot(transformU8ArraysToBytesVisitor());\n\n        return root;\n    });\n}\n","import {\n    AccountNode,\n    accountNode,\n    assertIsNode,\n    bytesTypeNode,\n    camelCase,\n    DiscriminatorNode,\n    fieldDiscriminatorNode,\n    fixedSizeTypeNode,\n    pdaLinkNode,\n    structFieldTypeNode,\n    StructTypeNode,\n    structTypeNode,\n} from '@codama/nodes';\n\nimport { getAnchorAccountDiscriminatorV00 } from '../discriminators';\nimport { IdlV00AccountDef } from './idl';\nimport { structTypeNodeFromAnchorV00 } from './typeNodes';\n\nexport function accountNodeFromAnchorV00(\n    idl: IdlV00AccountDef,\n    origin?: 'anchor' | 'shank',\n): AccountNode<StructTypeNode> {\n    const idlName = idl.name ?? '';\n    const name = camelCase(idlName);\n    const idlStruct = idl.type ?? { fields: [], kind: 'struct' };\n    let data = structTypeNodeFromAnchorV00(idlStruct);\n    assertIsNode(data, 'structTypeNode');\n    const hasSeeds = (idl.seeds ?? []).length > 0;\n\n    // Account discriminator.\n    let discriminators: DiscriminatorNode[] | undefined;\n    if (origin === 'anchor') {\n        const discriminator = structFieldTypeNode({\n            defaultValue: getAnchorAccountDiscriminatorV00(idlName),\n            defaultValueStrategy: 'omitted',\n            name: 'discriminator',\n            type: fixedSizeTypeNode(bytesTypeNode(), 8),\n        });\n        data = structTypeNode([discriminator, ...data.fields]);\n        discriminators = [fieldDiscriminatorNode('discriminator')];\n    }\n\n    return accountNode({\n        data,\n        discriminators,\n        docs: idl.docs ?? [],\n        name,\n        pda: hasSeeds ? pdaLinkNode(name) : undefined,\n        size: idl.size,\n    });\n}\n","import { BytesValueNode, bytesValueNode, pascalCase, snakeCase } from '@codama/nodes';\nimport { sha256 } from '@noble/hashes/sha256';\n\nimport { hex } from './utils';\n\nexport const getAnchorDiscriminatorV01 = (discriminator: number[]): BytesValueNode => {\n    return bytesValueNode('base16', hex(new Uint8Array(discriminator)));\n};\n\nexport const getAnchorInstructionDiscriminatorV00 = (idlName: string): BytesValueNode => {\n    const hash = sha256(`global:${snakeCase(idlName)}`).slice(0, 8);\n    return bytesValueNode('base16', hex(hash));\n};\n\nexport const getAnchorAccountDiscriminatorV00 = (idlName: string): BytesValueNode => {\n    const hash = sha256(`account:${pascalCase(idlName)}`).slice(0, 8);\n    return bytesValueNode('base16', hex(hash));\n};\n","/**\n * Utilities for hex, bytes, CSPRNG.\n * @module\n */\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.\nimport { crypto } from '@noble/hashes/crypto';\n\n/** Checks if something is Uint8Array. Be careful: nodejs Buffer will return true. */\nexport function isBytes(a: unknown): a is Uint8Array {\n  return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\n\n/** Asserts something is positive integer. */\nexport function anumber(n: number): void {\n  if (!Number.isSafeInteger(n) || n < 0) throw new Error('positive integer expected, got ' + n);\n}\n\n/** Asserts something is Uint8Array. */\nexport function abytes(b: Uint8Array | undefined, ...lengths: number[]): void {\n  if (!isBytes(b)) throw new Error('Uint8Array expected');\n  if (lengths.length > 0 && !lengths.includes(b.length))\n    throw new Error('Uint8Array expected of length ' + lengths + ', got length=' + b.length);\n}\n\n/** Asserts something is hash */\nexport function ahash(h: IHash): void {\n  if (typeof h !== 'function' || typeof h.create !== 'function')\n    throw new Error('Hash should be wrapped by utils.createHasher');\n  anumber(h.outputLen);\n  anumber(h.blockLen);\n}\n\n/** Asserts a hash instance has not been destroyed / finished */\nexport function aexists(instance: any, checkFinished = true): void {\n  if (instance.destroyed) throw new Error('Hash instance has been destroyed');\n  if (checkFinished && instance.finished) throw new Error('Hash#digest() has already been called');\n}\n\n/** Asserts output is properly-sized byte array */\nexport function aoutput(out: any, instance: any): void {\n  abytes(out);\n  const min = instance.outputLen;\n  if (out.length < min) {\n    throw new Error('digestInto() expects output buffer of length at least ' + min);\n  }\n}\n\n/** Generic type encompassing 8/16/32-byte arrays - but not 64-byte. */\n// prettier-ignore\nexport type TypedArray = Int8Array | Uint8ClampedArray | Uint8Array |\n  Uint16Array | Int16Array | Uint32Array | Int32Array;\n\n/** Cast u8 / u16 / u32 to u8. */\nexport function u8(arr: TypedArray): Uint8Array {\n  return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n\n/** Cast u8 / u16 / u32 to u32. */\nexport function u32(arr: TypedArray): Uint32Array {\n  return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n}\n\n/** Zeroize a byte array. Warning: JS provides no guarantees. */\nexport function clean(...arrays: TypedArray[]): void {\n  for (let i = 0; i < arrays.length; i++) {\n    arrays[i].fill(0);\n  }\n}\n\n/** Create DataView of an array for easy byte-level manipulation. */\nexport function createView(arr: TypedArray): DataView {\n  return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n\n/** The rotate right (circular right shift) operation for uint32 */\nexport function rotr(word: number, shift: number): number {\n  return (word << (32 - shift)) | (word >>> shift);\n}\n\n/** The rotate left (circular left shift) operation for uint32 */\nexport function rotl(word: number, shift: number): number {\n  return (word << shift) | ((word >>> (32 - shift)) >>> 0);\n}\n\n/** Is current platform little-endian? Most are. Big-Endian platform: IBM */\nexport const isLE: boolean = /* @__PURE__ */ (() =>\n  new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44)();\n\n/** The byte swap operation for uint32 */\nexport function byteSwap(word: number): number {\n  return (\n    ((word << 24) & 0xff000000) |\n    ((word << 8) & 0xff0000) |\n    ((word >>> 8) & 0xff00) |\n    ((word >>> 24) & 0xff)\n  );\n}\n/** Conditionally byte swap if on a big-endian platform */\nexport const swap8IfBE: (n: number) => number = isLE\n  ? (n: number) => n\n  : (n: number) => byteSwap(n);\n\n/** @deprecated */\nexport const byteSwapIfBE: typeof swap8IfBE = swap8IfBE;\n/** In place byte swap for Uint32Array */\nexport function byteSwap32(arr: Uint32Array): Uint32Array {\n  for (let i = 0; i < arr.length; i++) {\n    arr[i] = byteSwap(arr[i]);\n  }\n  return arr;\n}\n\nexport const swap32IfBE: (u: Uint32Array) => Uint32Array = isLE\n  ? (u: Uint32Array) => u\n  : byteSwap32;\n\n// Built-in hex conversion https://caniuse.com/mdn-javascript_builtins_uint8array_fromhex\nconst hasHexBuiltin: boolean = /* @__PURE__ */ (() =>\n  // @ts-ignore\n  typeof Uint8Array.from([]).toHex === 'function' && typeof Uint8Array.fromHex === 'function')();\n\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) =>\n  i.toString(16).padStart(2, '0')\n);\n\n/**\n * Convert byte array to hex string. Uses built-in function, when available.\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes: Uint8Array): string {\n  abytes(bytes);\n  // @ts-ignore\n  if (hasHexBuiltin) return bytes.toHex();\n  // pre-caching improves the speed 6x\n  let hex = '';\n  for (let i = 0; i < bytes.length; i++) {\n    hex += hexes[bytes[i]];\n  }\n  return hex;\n}\n\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 } as const;\nfunction asciiToBase16(ch: number): number | undefined {\n  if (ch >= asciis._0 && ch <= asciis._9) return ch - asciis._0; // '2' => 50-48\n  if (ch >= asciis.A && ch <= asciis.F) return ch - (asciis.A - 10); // 'B' => 66-(65-10)\n  if (ch >= asciis.a && ch <= asciis.f) return ch - (asciis.a - 10); // 'b' => 98-(97-10)\n  return;\n}\n\n/**\n * Convert hex string to byte array. Uses built-in function, when available.\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex: string): Uint8Array {\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n  // @ts-ignore\n  if (hasHexBuiltin) return Uint8Array.fromHex(hex);\n  const hl = hex.length;\n  const al = hl / 2;\n  if (hl % 2) throw new Error('hex string expected, got unpadded hex of length ' + hl);\n  const array = new Uint8Array(al);\n  for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n    const n1 = asciiToBase16(hex.charCodeAt(hi));\n    const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n    if (n1 === undefined || n2 === undefined) {\n      const char = hex[hi] + hex[hi + 1];\n      throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n    }\n    array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163\n  }\n  return array;\n}\n\n/**\n * There is no setImmediate in browser and setTimeout is slow.\n * Call of async fn will return Promise, which will be fullfiled only on\n * next scheduler queue processing step and this is exactly what we need.\n */\nexport const nextTick = async (): Promise<void> => {};\n\n/** Returns control to thread each 'tick' ms to avoid blocking. */\nexport async function asyncLoop(\n  iters: number,\n  tick: number,\n  cb: (i: number) => void\n): Promise<void> {\n  let ts = Date.now();\n  for (let i = 0; i < iters; i++) {\n    cb(i);\n    // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n    const diff = Date.now() - ts;\n    if (diff >= 0 && diff < tick) continue;\n    await nextTick();\n    ts += diff;\n  }\n}\n\n// Global symbols, but ts doesn't see them: https://github.com/microsoft/TypeScript/issues/31535\ndeclare const TextEncoder: any;\ndeclare const TextDecoder: any;\n\n/**\n * Converts string to bytes using UTF8 encoding.\n * @example utf8ToBytes('abc') // Uint8Array.from([97, 98, 99])\n */\nexport function utf8ToBytes(str: string): Uint8Array {\n  if (typeof str !== 'string') throw new Error('string expected');\n  return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n\n/**\n * Converts bytes to string using UTF8 encoding.\n * @example bytesToUtf8(Uint8Array.from([97, 98, 99])) // 'abc'\n */\nexport function bytesToUtf8(bytes: Uint8Array): string {\n  return new TextDecoder().decode(bytes);\n}\n\n/** Accepted input of hash functions. Strings are converted to byte arrays. */\nexport type Input = string | Uint8Array;\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nexport function toBytes(data: Input): Uint8Array {\n  if (typeof data === 'string') data = utf8ToBytes(data);\n  abytes(data);\n  return data;\n}\n\n/** KDFs can accept string or Uint8Array for user convenience. */\nexport type KDFInput = string | Uint8Array;\n/**\n * Helper for KDFs: consumes uint8array or string.\n * When string is passed, does utf8 decoding, using TextDecoder.\n */\nexport function kdfInputToBytes(data: KDFInput): Uint8Array {\n  if (typeof data === 'string') data = utf8ToBytes(data);\n  abytes(data);\n  return data;\n}\n\n/** Copies several Uint8Arrays into one. */\nexport function concatBytes(...arrays: Uint8Array[]): Uint8Array {\n  let sum = 0;\n  for (let i = 0; i < arrays.length; i++) {\n    const a = arrays[i];\n    abytes(a);\n    sum += a.length;\n  }\n  const res = new Uint8Array(sum);\n  for (let i = 0, pad = 0; i < arrays.length; i++) {\n    const a = arrays[i];\n    res.set(a, pad);\n    pad += a.length;\n  }\n  return res;\n}\n\ntype EmptyObj = {};\nexport function checkOpts<T1 extends EmptyObj, T2 extends EmptyObj>(\n  defaults: T1,\n  opts?: T2\n): T1 & T2 {\n  if (opts !== undefined && {}.toString.call(opts) !== '[object Object]')\n    throw new Error('options should be object or undefined');\n  const merged = Object.assign(defaults, opts);\n  return merged as T1 & T2;\n}\n\n/** Hash interface. */\nexport type IHash = {\n  (data: Uint8Array): Uint8Array;\n  blockLen: number;\n  outputLen: number;\n  create: any;\n};\n\n/** For runtime check if class implements interface */\nexport abstract class Hash<T extends Hash<T>> {\n  abstract blockLen: number; // Bytes per block\n  abstract outputLen: number; // Bytes in output\n  abstract update(buf: Input): this;\n  // Writes digest into buf\n  abstract digestInto(buf: Uint8Array): void;\n  abstract digest(): Uint8Array;\n  /**\n   * Resets internal state. Makes Hash instance unusable.\n   * Reset is impossible for keyed hashes if key is consumed into state. If digest is not consumed\n   * by user, they will need to manually call `destroy()` when zeroing is necessary.\n   */\n  abstract destroy(): void;\n  /**\n   * Clones hash instance. Unsafe: doesn't check whether `to` is valid. Can be used as `clone()`\n   * when no options are passed.\n   * Reasons to use `_cloneInto` instead of clone: 1) performance 2) reuse instance => all internal\n   * buffers are overwritten => causes buffer overwrite which is used for digest in some cases.\n   * There are no guarantees for clean-up because it's impossible in JS.\n   */\n  abstract _cloneInto(to?: T): T;\n  // Safe version that clones internal state\n  abstract clone(): T;\n}\n\n/**\n * XOF: streaming API to read digest in chunks.\n * Same as 'squeeze' in keccak/k12 and 'seek' in blake3, but more generic name.\n * When hash used in XOF mode it is up to user to call '.destroy' afterwards, since we cannot\n * destroy state, next call can require more bytes.\n */\nexport type HashXOF<T extends Hash<T>> = Hash<T> & {\n  xof(bytes: number): Uint8Array; // Read 'bytes' bytes from digest stream\n  xofInto(buf: Uint8Array): Uint8Array; // read buf.length bytes from digest stream into buf\n};\n\n/** Hash function */\nexport type CHash = ReturnType<typeof createHasher>;\n/** Hash function with output */\nexport type CHashO = ReturnType<typeof createOptHasher>;\n/** XOF with output */\nexport type CHashXO = ReturnType<typeof createXOFer>;\n\n/** Wraps hash function, creating an interface on top of it */\nexport function createHasher<T extends Hash<T>>(\n  hashCons: () => Hash<T>\n): {\n  (msg: Input): Uint8Array;\n  outputLen: number;\n  blockLen: number;\n  create(): Hash<T>;\n} {\n  const hashC = (msg: Input): Uint8Array => hashCons().update(toBytes(msg)).digest();\n  const tmp = hashCons();\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = () => hashCons();\n  return hashC;\n}\n\nexport function createOptHasher<H extends Hash<H>, T extends Object>(\n  hashCons: (opts?: T) => Hash<H>\n): {\n  (msg: Input, opts?: T): Uint8Array;\n  outputLen: number;\n  blockLen: number;\n  create(opts?: T): Hash<H>;\n} {\n  const hashC = (msg: Input, opts?: T): Uint8Array => hashCons(opts).update(toBytes(msg)).digest();\n  const tmp = hashCons({} as T);\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = (opts?: T) => hashCons(opts);\n  return hashC;\n}\n\nexport function createXOFer<H extends HashXOF<H>, T extends Object>(\n  hashCons: (opts?: T) => HashXOF<H>\n): {\n  (msg: Input, opts?: T): Uint8Array;\n  outputLen: number;\n  blockLen: number;\n  create(opts?: T): HashXOF<H>;\n} {\n  const hashC = (msg: Input, opts?: T): Uint8Array => hashCons(opts).update(toBytes(msg)).digest();\n  const tmp = hashCons({} as T);\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = (opts?: T) => hashCons(opts);\n  return hashC;\n}\nexport const wrapConstructor: typeof createHasher = createHasher;\nexport const wrapConstructorWithOpts: typeof createOptHasher = createOptHasher;\nexport const wrapXOFConstructorWithOpts: typeof createXOFer = createXOFer;\n\n/** Cryptographically secure PRNG. Uses internal OS-level `crypto.getRandomValues`. */\nexport function randomBytes(bytesLength = 32): Uint8Array {\n  if (crypto && typeof crypto.getRandomValues === 'function') {\n    return crypto.getRandomValues(new Uint8Array(bytesLength));\n  }\n  // Legacy Node.js compatibility\n  if (crypto && typeof crypto.randomBytes === 'function') {\n    return Uint8Array.from(crypto.randomBytes(bytesLength));\n  }\n  throw new Error('crypto.getRandomValues must be defined');\n}\n","/**\n * Internal Merkle-Damgard hash utils.\n * @module\n */\nimport { type Input, Hash, abytes, aexists, aoutput, clean, createView, toBytes } from './utils.ts';\n\n/** Polyfill for Safari 14. https://caniuse.com/mdn-javascript_builtins_dataview_setbiguint64 */\nexport function setBigUint64(\n  view: DataView,\n  byteOffset: number,\n  value: bigint,\n  isLE: boolean\n): void {\n  if (typeof view.setBigUint64 === 'function') return view.setBigUint64(byteOffset, value, isLE);\n  const _32n = BigInt(32);\n  const _u32_max = BigInt(0xffffffff);\n  const wh = Number((value >> _32n) & _u32_max);\n  const wl = Number(value & _u32_max);\n  const h = isLE ? 4 : 0;\n  const l = isLE ? 0 : 4;\n  view.setUint32(byteOffset + h, wh, isLE);\n  view.setUint32(byteOffset + l, wl, isLE);\n}\n\n/** Choice: a ? b : c */\nexport function Chi(a: number, b: number, c: number): number {\n  return (a & b) ^ (~a & c);\n}\n\n/** Majority function, true if any two inputs is true. */\nexport function Maj(a: number, b: number, c: number): number {\n  return (a & b) ^ (a & c) ^ (b & c);\n}\n\n/**\n * Merkle-Damgard hash construction base class.\n * Could be used to create MD5, RIPEMD, SHA1, SHA2.\n */\nexport abstract class HashMD<T extends HashMD<T>> extends Hash<T> {\n  protected abstract process(buf: DataView, offset: number): void;\n  protected abstract get(): number[];\n  protected abstract set(...args: number[]): void;\n  abstract destroy(): void;\n  protected abstract roundClean(): void;\n\n  readonly blockLen: number;\n  readonly outputLen: number;\n  readonly padOffset: number;\n  readonly isLE: boolean;\n\n  // For partial updates less than block size\n  protected buffer: Uint8Array;\n  protected view: DataView;\n  protected finished = false;\n  protected length = 0;\n  protected pos = 0;\n  protected destroyed = false;\n\n  constructor(blockLen: number, outputLen: number, padOffset: number, isLE: boolean) {\n    super();\n    this.blockLen = blockLen;\n    this.outputLen = outputLen;\n    this.padOffset = padOffset;\n    this.isLE = isLE;\n    this.buffer = new Uint8Array(blockLen);\n    this.view = createView(this.buffer);\n  }\n  update(data: Input): this {\n    aexists(this);\n    data = toBytes(data);\n    abytes(data);\n    const { view, buffer, blockLen } = this;\n    const len = data.length;\n    for (let pos = 0; pos < len; ) {\n      const take = Math.min(blockLen - this.pos, len - pos);\n      // Fast path: we have at least one block in input, cast it to view and process\n      if (take === blockLen) {\n        const dataView = createView(data);\n        for (; blockLen <= len - pos; pos += blockLen) this.process(dataView, pos);\n        continue;\n      }\n      buffer.set(data.subarray(pos, pos + take), this.pos);\n      this.pos += take;\n      pos += take;\n      if (this.pos === blockLen) {\n        this.process(view, 0);\n        this.pos = 0;\n      }\n    }\n    this.length += data.length;\n    this.roundClean();\n    return this;\n  }\n  digestInto(out: Uint8Array): void {\n    aexists(this);\n    aoutput(out, this);\n    this.finished = true;\n    // Padding\n    // We can avoid allocation of buffer for padding completely if it\n    // was previously not allocated here. But it won't change performance.\n    const { buffer, view, blockLen, isLE } = this;\n    let { pos } = this;\n    // append the bit '1' to the message\n    buffer[pos++] = 0b10000000;\n    clean(this.buffer.subarray(pos));\n    // we have less than padOffset left in buffer, so we cannot put length in\n    // current block, need process it and pad again\n    if (this.padOffset > blockLen - pos) {\n      this.process(view, 0);\n      pos = 0;\n    }\n    // Pad until full block byte with zeros\n    for (let i = pos; i < blockLen; i++) buffer[i] = 0;\n    // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n    // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n    // So we just write lowest 64 bits of that value.\n    setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n    this.process(view, 0);\n    const oview = createView(out);\n    const len = this.outputLen;\n    // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n    if (len % 4) throw new Error('_sha2: outputLen should be aligned to 32bit');\n    const outLen = len / 4;\n    const state = this.get();\n    if (outLen > state.length) throw new Error('_sha2: outputLen bigger than state');\n    for (let i = 0; i < outLen; i++) oview.setUint32(4 * i, state[i], isLE);\n  }\n  digest(): Uint8Array {\n    const { buffer, outputLen } = this;\n    this.digestInto(buffer);\n    const res = buffer.slice(0, outputLen);\n    this.destroy();\n    return res;\n  }\n  _cloneInto(to?: T): T {\n    to ||= new (this.constructor as any)() as T;\n    to.set(...this.get());\n    const { blockLen, buffer, length, finished, destroyed, pos } = this;\n    to.destroyed = destroyed;\n    to.finished = finished;\n    to.length = length;\n    to.pos = pos;\n    if (length % blockLen) to.buffer.set(buffer);\n    return to;\n  }\n  clone(): T {\n    return this._cloneInto();\n  }\n}\n\n/**\n * Initial SHA-2 state: fractional parts of square roots of first 16 primes 2..53.\n * Check out `test/misc/sha2-gen-iv.js` for recomputation guide.\n */\n\n/** Initial SHA256 state. Bits 0..32 of frac part of sqrt of primes 2..19 */\nexport const SHA256_IV: Uint32Array = /* @__PURE__ */ Uint32Array.from([\n  0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19,\n]);\n\n/** Initial SHA224 state. Bits 32..64 of frac part of sqrt of primes 23..53 */\nexport const SHA224_IV: Uint32Array = /* @__PURE__ */ Uint32Array.from([\n  0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939, 0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4,\n]);\n\n/** Initial SHA384 state. Bits 0..64 of frac part of sqrt of primes 23..53 */\nexport const SHA384_IV: Uint32Array = /* @__PURE__ */ Uint32Array.from([\n  0xcbbb9d5d, 0xc1059ed8, 0x629a292a, 0x367cd507, 0x9159015a, 0x3070dd17, 0x152fecd8, 0xf70e5939,\n  0x67332667, 0xffc00b31, 0x8eb44a87, 0x68581511, 0xdb0c2e0d, 0x64f98fa7, 0x47b5481d, 0xbefa4fa4,\n]);\n\n/** Initial SHA512 state. Bits 0..64 of frac part of sqrt of primes 2..19 */\nexport const SHA512_IV: Uint32Array = /* @__PURE__ */ Uint32Array.from([\n  0x6a09e667, 0xf3bcc908, 0xbb67ae85, 0x84caa73b, 0x3c6ef372, 0xfe94f82b, 0xa54ff53a, 0x5f1d36f1,\n  0x510e527f, 0xade682d1, 0x9b05688c, 0x2b3e6c1f, 0x1f83d9ab, 0xfb41bd6b, 0x5be0cd19, 0x137e2179,\n]);\n","/**\n * SHA2 hash function. A.k.a. sha256, sha384, sha512, sha512_224, sha512_256.\n * SHA256 is the fastest hash implementable in JS, even faster than Blake3.\n * Check out [RFC 4634](https://datatracker.ietf.org/doc/html/rfc4634) and\n * [FIPS 180-4](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf).\n * @module\n */\nimport { Chi, HashMD, Maj, SHA224_IV, SHA256_IV, SHA384_IV, SHA512_IV } from './_md.ts';\nimport * as u64 from './_u64.ts';\nimport { type CHash, clean, createHasher, rotr } from './utils.ts';\n\n/**\n * Round constants:\n * First 32 bits of fractional parts of the cube roots of the first 64 primes 2..311)\n */\n// prettier-ignore\nconst SHA256_K = /* @__PURE__ */ Uint32Array.from([\n  0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n  0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n  0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n  0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n  0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n  0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n  0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n  0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\n\n/** Reusable temporary buffer. \"W\" comes straight from spec. */\nconst SHA256_W = /* @__PURE__ */ new Uint32Array(64);\nexport class SHA256 extends HashMD<SHA256> {\n  // We cannot use array here since array allows indexing by variable\n  // which means optimizer/compiler cannot use registers.\n  protected A: number = SHA256_IV[0] | 0;\n  protected B: number = SHA256_IV[1] | 0;\n  protected C: number = SHA256_IV[2] | 0;\n  protected D: number = SHA256_IV[3] | 0;\n  protected E: number = SHA256_IV[4] | 0;\n  protected F: number = SHA256_IV[5] | 0;\n  protected G: number = SHA256_IV[6] | 0;\n  protected H: number = SHA256_IV[7] | 0;\n\n  constructor(outputLen: number = 32) {\n    super(64, outputLen, 8, false);\n  }\n  protected get(): [number, number, number, number, number, number, number, number] {\n    const { A, B, C, D, E, F, G, H } = this;\n    return [A, B, C, D, E, F, G, H];\n  }\n  // prettier-ignore\n  protected set(\n    A: number, B: number, C: number, D: number, E: number, F: number, G: number, H: number\n  ): void {\n    this.A = A | 0;\n    this.B = B | 0;\n    this.C = C | 0;\n    this.D = D | 0;\n    this.E = E | 0;\n    this.F = F | 0;\n    this.G = G | 0;\n    this.H = H | 0;\n  }\n  protected process(view: DataView, offset: number): void {\n    // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n    for (let i = 0; i < 16; i++, offset += 4) SHA256_W[i] = view.getUint32(offset, false);\n    for (let i = 16; i < 64; i++) {\n      const W15 = SHA256_W[i - 15];\n      const W2 = SHA256_W[i - 2];\n      const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ (W15 >>> 3);\n      const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ (W2 >>> 10);\n      SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;\n    }\n    // Compression function main loop, 64 rounds\n    let { A, B, C, D, E, F, G, H } = this;\n    for (let i = 0; i < 64; i++) {\n      const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);\n      const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n      const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);\n      const T2 = (sigma0 + Maj(A, B, C)) | 0;\n      H = G;\n      G = F;\n      F = E;\n      E = (D + T1) | 0;\n      D = C;\n      C = B;\n      B = A;\n      A = (T1 + T2) | 0;\n    }\n    // Add the compressed chunk to the current hash value\n    A = (A + this.A) | 0;\n    B = (B + this.B) | 0;\n    C = (C + this.C) | 0;\n    D = (D + this.D) | 0;\n    E = (E + this.E) | 0;\n    F = (F + this.F) | 0;\n    G = (G + this.G) | 0;\n    H = (H + this.H) | 0;\n    this.set(A, B, C, D, E, F, G, H);\n  }\n  protected roundClean(): void {\n    clean(SHA256_W);\n  }\n  destroy(): void {\n    this.set(0, 0, 0, 0, 0, 0, 0, 0);\n    clean(this.buffer);\n  }\n}\n\nexport class SHA224 extends SHA256 {\n  protected A: number = SHA224_IV[0] | 0;\n  protected B: number = SHA224_IV[1] | 0;\n  protected C: number = SHA224_IV[2] | 0;\n  protected D: number = SHA224_IV[3] | 0;\n  protected E: number = SHA224_IV[4] | 0;\n  protected F: number = SHA224_IV[5] | 0;\n  protected G: number = SHA224_IV[6] | 0;\n  protected H: number = SHA224_IV[7] | 0;\n  constructor() {\n    super(28);\n  }\n}\n\n// SHA2-512 is slower than sha256 in js because u64 operations are slow.\n\n// Round contants\n// First 32 bits of the fractional parts of the cube roots of the first 80 primes 2..409\n// prettier-ignore\nconst K512 = /* @__PURE__ */ (() => u64.split([\n  '0x428a2f98d728ae22', '0x7137449123ef65cd', '0xb5c0fbcfec4d3b2f', '0xe9b5dba58189dbbc',\n  '0x3956c25bf348b538', '0x59f111f1b605d019', '0x923f82a4af194f9b', '0xab1c5ed5da6d8118',\n  '0xd807aa98a3030242', '0x12835b0145706fbe', '0x243185be4ee4b28c', '0x550c7dc3d5ffb4e2',\n  '0x72be5d74f27b896f', '0x80deb1fe3b1696b1', '0x9bdc06a725c71235', '0xc19bf174cf692694',\n  '0xe49b69c19ef14ad2', '0xefbe4786384f25e3', '0x0fc19dc68b8cd5b5', '0x240ca1cc77ac9c65',\n  '0x2de92c6f592b0275', '0x4a7484aa6ea6e483', '0x5cb0a9dcbd41fbd4', '0x76f988da831153b5',\n  '0x983e5152ee66dfab', '0xa831c66d2db43210', '0xb00327c898fb213f', '0xbf597fc7beef0ee4',\n  '0xc6e00bf33da88fc2', '0xd5a79147930aa725', '0x06ca6351e003826f', '0x142929670a0e6e70',\n  '0x27b70a8546d22ffc', '0x2e1b21385c26c926', '0x4d2c6dfc5ac42aed', '0x53380d139d95b3df',\n  '0x650a73548baf63de', '0x766a0abb3c77b2a8', '0x81c2c92e47edaee6', '0x92722c851482353b',\n  '0xa2bfe8a14cf10364', '0xa81a664bbc423001', '0xc24b8b70d0f89791', '0xc76c51a30654be30',\n  '0xd192e819d6ef5218', '0xd69906245565a910', '0xf40e35855771202a', '0x106aa07032bbd1b8',\n  '0x19a4c116b8d2d0c8', '0x1e376c085141ab53', '0x2748774cdf8eeb99', '0x34b0bcb5e19b48a8',\n  '0x391c0cb3c5c95a63', '0x4ed8aa4ae3418acb', '0x5b9cca4f7763e373', '0x682e6ff3d6b2b8a3',\n  '0x748f82ee5defb2fc', '0x78a5636f43172f60', '0x84c87814a1f0ab72', '0x8cc702081a6439ec',\n  '0x90befffa23631e28', '0xa4506cebde82bde9', '0xbef9a3f7b2c67915', '0xc67178f2e372532b',\n  '0xca273eceea26619c', '0xd186b8c721c0c207', '0xeada7dd6cde0eb1e', '0xf57d4f7fee6ed178',\n  '0x06f067aa72176fba', '0x0a637dc5a2c898a6', '0x113f9804bef90dae', '0x1b710b35131c471b',\n  '0x28db77f523047d84', '0x32caab7b40c72493', '0x3c9ebe0a15c9bebc', '0x431d67c49c100d4c',\n  '0x4cc5d4becb3e42b6', '0x597f299cfc657e2a', '0x5fcb6fab3ad6faec', '0x6c44198c4a475817'\n].map(n => BigInt(n))))();\nconst SHA512_Kh = /* @__PURE__ */ (() => K512[0])();\nconst SHA512_Kl = /* @__PURE__ */ (() => K512[1])();\n\n// Reusable temporary buffers\nconst SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);\nconst SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);\n\nexport class SHA512 extends HashMD<SHA512> {\n  // We cannot use array here since array allows indexing by variable\n  // which means optimizer/compiler cannot use registers.\n  // h -- high 32 bits, l -- low 32 bits\n  protected Ah: number = SHA512_IV[0] | 0;\n  protected Al: number = SHA512_IV[1] | 0;\n  protected Bh: number = SHA512_IV[2] | 0;\n  protected Bl: number = SHA512_IV[3] | 0;\n  protected Ch: number = SHA512_IV[4] | 0;\n  protected Cl: number = SHA512_IV[5] | 0;\n  protected Dh: number = SHA512_IV[6] | 0;\n  protected Dl: number = SHA512_IV[7] | 0;\n  protected Eh: number = SHA512_IV[8] | 0;\n  protected El: number = SHA512_IV[9] | 0;\n  protected Fh: number = SHA512_IV[10] | 0;\n  protected Fl: number = SHA512_IV[11] | 0;\n  protected Gh: number = SHA512_IV[12] | 0;\n  protected Gl: number = SHA512_IV[13] | 0;\n  protected Hh: number = SHA512_IV[14] | 0;\n  protected Hl: number = SHA512_IV[15] | 0;\n\n  constructor(outputLen: number = 64) {\n    super(128, outputLen, 16, false);\n  }\n  // prettier-ignore\n  protected get(): [\n    number, number, number, number, number, number, number, number,\n    number, number, number, number, number, number, number, number\n  ] {\n    const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n    return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];\n  }\n  // prettier-ignore\n  protected set(\n    Ah: number, Al: number, Bh: number, Bl: number, Ch: number, Cl: number, Dh: number, Dl: number,\n    Eh: number, El: number, Fh: number, Fl: number, Gh: number, Gl: number, Hh: number, Hl: number\n  ): void {\n    this.Ah = Ah | 0;\n    this.Al = Al | 0;\n    this.Bh = Bh | 0;\n    this.Bl = Bl | 0;\n    this.Ch = Ch | 0;\n    this.Cl = Cl | 0;\n    this.Dh = Dh | 0;\n    this.Dl = Dl | 0;\n    this.Eh = Eh | 0;\n    this.El = El | 0;\n    this.Fh = Fh | 0;\n    this.Fl = Fl | 0;\n    this.Gh = Gh | 0;\n    this.Gl = Gl | 0;\n    this.Hh = Hh | 0;\n    this.Hl = Hl | 0;\n  }\n  protected process(view: DataView, offset: number): void {\n    // Extend the first 16 words into the remaining 64 words w[16..79] of the message schedule array\n    for (let i = 0; i < 16; i++, offset += 4) {\n      SHA512_W_H[i] = view.getUint32(offset);\n      SHA512_W_L[i] = view.getUint32((offset += 4));\n    }\n    for (let i = 16; i < 80; i++) {\n      // s0 := (w[i-15] rightrotate 1) xor (w[i-15] rightrotate 8) xor (w[i-15] rightshift 7)\n      const W15h = SHA512_W_H[i - 15] | 0;\n      const W15l = SHA512_W_L[i - 15] | 0;\n      const s0h = u64.rotrSH(W15h, W15l, 1) ^ u64.rotrSH(W15h, W15l, 8) ^ u64.shrSH(W15h, W15l, 7);\n      const s0l = u64.rotrSL(W15h, W15l, 1) ^ u64.rotrSL(W15h, W15l, 8) ^ u64.shrSL(W15h, W15l, 7);\n      // s1 := (w[i-2] rightrotate 19) xor (w[i-2] rightrotate 61) xor (w[i-2] rightshift 6)\n      const W2h = SHA512_W_H[i - 2] | 0;\n      const W2l = SHA512_W_L[i - 2] | 0;\n      const s1h = u64.rotrSH(W2h, W2l, 19) ^ u64.rotrBH(W2h, W2l, 61) ^ u64.shrSH(W2h, W2l, 6);\n      const s1l = u64.rotrSL(W2h, W2l, 19) ^ u64.rotrBL(W2h, W2l, 61) ^ u64.shrSL(W2h, W2l, 6);\n      // SHA256_W[i] = s0 + s1 + SHA256_W[i - 7] + SHA256_W[i - 16];\n      const SUMl = u64.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);\n      const SUMh = u64.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);\n      SHA512_W_H[i] = SUMh | 0;\n      SHA512_W_L[i] = SUMl | 0;\n    }\n    let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n    // Compression function main loop, 80 rounds\n    for (let i = 0; i < 80; i++) {\n      // S1 := (e rightrotate 14) xor (e rightrotate 18) xor (e rightrotate 41)\n      const sigma1h = u64.rotrSH(Eh, El, 14) ^ u64.rotrSH(Eh, El, 18) ^ u64.rotrBH(Eh, El, 41);\n      const sigma1l = u64.rotrSL(Eh, El, 14) ^ u64.rotrSL(Eh, El, 18) ^ u64.rotrBL(Eh, El, 41);\n      //const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n      const CHIh = (Eh & Fh) ^ (~Eh & Gh);\n      const CHIl = (El & Fl) ^ (~El & Gl);\n      // T1 = H + sigma1 + Chi(E, F, G) + SHA512_K[i] + SHA512_W[i]\n      // prettier-ignore\n      const T1ll = u64.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);\n      const T1h = u64.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);\n      const T1l = T1ll | 0;\n      // S0 := (a rightrotate 28) xor (a rightrotate 34) xor (a rightrotate 39)\n      const sigma0h = u64.rotrSH(Ah, Al, 28) ^ u64.rotrBH(Ah, Al, 34) ^ u64.rotrBH(Ah, Al, 39);\n      const sigma0l = u64.rotrSL(Ah, Al, 28) ^ u64.rotrBL(Ah, Al, 34) ^ u64.rotrBL(Ah, Al, 39);\n      const MAJh = (Ah & Bh) ^ (Ah & Ch) ^ (Bh & Ch);\n      const MAJl = (Al & Bl) ^ (Al & Cl) ^ (Bl & Cl);\n      Hh = Gh | 0;\n      Hl = Gl | 0;\n      Gh = Fh | 0;\n      Gl = Fl | 0;\n      Fh = Eh | 0;\n      Fl = El | 0;\n      ({ h: Eh, l: El } = u64.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));\n      Dh = Ch | 0;\n      Dl = Cl | 0;\n      Ch = Bh | 0;\n      Cl = Bl | 0;\n      Bh = Ah | 0;\n      Bl = Al | 0;\n      const All = u64.add3L(T1l, sigma0l, MAJl);\n      Ah = u64.add3H(All, T1h, sigma0h, MAJh);\n      Al = All | 0;\n    }\n    // Add the compressed chunk to the current hash value\n    ({ h: Ah, l: Al } = u64.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));\n    ({ h: Bh, l: Bl } = u64.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));\n    ({ h: Ch, l: Cl } = u64.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));\n    ({ h: Dh, l: Dl } = u64.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));\n    ({ h: Eh, l: El } = u64.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));\n    ({ h: Fh, l: Fl } = u64.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));\n    ({ h: Gh, l: Gl } = u64.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));\n    ({ h: Hh, l: Hl } = u64.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));\n    this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);\n  }\n  protected roundClean(): void {\n    clean(SHA512_W_H, SHA512_W_L);\n  }\n  destroy(): void {\n    clean(this.buffer);\n    this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n  }\n}\n\nexport class SHA384 extends SHA512 {\n  protected Ah: number = SHA384_IV[0] | 0;\n  protected Al: number = SHA384_IV[1] | 0;\n  protected Bh: number = SHA384_IV[2] | 0;\n  protected Bl: number = SHA384_IV[3] | 0;\n  protected Ch: number = SHA384_IV[4] | 0;\n  protected Cl: number = SHA384_IV[5] | 0;\n  protected Dh: number = SHA384_IV[6] | 0;\n  protected Dl: number = SHA384_IV[7] | 0;\n  protected Eh: number = SHA384_IV[8] | 0;\n  protected El: number = SHA384_IV[9] | 0;\n  protected Fh: number = SHA384_IV[10] | 0;\n  protected Fl: number = SHA384_IV[11] | 0;\n  protected Gh: number = SHA384_IV[12] | 0;\n  protected Gl: number = SHA384_IV[13] | 0;\n  protected Hh: number = SHA384_IV[14] | 0;\n  protected Hl: number = SHA384_IV[15] | 0;\n\n  constructor() {\n    super(48);\n  }\n}\n\n/**\n * Truncated SHA512/256 and SHA512/224.\n * SHA512_IV is XORed with 0xa5a5a5a5a5a5a5a5, then used as \"intermediary\" IV of SHA512/t.\n * Then t hashes string to produce result IV.\n * See `test/misc/sha2-gen-iv.js`.\n */\n\n/** SHA512/224 IV */\nconst T224_IV = /* @__PURE__ */ Uint32Array.from([\n  0x8c3d37c8, 0x19544da2, 0x73e19966, 0x89dcd4d6, 0x1dfab7ae, 0x32ff9c82, 0x679dd514, 0x582f9fcf,\n  0x0f6d2b69, 0x7bd44da8, 0x77e36f73, 0x04c48942, 0x3f9d85a8, 0x6a1d36c8, 0x1112e6ad, 0x91d692a1,\n]);\n\n/** SHA512/256 IV */\nconst T256_IV = /* @__PURE__ */ Uint32Array.from([\n  0x22312194, 0xfc2bf72c, 0x9f555fa3, 0xc84c64c2, 0x2393b86b, 0x6f53b151, 0x96387719, 0x5940eabd,\n  0x96283ee2, 0xa88effe3, 0xbe5e1e25, 0x53863992, 0x2b0199fc, 0x2c85b8aa, 0x0eb72ddc, 0x81c52ca2,\n]);\n\nexport class SHA512_224 extends SHA512 {\n  protected Ah: number = T224_IV[0] | 0;\n  protected Al: number = T224_IV[1] | 0;\n  protected Bh: number = T224_IV[2] | 0;\n  protected Bl: number = T224_IV[3] | 0;\n  protected Ch: number = T224_IV[4] | 0;\n  protected Cl: number = T224_IV[5] | 0;\n  protected Dh: number = T224_IV[6] | 0;\n  protected Dl: number = T224_IV[7] | 0;\n  protected Eh: number = T224_IV[8] | 0;\n  protected El: number = T224_IV[9] | 0;\n  protected Fh: number = T224_IV[10] | 0;\n  protected Fl: number = T224_IV[11] | 0;\n  protected Gh: number = T224_IV[12] | 0;\n  protected Gl: number = T224_IV[13] | 0;\n  protected Hh: number = T224_IV[14] | 0;\n  protected Hl: number = T224_IV[15] | 0;\n\n  constructor() {\n    super(28);\n  }\n}\n\nexport class SHA512_256 extends SHA512 {\n  protected Ah: number = T256_IV[0] | 0;\n  protected Al: number = T256_IV[1] | 0;\n  protected Bh: number = T256_IV[2] | 0;\n  protected Bl: number = T256_IV[3] | 0;\n  protected Ch: number = T256_IV[4] | 0;\n  protected Cl: number = T256_IV[5] | 0;\n  protected Dh: number = T256_IV[6] | 0;\n  protected Dl: number = T256_IV[7] | 0;\n  protected Eh: number = T256_IV[8] | 0;\n  protected El: number = T256_IV[9] | 0;\n  protected Fh: number = T256_IV[10] | 0;\n  protected Fl: number = T256_IV[11] | 0;\n  protected Gh: number = T256_IV[12] | 0;\n  protected Gl: number = T256_IV[13] | 0;\n  protected Hh: number = T256_IV[14] | 0;\n  protected Hl: number = T256_IV[15] | 0;\n\n  constructor() {\n    super(32);\n  }\n}\n\n/**\n * SHA2-256 hash function from RFC 4634.\n *\n * It is the fastest JS hash, even faster than Blake3.\n * To break sha256 using birthday attack, attackers need to try 2^128 hashes.\n * BTC network is doing 2^70 hashes/sec (2^95 hashes/year) as per 2025.\n */\nexport const sha256: CHash = /* @__PURE__ */ createHasher(() => new SHA256());\n/** SHA2-224 hash function from RFC 4634 */\nexport const sha224: CHash = /* @__PURE__ */ createHasher(() => new SHA224());\n\n/** SHA2-512 hash function from RFC 4634. */\nexport const sha512: CHash = /* @__PURE__ */ createHasher(() => new SHA512());\n/** SHA2-384 hash function from RFC 4634. */\nexport const sha384: CHash = /* @__PURE__ */ createHasher(() => new SHA384());\n\n/**\n * SHA2-512/256 \"truncated\" hash function, with improved resistance to length extension attacks.\n * See the paper on [truncated SHA512](https://eprint.iacr.org/2010/548.pdf).\n */\nexport const sha512_256: CHash = /* @__PURE__ */ createHasher(() => new SHA512_256());\n/**\n * SHA2-512/224 \"truncated\" hash function, with improved resistance to length extension attacks.\n * See the paper on [truncated SHA512](https://eprint.iacr.org/2010/548.pdf).\n */\nexport const sha512_224: CHash = /* @__PURE__ */ createHasher(() => new SHA512_224());\n","/**\n * SHA2-256 a.k.a. sha256. In JS, it is the fastest hash, even faster than Blake3.\n *\n * To break sha256 using birthday attack, attackers need to try 2^128 hashes.\n * BTC network is doing 2^70 hashes/sec (2^95 hashes/year) as per 2025.\n *\n * Check out [FIPS 180-4](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf).\n * @module\n * @deprecated\n */\nimport {\n  SHA224 as SHA224n,\n  sha224 as sha224n,\n  SHA256 as SHA256n,\n  sha256 as sha256n,\n} from './sha2.ts';\n/** @deprecated Use import from `noble/hashes/sha2` module */\nexport const SHA256: typeof SHA256n = SHA256n;\n/** @deprecated Use import from `noble/hashes/sha2` module */\nexport const sha256: typeof sha256n = sha256n;\n/** @deprecated Use import from `noble/hashes/sha2` module */\nexport const SHA224: typeof SHA224n = SHA224n;\n/** @deprecated Use import from `noble/hashes/sha2` module */\nexport const sha224: typeof sha224n = sha224n;\n","export function hex(bytes: number[] | Uint8Array): string {\n    return (bytes as number[]).reduce((str, byte) => str + byte.toString(16).padStart(2, '0'), '');\n}\n","import {\n    ArrayTypeNode,\n    arrayTypeNode,\n    fixedCountNode,\n    numberTypeNode,\n    prefixedCountNode,\n    remainderCountNode,\n} from '@codama/nodes';\n\nimport { IdlV00TypeArray, IdlV00TypeVec } from '../idl';\nimport { typeNodeFromAnchorV00 } from './TypeNode';\n\nexport function arrayTypeNodeFromAnchorV00(idl: IdlV00TypeArray | IdlV00TypeVec): ArrayTypeNode {\n    if ('array' in idl) {\n        const item = typeNodeFromAnchorV00(idl.array[0]);\n        return arrayTypeNode(item, fixedCountNode(idl.array[1]));\n    }\n    const item = typeNodeFromAnchorV00(idl.vec);\n    if (idl.size === 'remainder') return arrayTypeNode(item, remainderCountNode());\n    return arrayTypeNode(item, prefixedCountNode(numberTypeNode(idl.size ?? 'u32')));\n}\n","import { CODAMA_ERROR__ANCHOR__UNRECOGNIZED_IDL_TYPE, CodamaError } from '@codama/errors';\nimport {\n    booleanTypeNode,\n    bytesTypeNode,\n    definedTypeLinkNode,\n    numberTypeNode,\n    publicKeyTypeNode,\n    sizePrefixTypeNode,\n    stringTypeNode,\n    TypeNode,\n} from '@codama/nodes';\n\nimport { IdlV00Type, IdlV00TypeDefTy, IdlV00TypeMap, IdlV00TypeSet } from '../idl';\nimport { arrayTypeNodeFromAnchorV00 } from './ArrayTypeNode';\nimport { enumTypeNodeFromAnchorV00 } from './EnumTypeNode';\nimport { mapTypeNodeFromAnchorV00 } from './MapTypeNode';\nimport { optionTypeNodeFromAnchorV00 } from './OptionTypeNode';\nimport { setTypeNodeFromAnchorV00 } from './SetTypeNode';\nimport { structTypeNodeFromAnchorV00 } from './StructTypeNode';\nimport { tupleTypeNodeFromAnchorV00 } from './TupleTypeNode';\n\nconst IDL_V00_TYPE_LEAVES = [\n    'string',\n    'publicKey',\n    'bytes',\n    'bool',\n    'u8',\n    'u16',\n    'u32',\n    'u64',\n    'u128',\n    'i8',\n    'i16',\n    'i32',\n    'i64',\n    'i128',\n    'f32',\n    'f64',\n    'shortU16',\n] as const;\n\nexport const typeNodeFromAnchorV00 = (idlType: IdlV00Type | IdlV00TypeDefTy): TypeNode => {\n    // Leaf.\n    if (typeof idlType === 'string' && IDL_V00_TYPE_LEAVES.includes(idlType)) {\n        if (idlType === 'bool') return booleanTypeNode();\n        if (idlType === 'publicKey') return publicKeyTypeNode();\n        if (idlType === 'string') return sizePrefixTypeNode(stringTypeNode('utf8'), numberTypeNode('u32'));\n        if (idlType === 'bytes') return sizePrefixTypeNode(bytesTypeNode(), numberTypeNode('u32'));\n        return numberTypeNode(idlType);\n    }\n\n    // Ensure eveything else is an object.\n    if (typeof idlType !== 'object') {\n        throw new CodamaError(CODAMA_ERROR__ANCHOR__UNRECOGNIZED_IDL_TYPE, {\n            idlType: JSON.stringify(idlType),\n        });\n    }\n\n    // Array.\n    if ('array' in idlType && isArrayOfSize(idlType.array, 2)) {\n        return arrayTypeNodeFromAnchorV00(idlType);\n    }\n\n    // Vec.\n    if ('vec' in idlType) {\n        return arrayTypeNodeFromAnchorV00(idlType);\n    }\n\n    // Defined link.\n    if ('defined' in idlType && typeof idlType.defined === 'string') {\n        return definedTypeLinkNode(idlType.defined);\n    }\n\n    // Enum.\n    if ('kind' in idlType && idlType.kind === 'enum' && 'variants' in idlType) {\n        return enumTypeNodeFromAnchorV00(idlType);\n    }\n\n    // Alias.\n    if ('kind' in idlType && idlType.kind === 'alias' && 'value' in idlType) {\n        return typeNodeFromAnchorV00(idlType.value);\n    }\n\n    // Map.\n    if (\n        ('hashMap' in idlType && isArrayOfSize(idlType.hashMap, 2)) ||\n        ('bTreeMap' in idlType && isArrayOfSize(idlType.bTreeMap, 2))\n    ) {\n        return mapTypeNodeFromAnchorV00(idlType as IdlV00TypeMap);\n    }\n\n    // Option.\n    if ('option' in idlType || 'coption' in idlType) {\n        return optionTypeNodeFromAnchorV00(idlType);\n    }\n\n    // Set.\n    if ('hashSet' in idlType || 'bTreeSet' in idlType) {\n        return setTypeNodeFromAnchorV00(idlType as IdlV00TypeSet);\n    }\n\n    // Struct.\n    if ('kind' in idlType && 'fields' in idlType && idlType.kind === 'struct') {\n        return structTypeNodeFromAnchorV00(idlType);\n    }\n\n    // Tuple.\n    if ('tuple' in idlType && Array.isArray(idlType.tuple)) {\n        return tupleTypeNodeFromAnchorV00(idlType);\n    }\n\n    throw new CodamaError(CODAMA_ERROR__ANCHOR__UNRECOGNIZED_IDL_TYPE, {\n        idlType: JSON.stringify(idlType),\n    });\n};\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction isArrayOfSize(array: any, size: number): boolean {\n    return Array.isArray(array) && array.length === size;\n}\n","import { EnumTypeNode, enumTypeNode, EnumVariantTypeNode, NumberTypeNode, numberTypeNode } from '@codama/nodes';\n\nimport { IdlV00EnumFieldsNamed, IdlV00EnumFieldsTuple, IdlV00EnumVariant, IdlV00TypeDefTyEnum } from '../idl';\nimport { enumEmptyVariantTypeNodeFromAnchorV00 } from './EnumEmptyVariantTypeNode';\nimport { enumStructVariantTypeNodeFromAnchorV00 } from './EnumStructVariantTypeNode';\nimport { enumTupleVariantTypeNodeFromAnchorV00 } from './EnumTupleVariantTypeNode';\n\nexport function enumTypeNodeFromAnchorV00(\n    idl: IdlV00TypeDefTyEnum,\n): EnumTypeNode<EnumVariantTypeNode[], NumberTypeNode> {\n    const variants = idl.variants.map((variant): EnumVariantTypeNode => {\n        if (!variant.fields || variant.fields.length <= 0) {\n            return enumEmptyVariantTypeNodeFromAnchorV00(variant);\n        }\n        if (isStructVariant(variant)) {\n            return enumStructVariantTypeNodeFromAnchorV00(variant);\n        }\n        return enumTupleVariantTypeNodeFromAnchorV00(variant as IdlV00EnumVariant & { fields: IdlV00EnumFieldsTuple });\n    });\n    return enumTypeNode(variants, {\n        size: idl.size ? numberTypeNode(idl.size) : undefined,\n    });\n}\n\nfunction isStructVariant(variant: IdlV00EnumVariant): variant is IdlV00EnumVariant & { fields: IdlV00EnumFieldsNamed } {\n    const field = variant.fields![0];\n    return typeof field === 'object' && 'name' in field && 'type' in field;\n}\n","import { EnumEmptyVariantTypeNode, enumEmptyVariantTypeNode } from '@codama/nodes';\n\nimport { IdlV00EnumVariant } from '../idl';\n\nexport function enumEmptyVariantTypeNodeFromAnchorV00(idl: IdlV00EnumVariant): EnumEmptyVariantTypeNode {\n    return enumEmptyVariantTypeNode(idl.name ?? '');\n}\n","import { EnumStructVariantTypeNode, enumStructVariantTypeNode, StructTypeNode } from '@codama/nodes';\n\nimport { IdlV00EnumFieldsNamed, IdlV00EnumVariant } from '../idl';\nimport { structTypeNodeFromAnchorV00 } from './StructTypeNode';\n\nexport function enumStructVariantTypeNodeFromAnchorV00(\n    idl: IdlV00EnumVariant & { fields: IdlV00EnumFieldsNamed },\n): EnumStructVariantTypeNode<StructTypeNode> {\n    return enumStructVariantTypeNode(\n        idl.name ?? '',\n        structTypeNodeFromAnchorV00({ fields: idl.fields, kind: 'struct' }),\n    );\n}\n","import { StructTypeNode, structTypeNode } from '@codama/nodes';\n\nimport { IdlV00TypeDefTyStruct } from '../idl';\nimport { structFieldTypeNodeFromAnchorV00 } from './StructFieldTypeNode';\n\nexport function structTypeNodeFromAnchorV00(idl: IdlV00TypeDefTyStruct): StructTypeNode {\n    return structTypeNode((idl.fields ?? []).map(structFieldTypeNodeFromAnchorV00));\n}\n","import { StructFieldTypeNode, structFieldTypeNode } from '@codama/nodes';\n\nimport { IdlV00Field } from '../idl';\nimport { typeNodeFromAnchorV00 } from './TypeNode';\n\nexport function structFieldTypeNodeFromAnchorV00(idl: IdlV00Field): StructFieldTypeNode {\n    return structFieldTypeNode({\n        docs: idl.docs ?? [],\n        name: idl.name ?? '',\n        type: typeNodeFromAnchorV00(idl.type),\n    });\n}\n","import { EnumTupleVariantTypeNode, enumTupleVariantTypeNode, TupleTypeNode } from '@codama/nodes';\n\nimport { IdlV00EnumFieldsTuple, IdlV00EnumVariant } from '../idl';\nimport { tupleTypeNodeFromAnchorV00 } from './TupleTypeNode';\n\nexport function enumTupleVariantTypeNodeFromAnchorV00(\n    idl: IdlV00EnumVariant & { fields: IdlV00EnumFieldsTuple },\n): EnumTupleVariantTypeNode<TupleTypeNode> {\n    return enumTupleVariantTypeNode(idl.name ?? '', tupleTypeNodeFromAnchorV00({ tuple: idl.fields }));\n}\n","import { TupleTypeNode, tupleTypeNode } from '@codama/nodes';\n\nimport { IdlV00TypeTuple } from '../idl';\nimport { typeNodeFromAnchorV00 } from './TypeNode';\n\nexport function tupleTypeNodeFromAnchorV00(idl: IdlV00TypeTuple): TupleTypeNode {\n    return tupleTypeNode(idl.tuple.map(typeNodeFromAnchorV00));\n}\n","import {\n    CountNode,\n    fixedCountNode,\n    MapTypeNode,\n    mapTypeNode,\n    numberTypeNode,\n    prefixedCountNode,\n    remainderCountNode,\n} from '@codama/nodes';\n\nimport { IdlV00TypeMap } from '../idl';\nimport { typeNodeFromAnchorV00 } from './TypeNode';\n\nexport function mapTypeNodeFromAnchorV00(idl: IdlV00TypeMap): MapTypeNode {\n    const [key, value] = 'hashMap' in idl ? idl.hashMap : idl.bTreeMap;\n    let size: CountNode | undefined;\n    if (idl.size === 'remainder') {\n        size = remainderCountNode();\n    } else if (typeof idl.size === 'number') {\n        size = fixedCountNode(idl.size);\n    } else {\n        size = prefixedCountNode(numberTypeNode(idl.size ?? 'u32'));\n    }\n    return mapTypeNode(typeNodeFromAnchorV00(key), typeNodeFromAnchorV00(value), size);\n}\n","import { numberTypeNode, OptionTypeNode, optionTypeNode } from '@codama/nodes';\n\nimport { IdlV00TypeOption } from '../idl';\nimport { typeNodeFromAnchorV00 } from './TypeNode';\n\nexport function optionTypeNodeFromAnchorV00(idl: IdlV00TypeOption): OptionTypeNode {\n    const item = 'option' in idl ? idl.option : idl.coption;\n    const defaultPrefix = numberTypeNode('option' in idl ? 'u8' : 'u32');\n    const defaultFixed = !('option' in idl);\n    return optionTypeNode(typeNodeFromAnchorV00(item), {\n        fixed: idl.fixed !== undefined ? idl.fixed : defaultFixed,\n        prefix: idl.prefix ? numberTypeNode(idl.prefix) : defaultPrefix,\n    });\n}\n","import {\n    fixedCountNode,\n    numberTypeNode,\n    prefixedCountNode,\n    remainderCountNode,\n    SetTypeNode,\n    setTypeNode,\n} from '@codama/nodes';\n\nimport { IdlV00TypeSet } from '../idl';\nimport { typeNodeFromAnchorV00 } from './TypeNode';\n\nexport function setTypeNodeFromAnchorV00(idl: IdlV00TypeSet): SetTypeNode {\n    const child = 'hashSet' in idl ? idl.hashSet : idl.bTreeSet;\n    let size: SetTypeNode['count'] | undefined;\n    if (idl.size === 'remainder') {\n        size = remainderCountNode();\n    } else if (typeof idl.size === 'number') {\n        size = fixedCountNode(idl.size);\n    } else {\n        size = prefixedCountNode(numberTypeNode(idl.size ?? 'u32'));\n    }\n    return setTypeNode(typeNodeFromAnchorV00(child), size);\n}\n","import { DefinedTypeNode, definedTypeNode } from '@codama/nodes';\n\nimport { IdlV00TypeDef } from './idl';\nimport { typeNodeFromAnchorV00 } from './typeNodes';\n\nexport function definedTypeNodeFromAnchorV00(idl: Partial<IdlV00TypeDef>): DefinedTypeNode {\n    const name = idl.name ?? '';\n    const idlType = idl.type ?? { fields: [], kind: 'struct' };\n    const type = typeNodeFromAnchorV00(idlType);\n    return definedTypeNode({ docs: idl.docs, name, type });\n}\n","import { ErrorNode, errorNode } from '@codama/nodes';\n\nimport { IdlV00ErrorCode } from './idl';\n\nexport function errorNodeFromAnchorV00(idl: Partial<IdlV00ErrorCode>): ErrorNode {\n    const name = idl.name ?? '';\n    const msg = idl.msg ?? '';\n    return errorNode({\n        code: idl.code ?? -1,\n        docs: idl.docs ?? [msg ? `${name}: ${msg}` : `${name}`],\n        message: msg,\n        name,\n    });\n}\n","import { InstructionAccountNode, instructionAccountNode } from '@codama/nodes';\n\nimport { IdlV00Account, IdlV00AccountItem } from './idl';\n\nexport function instructionAccountNodesFromAnchorV00(idl: IdlV00AccountItem[]): InstructionAccountNode[] {\n    return idl.flatMap(account =>\n        'accounts' in account\n            ? instructionAccountNodesFromAnchorV00(account.accounts)\n            : [instructionAccountNodeFromAnchorV00(account)],\n    );\n}\n\nexport function instructionAccountNodeFromAnchorV00(idl: IdlV00Account): InstructionAccountNode {\n    const isOptional = idl.optional ?? idl.isOptional ?? false;\n    const desc = idl.desc ? [idl.desc] : undefined;\n    return instructionAccountNode({\n        docs: idl.docs ?? desc ?? [],\n        isOptional,\n        isSigner: idl.isOptionalSigner ? 'either' : (idl.isSigner ?? false),\n        isWritable: idl.isMut ?? false,\n        name: idl.name ?? '',\n    });\n}\n","import { InstructionArgumentNode, instructionArgumentNode } from '@codama/nodes';\n\nimport { IdlV00Field } from './idl';\nimport { typeNodeFromAnchorV00 } from './typeNodes';\n\nexport function instructionArgumentNodeFromAnchorV00(idl: IdlV00Field): InstructionArgumentNode {\n    return instructionArgumentNode({\n        docs: idl.docs ?? [],\n        name: idl.name ?? '',\n        type: typeNodeFromAnchorV00(idl.type),\n    });\n}\n","import {\n    bytesTypeNode,\n    bytesValueNode,\n    camelCase,\n    DiscriminatorNode,\n    fieldDiscriminatorNode,\n    fixedSizeTypeNode,\n    instructionArgumentNode,\n    InstructionNode,\n    instructionNode,\n    numberValueNode,\n} from '@codama/nodes';\n\nimport { getAnchorInstructionDiscriminatorV00 } from '../discriminators';\nimport { IdlV00Instruction } from './idl';\nimport { instructionAccountNodesFromAnchorV00 } from './InstructionAccountNode';\nimport { instructionArgumentNodeFromAnchorV00 } from './InstructionArgumentNode';\nimport { typeNodeFromAnchorV00 } from './typeNodes';\n\nexport function instructionNodeFromAnchorV00(\n    idl: IdlV00Instruction,\n    ixIndex: number,\n    origin?: 'anchor' | 'shank',\n): InstructionNode {\n    const idlName = idl.name ?? '';\n    const name = camelCase(idlName);\n    let dataArguments = (idl.args ?? []).map(instructionArgumentNodeFromAnchorV00);\n\n    // Instruction discriminator.\n    let discriminators: DiscriminatorNode[] | undefined;\n    if (idl.discriminant) {\n        const discriminatorField = instructionArgumentNode({\n            defaultValue: numberValueNode(idl.discriminant.value),\n            defaultValueStrategy: 'omitted',\n            name: 'discriminator',\n            type: typeNodeFromAnchorV00(idl.discriminant.type),\n        });\n        dataArguments = [discriminatorField, ...dataArguments];\n        discriminators = [fieldDiscriminatorNode('discriminator')];\n    } else if (origin === 'anchor') {\n        const discriminatorField = instructionArgumentNode({\n            defaultValue: getAnchorInstructionDiscriminatorV00(idlName),\n            defaultValueStrategy: 'omitted',\n            name: 'discriminator',\n            type: fixedSizeTypeNode(bytesTypeNode(), 8),\n        });\n        dataArguments = [discriminatorField, ...dataArguments];\n        discriminators = [fieldDiscriminatorNode('discriminator')];\n    } else if (origin === 'shank') {\n        const discriminatorField = instructionArgumentNode({\n            defaultValue: bytesValueNode('base16', ixIndex.toString(16)),\n            defaultValueStrategy: 'omitted',\n            name: 'discriminator',\n            type: fixedSizeTypeNode(bytesTypeNode(), 1),\n        });\n        dataArguments = [discriminatorField, ...dataArguments];\n        discriminators = [fieldDiscriminatorNode('discriminator')];\n    }\n\n    return instructionNode({\n        accounts: instructionAccountNodesFromAnchorV00(idl.accounts ?? []),\n        arguments: dataArguments,\n        discriminators,\n        docs: idl.docs ?? [],\n        name,\n        optionalAccountStrategy: idl.legacyOptionalAccountsStrategy ? 'omitted' : 'programId',\n    });\n}\n","import {\n    booleanValueNode,\n    bytesTypeNode,\n    camelCase,\n    constantPdaSeedNode,\n    constantPdaSeedNodeFromProgramId,\n    numberValueNode,\n    PdaNode,\n    pdaNode,\n    PdaSeedNode,\n    stringTypeNode,\n    stringValueNode,\n    variablePdaSeedNode,\n} from '@codama/nodes';\n\nimport { IdlV00PdaDef } from './idl';\nimport { typeNodeFromAnchorV00 } from './typeNodes';\n\nexport function pdaNodeFromAnchorV00(idl: IdlV00PdaDef): PdaNode {\n    const name = camelCase(idl.name ?? '');\n    const seeds = (idl.seeds ?? []).map((seed): PdaSeedNode => {\n        if (seed.kind === 'constant') {\n            const type = (() => {\n                if (seed.type === 'string') return stringTypeNode('utf8');\n                if (seed.type === 'bytes') return bytesTypeNode();\n                return typeNodeFromAnchorV00(seed.type);\n            })();\n            const value = (() => {\n                if (typeof seed.value === 'string') return stringValueNode(seed.value);\n                if (typeof seed.value === 'number') return numberValueNode(seed.value);\n                return booleanValueNode(seed.value);\n            })();\n            return constantPdaSeedNode(type, value);\n        }\n        if (seed.kind === 'variable') {\n            return variablePdaSeedNode(\n                seed.name,\n                typeNodeFromAnchorV00(seed.type),\n                seed.description ? [seed.description] : [],\n            );\n        }\n        return constantPdaSeedNodeFromProgramId();\n    });\n    return pdaNode({ name, seeds });\n}\n","import { ProgramNode, programNode, ProgramVersion } from '@codama/nodes';\n\nimport { accountNodeFromAnchorV00 } from './AccountNode';\nimport { definedTypeNodeFromAnchorV00 } from './DefinedTypeNode';\nimport { errorNodeFromAnchorV00 } from './ErrorNode';\nimport { IdlV00 } from './idl';\nimport { instructionNodeFromAnchorV00 } from './InstructionNode';\nimport { pdaNodeFromAnchorV00 } from './PdaNode';\n\nexport function programNodeFromAnchorV00(idl: IdlV00): ProgramNode {\n    const origin = (idl?.metadata as { origin?: 'anchor' | 'shank' })?.origin ?? 'anchor';\n    const pdas = (idl.accounts ?? []).filter(account => (account.seeds ?? []).length > 0).map(pdaNodeFromAnchorV00);\n    const accounts = (idl.accounts ?? []).map(a => accountNodeFromAnchorV00(a, origin));\n    const instructions = (idl.instructions ?? []).map((instruction, index) =>\n        instructionNodeFromAnchorV00(instruction, index, origin),\n    );\n    return programNode({\n        accounts,\n        definedTypes: (idl?.types ?? []).map(definedTypeNodeFromAnchorV00),\n        errors: (idl?.errors ?? []).map(errorNodeFromAnchorV00),\n        instructions,\n        name: idl?.name ?? '',\n        origin,\n        pdas,\n        publicKey: (idl?.metadata as { address?: string })?.address ?? '',\n        version: idl.version as ProgramVersion,\n    });\n}\n","import { RootNode, rootNode } from '@codama/nodes';\n\nimport { IdlV00 } from './idl';\nimport { programNodeFromAnchorV00 } from './ProgramNode';\n\nexport function rootNodeFromAnchorV00(program: IdlV00, additionalPrograms: IdlV00[] = []): RootNode {\n    const programNode = programNodeFromAnchorV00(program);\n    const additionalProgramNodes = additionalPrograms.map(programNodeFromAnchorV00);\n    return rootNode(programNode, additionalProgramNodes);\n}\n","import { CODAMA_ERROR__ANCHOR__ACCOUNT_TYPE_MISSING, CodamaError } from '@codama/errors';\nimport {\n    AccountNode,\n    accountNode,\n    assertIsNode,\n    bytesTypeNode,\n    camelCase,\n    fieldDiscriminatorNode,\n    fixedSizeTypeNode,\n    structFieldTypeNode,\n    structTypeNode,\n} from '@codama/nodes';\n\nimport { getAnchorDiscriminatorV01 } from './../discriminators';\nimport { IdlV01Account, IdlV01TypeDef } from './idl';\nimport { typeNodeFromAnchorV01 } from './typeNodes';\n\nexport function accountNodeFromAnchorV01(idl: IdlV01Account, types: IdlV01TypeDef[]): AccountNode {\n    const name = camelCase(idl.name);\n    const type = types.find(({ name }) => name === idl.name);\n\n    if (!type) {\n        throw new CodamaError(CODAMA_ERROR__ANCHOR__ACCOUNT_TYPE_MISSING, { name: idl.name });\n    }\n\n    const data = typeNodeFromAnchorV01(type.type);\n    assertIsNode(data, 'structTypeNode');\n\n    const discriminator = structFieldTypeNode({\n        defaultValue: getAnchorDiscriminatorV01(idl.discriminator),\n        defaultValueStrategy: 'omitted',\n        name: 'discriminator',\n        type: fixedSizeTypeNode(bytesTypeNode(), idl.discriminator.length),\n    });\n\n    return accountNode({\n        data: structTypeNode([discriminator, ...data.fields]),\n        discriminators: [fieldDiscriminatorNode('discriminator')],\n        name,\n    });\n}\n\nexport function accountNodeFromAnchorV01WithTypeDefinition(types: IdlV01TypeDef[]) {\n    return function (idl: IdlV01Account): AccountNode {\n        return accountNodeFromAnchorV01(idl, types);\n    };\n}\n","import { ArrayTypeNode, arrayTypeNode, fixedCountNode, numberTypeNode, prefixedCountNode } from '@codama/nodes';\n\nimport { IdlV01TypeArray, IdlV01TypeVec } from '../idl';\nimport { typeNodeFromAnchorV01 } from './TypeNode';\n\nexport function arrayTypeNodeFromAnchorV01(idl: IdlV01TypeArray | IdlV01TypeVec): ArrayTypeNode {\n    if ('array' in idl) {\n        const item = typeNodeFromAnchorV01(idl.array[0]);\n        return arrayTypeNode(item, fixedCountNode(idl.array[1] as number));\n    }\n\n    const item = typeNodeFromAnchorV01(idl.vec);\n\n    return arrayTypeNode(item, prefixedCountNode(numberTypeNode('u32')));\n}\n","import { CODAMA_ERROR__ANCHOR__UNRECOGNIZED_IDL_TYPE, CodamaError } from '@codama/errors';\nimport {\n    booleanTypeNode,\n    bytesTypeNode,\n    definedTypeLinkNode,\n    numberTypeNode,\n    publicKeyTypeNode,\n    sizePrefixTypeNode,\n    stringTypeNode,\n    TypeNode,\n} from '@codama/nodes';\n\nimport {\n    IdlV01DefinedFields,\n    IdlV01DefinedFieldsNamed,\n    IdlV01DefinedFieldsTuple,\n    IdlV01Field,\n    IdlV01Type,\n    IdlV01TypeDefTy,\n} from '../idl';\nimport { arrayTypeNodeFromAnchorV01 } from './ArrayTypeNode';\nimport { enumTypeNodeFromAnchorV01 } from './EnumTypeNode';\nimport { optionTypeNodeFromAnchorV01 } from './OptionTypeNode';\nimport { structTypeNodeFromAnchorV01 } from './StructTypeNode';\nimport { tupleTypeNodeFromAnchorV01 } from './TupleTypeNode';\n\nconst IDL_V01_TYPE_LEAVES = [\n    'string',\n    'pubkey',\n    'bytes',\n    'bool',\n    'u8',\n    'u16',\n    'u32',\n    'u64',\n    'u128',\n    'i8',\n    'i16',\n    'i32',\n    'i64',\n    'i128',\n    'f32',\n    'f64',\n    'shortU16',\n] as const;\n\nexport const typeNodeFromAnchorV01 = (idlType: IdlV01Type | IdlV01TypeDefTy): TypeNode => {\n    // Leaf.\n    if (typeof idlType === 'string' && IDL_V01_TYPE_LEAVES.includes(idlType)) {\n        if (idlType === 'bool') return booleanTypeNode();\n        if (idlType === 'pubkey') return publicKeyTypeNode();\n        if (idlType === 'string') return sizePrefixTypeNode(stringTypeNode('utf8'), numberTypeNode('u32'));\n        if (idlType === 'bytes') return sizePrefixTypeNode(bytesTypeNode(), numberTypeNode('u32'));\n        return numberTypeNode(idlType);\n    }\n\n    // Ensure eveything else is an object.\n    if (typeof idlType !== 'object') {\n        throw new CodamaError(CODAMA_ERROR__ANCHOR__UNRECOGNIZED_IDL_TYPE, {\n            idlType: JSON.stringify(idlType),\n        });\n    }\n\n    // Array.\n    if ('array' in idlType && isArrayOfSize(idlType.array, 2)) {\n        return arrayTypeNodeFromAnchorV01(idlType);\n    }\n\n    // Vec.\n    if ('vec' in idlType) {\n        return arrayTypeNodeFromAnchorV01(idlType);\n    }\n\n    // Defined link.\n    // TODO: Support generics.\n    if ('defined' in idlType && typeof idlType.defined === 'object') {\n        return definedTypeLinkNode(idlType.defined.name);\n    }\n\n    // Enum.\n    if ('kind' in idlType && idlType.kind === 'enum' && 'variants' in idlType) {\n        return enumTypeNodeFromAnchorV01(idlType);\n    }\n\n    // Alias.\n    if ('kind' in idlType && idlType.kind === 'alias' && 'value' in idlType) {\n        return typeNodeFromAnchorV01(idlType.value);\n    }\n\n    // Option.\n    if ('option' in idlType) {\n        return optionTypeNodeFromAnchorV01(idlType);\n    }\n\n    if ('coption' in idlType) {\n        return optionTypeNodeFromAnchorV01(idlType);\n    }\n\n    // Struct and Tuple.\n    if ('kind' in idlType && idlType.kind === 'struct') {\n        const fields = idlType.fields ?? [];\n        if (isStructFieldArray(fields)) {\n            return structTypeNodeFromAnchorV01(idlType);\n        }\n        if (isTupleFieldArray(fields)) {\n            return tupleTypeNodeFromAnchorV01(fields);\n        }\n    }\n\n    throw new CodamaError(CODAMA_ERROR__ANCHOR__UNRECOGNIZED_IDL_TYPE, {\n        idlType: JSON.stringify(idlType),\n    });\n};\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction isArrayOfSize(array: any, size: number): boolean {\n    return Array.isArray(array) && array.length === size;\n}\n\nfunction isStructFieldArray(field: IdlV01DefinedFields): field is IdlV01DefinedFieldsNamed {\n    return field.every(isStructField);\n}\n\nfunction isTupleFieldArray(field: IdlV01DefinedFields): field is IdlV01DefinedFieldsTuple {\n    return field.every(f => !isStructField(f));\n}\n\nfunction isStructField(field: IdlV01Field | IdlV01Type): field is IdlV01Field {\n    return typeof field === 'object' && 'name' in field && 'type' in field;\n}\n","import { EnumTypeNode, enumTypeNode, EnumVariantTypeNode, NumberTypeNode } from '@codama/nodes';\n\nimport { IdlV01DefinedFieldsNamed, IdlV01DefinedFieldsTuple, IdlV01EnumVariant, IdlV01TypeDefTyEnum } from '../idl';\nimport { enumEmptyVariantTypeNodeFromAnchorV01 } from './EnumEmptyVariantTypeNode';\nimport { enumStructVariantTypeNodeFromAnchorV01 } from './EnumStructVariantTypeNode';\nimport { enumTupleVariantTypeNodeFromAnchorV01 } from './EnumTupleVariantTypeNode';\n\nexport function enumTypeNodeFromAnchorV01(\n    idl: IdlV01TypeDefTyEnum,\n): EnumTypeNode<EnumVariantTypeNode[], NumberTypeNode> {\n    const variants = idl.variants.map((variant): EnumVariantTypeNode => {\n        if (!variant.fields || variant.fields.length <= 0) {\n            return enumEmptyVariantTypeNodeFromAnchorV01(variant);\n        }\n        if (isStructVariant(variant)) {\n            return enumStructVariantTypeNodeFromAnchorV01(variant);\n        }\n        return enumTupleVariantTypeNodeFromAnchorV01(\n            variant as IdlV01EnumVariant & { fields: IdlV01DefinedFieldsTuple },\n        );\n    });\n    return enumTypeNode(variants);\n}\n\nfunction isStructVariant(\n    variant: IdlV01EnumVariant,\n): variant is IdlV01EnumVariant & { fields: IdlV01DefinedFieldsNamed } {\n    const field = variant.fields![0];\n    return typeof field === 'object' && 'name' in field && 'type' in field;\n}\n","import { EnumEmptyVariantTypeNode, enumEmptyVariantTypeNode } from '@codama/nodes';\n\nimport { IdlV01EnumVariant } from '../idl';\n\nexport function enumEmptyVariantTypeNodeFromAnchorV01(idl: IdlV01EnumVariant): EnumEmptyVariantTypeNode {\n    return enumEmptyVariantTypeNode(idl.name ?? '');\n}\n","import { EnumStructVariantTypeNode, enumStructVariantTypeNode, StructTypeNode } from '@codama/nodes';\n\nimport { IdlV01DefinedFieldsNamed, IdlV01EnumVariant } from '../idl';\nimport { structTypeNodeFromAnchorV01 } from './StructTypeNode';\n\nexport function enumStructVariantTypeNodeFromAnchorV01(\n    idl: IdlV01EnumVariant & { fields: IdlV01DefinedFieldsNamed },\n): EnumStructVariantTypeNode<StructTypeNode> {\n    return enumStructVariantTypeNode(\n        idl.name ?? '',\n        structTypeNodeFromAnchorV01({ fields: idl.fields, kind: 'struct' }),\n    );\n}\n","import { StructTypeNode, structTypeNode } from '@codama/nodes';\n\nimport { IdlV01DefinedFields, IdlV01TypeDefTyStruct } from '../idl';\nimport { structFieldTypeNodeFromAnchorV01 } from './StructFieldTypeNode';\n\nexport function structTypeNodeFromAnchorV01(idl: IdlV01TypeDefTyStruct): StructTypeNode {\n    const fields: IdlV01DefinedFields = idl.fields ?? [];\n\n    return structTypeNode(fields.map(structFieldTypeNodeFromAnchorV01));\n}\n","import { CODAMA_ERROR__ANCHOR__UNRECOGNIZED_IDL_TYPE, CodamaError } from '@codama/errors';\nimport { StructFieldTypeNode, structFieldTypeNode } from '@codama/nodes';\n\nimport { IdlV01Field, IdlV01Type } from '../idl';\nimport { typeNodeFromAnchorV01 } from './TypeNode';\n\nexport function structFieldTypeNodeFromAnchorV01(idl: IdlV01Field | IdlV01Type): StructFieldTypeNode {\n    if (!isStructField(idl)) {\n        throw new CodamaError(CODAMA_ERROR__ANCHOR__UNRECOGNIZED_IDL_TYPE, {\n            idlType: JSON.stringify(idl),\n        });\n    }\n\n    return structFieldTypeNode({\n        docs: idl.docs ?? [],\n        name: idl.name,\n        type: typeNodeFromAnchorV01(idl.type),\n    });\n}\n\nfunction isStructField(field: IdlV01Field | IdlV01Type): field is IdlV01Field {\n    return typeof field === 'object' && 'name' in field && 'type' in field;\n}\n","import { EnumTupleVariantTypeNode, enumTupleVariantTypeNode, TupleTypeNode } from '@codama/nodes';\n\nimport { IdlV01DefinedFieldsTuple, IdlV01EnumVariant } from '../idl';\nimport { tupleTypeNodeFromAnchorV01 } from './TupleTypeNode';\n\nexport function enumTupleVariantTypeNodeFromAnchorV01(\n    idl: IdlV01EnumVariant & { fields: IdlV01DefinedFieldsTuple },\n): EnumTupleVariantTypeNode<TupleTypeNode> {\n    return enumTupleVariantTypeNode(idl.name ?? '', tupleTypeNodeFromAnchorV01(idl.fields));\n}\n","import { TupleTypeNode, tupleTypeNode } from '@codama/nodes';\n\nimport { IdlV01DefinedFieldsTuple } from '../idl';\nimport { typeNodeFromAnchorV01 } from './TypeNode';\n\nexport function tupleTypeNodeFromAnchorV01(idl: IdlV01DefinedFieldsTuple): TupleTypeNode {\n    return tupleTypeNode(idl.map(typeNodeFromAnchorV01));\n}\n","import { numberTypeNode, OptionTypeNode, optionTypeNode } from '@codama/nodes';\n\nimport { IdlV01TypeCOption, IdlV01TypeOption } from '../idl';\nimport { typeNodeFromAnchorV01 } from './TypeNode';\n\nexport function optionTypeNodeFromAnchorV01(idl: IdlV01TypeCOption | IdlV01TypeOption): OptionTypeNode {\n    const item = 'option' in idl ? idl.option : idl.coption;\n    const hasOptionField = 'option' in idl;\n\n    const prefix = numberTypeNode(hasOptionField ? 'u8' : 'u32');\n    const fixed = !hasOptionField;\n\n    return optionTypeNode(typeNodeFromAnchorV01(item), {\n        fixed,\n        prefix,\n    });\n}\n","import { DefinedTypeNode, definedTypeNode } from '@codama/nodes';\n\nimport { IdlV01TypeDef } from './idl';\nimport { typeNodeFromAnchorV01 } from './typeNodes';\n\nexport function definedTypeNodeFromAnchorV01(idl: Partial<IdlV01TypeDef>): DefinedTypeNode {\n    const name = idl.name ?? '';\n    const idlType = idl.type ?? { fields: [], kind: 'struct' };\n    const type = typeNodeFromAnchorV01(idlType);\n    return definedTypeNode({ docs: idl.docs, name, type });\n}\n","import { ErrorNode, errorNode } from '@codama/nodes';\n\nimport { IdlV01ErrorCode } from './idl';\n\nexport function errorNodeFromAnchorV01(idl: Partial<IdlV01ErrorCode>): ErrorNode {\n    const name = idl.name ?? '';\n    const msg = idl.msg ?? '';\n    return errorNode({\n        code: idl.code ?? -1,\n        docs: `${name}: ${msg}`,\n        message: msg,\n        name,\n    });\n}\n","import {\n    CODAMA_ERROR__ANCHOR__ACCOUNT_TYPE_MISSING,\n    CODAMA_ERROR__ANCHOR__ARGUMENT_TYPE_MISSING,\n    CODAMA_ERROR__ANCHOR__PROGRAM_ID_KIND_UNIMPLEMENTED,\n    CODAMA_ERROR__ANCHOR__SEED_KIND_UNIMPLEMENTED,\n    CODAMA_ERROR__ANCHOR__TYPE_PATH_MISSING,\n    CodamaError,\n} from '@codama/errors';\nimport {\n    AccountNode,\n    accountValueNode,\n    argumentValueNode,\n    camelCase,\n    constantPdaSeedNodeFromBytes,\n    InstructionAccountNode,\n    instructionAccountNode,\n    InstructionArgumentNode,\n    pdaNode,\n    PdaSeedNode,\n    PdaSeedValueNode,\n    pdaSeedValueNode,\n    PdaValueNode,\n    pdaValueNode,\n    publicKeyTypeNode,\n    PublicKeyValueNode,\n    publicKeyValueNode,\n    resolveNestedTypeNode,\n    variablePdaSeedNode,\n} from '@codama/nodes';\nimport { getBase58Codec } from '@solana/codecs';\n\nimport { hex } from '../utils';\nimport { IdlV01InstructionAccount, IdlV01InstructionAccountItem, IdlV01Seed } from './idl';\n\nexport function instructionAccountNodesFromAnchorV01(\n    allAccounts: AccountNode[],\n    instructionArguments: InstructionArgumentNode[],\n    idl: IdlV01InstructionAccountItem[],\n): InstructionAccountNode[] {\n    return idl.flatMap(account =>\n        'accounts' in account\n            ? instructionAccountNodesFromAnchorV01(allAccounts, instructionArguments, account.accounts)\n            : [instructionAccountNodeFromAnchorV01(allAccounts, instructionArguments, account, idl)],\n    );\n}\n\nexport function instructionAccountNodeFromAnchorV01(\n    allAccounts: AccountNode[],\n    instructionArguments: InstructionArgumentNode[],\n    idl: IdlV01InstructionAccount,\n    parentIdl: IdlV01InstructionAccountItem[],\n): InstructionAccountNode {\n    const isOptional = idl.optional ?? false;\n    const docs = idl.docs ?? [];\n    const isSigner = idl.signer ?? false;\n    const isWritable = idl.writable ?? false;\n    const name = idl.name ?? '';\n    let defaultValue: PdaValueNode | PublicKeyValueNode | undefined;\n\n    if (idl.address) {\n        defaultValue = publicKeyValueNode(idl.address, name);\n    } else if (idl.pda) {\n        // TODO: Handle seeds with nested paths.\n        // Currently, we gracefully ignore PDA default values if we encounter seeds with nested paths.\n        const seedsWithNestedPaths = idl.pda.seeds.some(seed => 'path' in seed && seed.path.includes('.'));\n        if (!seedsWithNestedPaths) {\n            const [seeds, lookups] = idl.pda.seeds.reduce(\n                ([seeds, lookups], seed: IdlV01Seed) => {\n                    const kind = seed.kind;\n\n                    switch (kind) {\n                        case 'const':\n                            return [[...seeds, constantPdaSeedNodeFromBytes('base16', hex(seed.value))], lookups];\n                        case 'account': {\n                            const path = seed.path.split('.');\n                            if (path.length === 1) {\n                                return [\n                                    [...seeds, variablePdaSeedNode(seed.path, publicKeyTypeNode())],\n                                    [...lookups, pdaSeedValueNode(seed.path, accountValueNode(seed.path))],\n                                ];\n                            } else if (path.length === 2) {\n                                // TODO: Handle nested account paths.\n                                // Currently, this scenario is never reached.\n\n                                const accountName = camelCase(seed.account ?? '');\n                                const accountNode = allAccounts.find(({ name }) => name === accountName);\n                                if (!accountNode) {\n                                    throw new CodamaError(CODAMA_ERROR__ANCHOR__ACCOUNT_TYPE_MISSING, { kind });\n                                }\n\n                                const fieldName = camelCase(path[1]);\n                                const accountFields = resolveNestedTypeNode(accountNode.data).fields;\n                                const fieldNode = accountFields.find(({ name }) => name === fieldName);\n                                if (!fieldNode) {\n                                    throw new CodamaError(CODAMA_ERROR__ANCHOR__TYPE_PATH_MISSING, {\n                                        idlType: seed.account,\n                                        path: seed.path,\n                                    });\n                                }\n\n                                const seedName = camelCase(seed.path);\n                                return [[...seeds, variablePdaSeedNode(seedName, fieldNode.type)], []];\n                            } else {\n                                throw new CodamaError(CODAMA_ERROR__ANCHOR__TYPE_PATH_MISSING, {\n                                    idlType: seed,\n                                    path: seed.path,\n                                });\n                            }\n                        }\n                        case 'arg': {\n                            const argumentName = camelCase(seed.path);\n                            const argumentNode = instructionArguments.find(({ name }) => name === argumentName);\n                            if (!argumentNode) {\n                                throw new CodamaError(CODAMA_ERROR__ANCHOR__ARGUMENT_TYPE_MISSING, { name: seed.path });\n                            }\n\n                            return [\n                                [...seeds, variablePdaSeedNode(seed.path, argumentNode.type)],\n                                [...lookups, pdaSeedValueNode(seed.path, argumentValueNode(seed.path))],\n                            ];\n                        }\n                        default:\n                            throw new CodamaError(CODAMA_ERROR__ANCHOR__SEED_KIND_UNIMPLEMENTED, { kind });\n                    }\n                },\n                <[PdaSeedNode[], PdaSeedValueNode[]]>[[], []],\n            );\n\n            let programId: string | undefined;\n            if (idl.pda.program !== undefined) {\n                const kind = idl.pda.program.kind;\n                switch (kind) {\n                    case 'const': {\n                        programId = getBase58Codec().decode(new Uint8Array(idl.pda.program.value));\n                        break;\n                    }\n                    case 'account': {\n                        const programPath = idl.pda.program.path;\n                        const programNode = parentIdl.find(acc => acc.name == programPath);\n                        if (!(programNode && 'address' in programNode)) {\n                            throw new CodamaError(CODAMA_ERROR__ANCHOR__PROGRAM_ID_KIND_UNIMPLEMENTED, { kind });\n                        }\n                        programId = programNode.address;\n                        break;\n                    }\n                    default: {\n                        throw new CodamaError(CODAMA_ERROR__ANCHOR__PROGRAM_ID_KIND_UNIMPLEMENTED, { kind });\n                    }\n                }\n            }\n\n            defaultValue = pdaValueNode(\n                pdaNode({ name, seeds, ...(programId !== undefined ? { programId } : {}) }),\n                lookups,\n            );\n        }\n    }\n\n    return instructionAccountNode({\n        defaultValue,\n        docs,\n        isOptional,\n        isSigner,\n        isWritable,\n        name,\n    });\n}\n","import { InstructionArgumentNode, instructionArgumentNode } from '@codama/nodes';\n\nimport { IdlV01Field } from './idl';\nimport { typeNodeFromAnchorV01 } from './typeNodes';\n\nexport function instructionArgumentNodeFromAnchorV01(idl: IdlV01Field): InstructionArgumentNode {\n    return instructionArgumentNode({\n        docs: idl.docs ?? [],\n        name: idl.name,\n        type: typeNodeFromAnchorV01(idl.type),\n    });\n}\n","import {\n    AccountNode,\n    bytesTypeNode,\n    camelCase,\n    fieldDiscriminatorNode,\n    fixedSizeTypeNode,\n    instructionArgumentNode,\n    InstructionNode,\n    instructionNode,\n} from '@codama/nodes';\n\nimport { getAnchorDiscriminatorV01 } from '../discriminators';\nimport { IdlV01Instruction } from './idl';\nimport { instructionAccountNodesFromAnchorV01 } from './InstructionAccountNode';\nimport { instructionArgumentNodeFromAnchorV01 } from './InstructionArgumentNode';\n\nexport function instructionNodeFromAnchorV01(allAccounts: AccountNode[], idl: IdlV01Instruction): InstructionNode {\n    const name = idl.name;\n    let dataArguments = idl.args.map(instructionArgumentNodeFromAnchorV01);\n\n    const discriminatorField = instructionArgumentNode({\n        defaultValue: getAnchorDiscriminatorV01(idl.discriminator),\n        defaultValueStrategy: 'omitted',\n        name: 'discriminator',\n        type: fixedSizeTypeNode(bytesTypeNode(), idl.discriminator.length),\n    });\n    dataArguments = [discriminatorField, ...dataArguments];\n    const discriminators = [fieldDiscriminatorNode('discriminator')];\n\n    return instructionNode({\n        accounts: instructionAccountNodesFromAnchorV01(allAccounts, dataArguments, idl.accounts ?? []),\n        arguments: dataArguments,\n        discriminators,\n        docs: idl.docs ?? [],\n        name: camelCase(name),\n        optionalAccountStrategy: 'programId',\n    });\n}\n","import { ProgramNode, programNode, ProgramVersion } from '@codama/nodes';\n\nimport { accountNodeFromAnchorV01WithTypeDefinition } from './AccountNode';\nimport { definedTypeNodeFromAnchorV01 } from './DefinedTypeNode';\nimport { errorNodeFromAnchorV01 } from './ErrorNode';\nimport { IdlV01 } from './idl';\nimport { instructionNodeFromAnchorV01 } from './InstructionNode';\n\nexport function programNodeFromAnchorV01(idl: IdlV01): ProgramNode {\n    const types = idl.types ?? [];\n    const accounts = idl.accounts ?? [];\n    const instructions = idl.instructions ?? [];\n    const errors = idl.errors ?? [];\n\n    const filteredTypes = types.filter(type => !accounts.some(account => account.name === type.name));\n    const definedTypes = filteredTypes.map(definedTypeNodeFromAnchorV01);\n    const accountNodeFromAnchorV01 = accountNodeFromAnchorV01WithTypeDefinition(types);\n    const accountNodes = accounts.map(accountNodeFromAnchorV01);\n\n    return programNode({\n        accounts: accountNodes,\n        definedTypes,\n        errors: errors.map(errorNodeFromAnchorV01),\n        instructions: instructions.map(instruction => instructionNodeFromAnchorV01(accountNodes, instruction)),\n        name: idl.metadata.name,\n        origin: 'anchor',\n        publicKey: idl.address,\n        version: idl.metadata.version as ProgramVersion,\n    });\n}\n","import { RootNode, rootNode } from '@codama/nodes';\n\nimport { IdlV01 } from './idl';\nimport { programNodeFromAnchorV01 } from './ProgramNode';\n\nexport function rootNodeFromAnchorV01(program: IdlV01, additionalPrograms: IdlV01[] = []): RootNode {\n    const programNode = programNodeFromAnchorV01(program);\n    const additionalProgramNodes = additionalPrograms.map(programNodeFromAnchorV01);\n    return rootNode(programNode, additionalProgramNodes);\n}\n"],"mappings":"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","names":["import_visitors","import_nodes","import_nodes","sha256","sha256","import_nodes","import_nodes","import_nodes","import_nodes","import_nodes","import_nodes","import_nodes","import_nodes","import_nodes","import_nodes","import_nodes","import_nodes","item","import_nodes","import_nodes","import_nodes","import_nodes","import_nodes","import_nodes","import_nodes","import_nodes","programNode","import_errors","import_nodes","import_nodes","import_errors","import_nodes","import_nodes","import_nodes","import_nodes","import_nodes","import_errors","import_nodes","import_nodes","import_nodes","isStructVariant","import_nodes","isArrayOfSize","isStructField","item","name","import_nodes","import_nodes","import_errors","import_nodes","seeds","lookups","accountNode","name","programNode","import_nodes","import_nodes","import_nodes","accountNodeFromAnchorV01","import_nodes","programNode"]}