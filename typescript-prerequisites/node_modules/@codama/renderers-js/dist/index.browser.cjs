"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var index_exports = {};
__export(index_exports, {
  DEFAULT_NAME_TRANSFORMERS: () => DEFAULT_NAME_TRANSFORMERS,
  addToImportMap: () => addToImportMap,
  createImportMap: () => createImportMap,
  default: () => renderVisitor,
  getNameApi: () => getNameApi,
  getRenderMapVisitor: () => getRenderMapVisitor,
  getTypeManifestVisitor: () => getTypeManifestVisitor,
  importMapToString: () => importMapToString,
  mergeImportMaps: () => mergeImportMaps,
  mergeTypeManifests: () => mergeTypeManifests,
  parseImportInput: () => parseImportInput,
  removeFromImportMap: () => removeFromImportMap,
  renderVisitor: () => renderVisitor,
  typeManifest: () => typeManifest
});
module.exports = __toCommonJS(index_exports);

// src/utils/importMap.ts
var DEFAULT_EXTERNAL_MODULE_MAP = {
  solanaAccounts: "@solana/kit",
  solanaAddresses: "@solana/kit",
  solanaCodecsCore: "@solana/kit",
  solanaCodecsDataStructures: "@solana/kit",
  solanaCodecsNumbers: "@solana/kit",
  solanaCodecsStrings: "@solana/kit",
  solanaErrors: "@solana/kit",
  solanaInstructions: "@solana/kit",
  solanaOptions: "@solana/kit",
  solanaPrograms: "@solana/kit",
  solanaRpcTypes: "@solana/kit",
  solanaSigners: "@solana/kit"
};
var DEFAULT_GRANULAR_EXTERNAL_MODULE_MAP = {
  solanaAccounts: "@solana/accounts",
  solanaAddresses: "@solana/addresses",
  solanaCodecsCore: "@solana/codecs",
  solanaCodecsDataStructures: "@solana/codecs",
  solanaCodecsNumbers: "@solana/codecs",
  solanaCodecsStrings: "@solana/codecs",
  solanaErrors: "@solana/errors",
  solanaInstructions: "@solana/instructions",
  solanaOptions: "@solana/codecs",
  solanaPrograms: "@solana/programs",
  solanaRpcTypes: "@solana/rpc-types",
  solanaSigners: "@solana/signers"
};
var DEFAULT_INTERNAL_MODULE_MAP = {
  errors: "../errors",
  generated: "..",
  generatedAccounts: "../accounts",
  generatedErrors: "../errors",
  generatedInstructions: "../instructions",
  generatedPdas: "../pdas",
  generatedPrograms: "../programs",
  generatedTypes: "../types",
  hooked: "../../hooked",
  shared: "../shared",
  types: "../types"
};
function createImportMap() {
  return Object.freeze(/* @__PURE__ */ new Map());
}
function parseImportInput(input) {
  const matches = input.match(/^(type )?([^ ]+)(?: as (.+))?$/);
  if (!matches) return Object.freeze({ importedIdentifier: input, isType: false, usedIdentifier: input });
  const [_, isType, name, alias] = matches;
  return Object.freeze({
    importedIdentifier: name,
    isType: !!isType,
    usedIdentifier: alias ?? name
  });
}
function addToImportMap(importMap, module2, imports) {
  const parsedImports = imports.map(parseImportInput).map((i) => [i.usedIdentifier, i]);
  return mergeImportMaps([importMap, /* @__PURE__ */ new Map([[module2, new Map(parsedImports)]])]);
}
function removeFromImportMap(importMap, module2, usedIdentifiers) {
  const newMap = new Map(importMap);
  const newModuleMap = new Map(newMap.get(module2));
  usedIdentifiers.forEach((usedIdentifier) => {
    newModuleMap.delete(usedIdentifier);
  });
  if (newModuleMap.size === 0) {
    newMap.delete(module2);
  } else {
    newMap.set(module2, newModuleMap);
  }
  return Object.freeze(newMap);
}
function mergeImportMaps(importMaps) {
  if (importMaps.length === 0) return createImportMap();
  if (importMaps.length === 1) return importMaps[0];
  const mergedMap = new Map(importMaps[0]);
  for (const map of importMaps.slice(1)) {
    for (const [module2, imports] of map) {
      const mergedModuleMap = mergedMap.get(module2) ?? /* @__PURE__ */ new Map();
      for (const [usedIdentifier, importInfo] of imports) {
        const existingImportInfo = mergedModuleMap.get(usedIdentifier);
        const shouldOverwriteTypeOnly = existingImportInfo && existingImportInfo.importedIdentifier === importInfo.importedIdentifier && existingImportInfo.isType && !importInfo.isType;
        if (!existingImportInfo || shouldOverwriteTypeOnly) {
          mergedModuleMap.set(usedIdentifier, importInfo);
        }
      }
      mergedMap.set(module2, mergedModuleMap);
    }
  }
  return Object.freeze(mergedMap);
}
function importMapToString(importMap, dependencyMap = {}, useGranularImports = false) {
  const resolvedMap = resolveImportMapModules(importMap, dependencyMap, useGranularImports);
  return [...resolvedMap.entries()].sort(([a], [b]) => {
    const relative = Number(a.startsWith(".")) - Number(b.startsWith("."));
    if (relative !== 0) return relative;
    return a.localeCompare(b);
  }).map(([module2, imports]) => {
    const innerImports = [...imports.values()].map(importInfoToString).sort((a, b) => a.localeCompare(b)).join(", ");
    return `import { ${innerImports} } from '${module2}';`;
  }).join("\n");
}
function resolveImportMapModules(importMap, dependencyMap, useGranularImports) {
  const dependencyMapWithDefaults = {
    ...useGranularImports ? DEFAULT_GRANULAR_EXTERNAL_MODULE_MAP : DEFAULT_EXTERNAL_MODULE_MAP,
    ...DEFAULT_INTERNAL_MODULE_MAP,
    ...dependencyMap
  };
  return mergeImportMaps(
    [...importMap.entries()].map(([module2, imports]) => {
      const resolvedModule = dependencyMapWithDefaults[module2] ?? module2;
      return /* @__PURE__ */ new Map([[resolvedModule, imports]]);
    })
  );
}
function importInfoToString({ importedIdentifier, isType, usedIdentifier }) {
  const alias = importedIdentifier !== usedIdentifier ? ` as ${usedIdentifier}` : "";
  return `${isType ? "type " : ""}${importedIdentifier}${alias}`;
}

// src/utils/nameTransformers.ts
var import_nodes = require("@codama/nodes");
function getNameApi(transformers) {
  const helpers = {
    camelCase: import_nodes.camelCase,
    capitalize: import_nodes.capitalize,
    kebabCase: import_nodes.kebabCase,
    pascalCase: import_nodes.pascalCase,
    snakeCase: import_nodes.snakeCase,
    titleCase: import_nodes.titleCase
  };
  return Object.fromEntries(
    Object.entries(transformers).map(([key, transformer]) => [key, (name) => transformer(name, helpers)])
  );
}
var DEFAULT_NAME_TRANSFORMERS = {
  accountDecodeFunction: (name) => `decode${(0, import_nodes.pascalCase)(name)}`,
  accountFetchAllFunction: (name) => `fetchAll${(0, import_nodes.pascalCase)(name)}`,
  accountFetchAllMaybeFunction: (name) => `fetchAllMaybe${(0, import_nodes.pascalCase)(name)}`,
  accountFetchFromSeedsFunction: (name) => `fetch${(0, import_nodes.pascalCase)(name)}FromSeeds`,
  accountFetchFunction: (name) => `fetch${(0, import_nodes.pascalCase)(name)}`,
  accountFetchMaybeFromSeedsFunction: (name) => `fetchMaybe${(0, import_nodes.pascalCase)(name)}FromSeeds`,
  accountFetchMaybeFunction: (name) => `fetchMaybe${(0, import_nodes.pascalCase)(name)}`,
  accountGetSizeFunction: (name) => `get${(0, import_nodes.pascalCase)(name)}Size`,
  codecFunction: (name) => `get${(0, import_nodes.pascalCase)(name)}Codec`,
  constant: (name) => (0, import_nodes.snakeCase)(name).toUpperCase(),
  constantFunction: (name) => `get${(0, import_nodes.pascalCase)(name)}Bytes`,
  dataArgsType: (name) => `${(0, import_nodes.pascalCase)(name)}Args`,
  dataType: (name) => `${(0, import_nodes.pascalCase)(name)}`,
  decoderFunction: (name) => `get${(0, import_nodes.pascalCase)(name)}Decoder`,
  discriminatedUnionDiscriminator: () => "__kind",
  discriminatedUnionFunction: (name) => `${(0, import_nodes.camelCase)(name)}`,
  discriminatedUnionVariant: (name) => `${(0, import_nodes.pascalCase)(name)}`,
  encoderFunction: (name) => `get${(0, import_nodes.pascalCase)(name)}Encoder`,
  enumVariant: (name) => `${(0, import_nodes.pascalCase)(name)}`,
  instructionAsyncFunction: (name) => `get${(0, import_nodes.pascalCase)(name)}InstructionAsync`,
  instructionAsyncInputType: (name) => `${(0, import_nodes.pascalCase)(name)}AsyncInput`,
  instructionDataType: (name) => `${(0, import_nodes.pascalCase)(name)}InstructionData`,
  instructionExtraType: (name) => `${(0, import_nodes.pascalCase)(name)}InstructionExtra`,
  instructionParseFunction: (name) => `parse${(0, import_nodes.pascalCase)(name)}Instruction`,
  instructionParsedType: (name) => `Parsed${(0, import_nodes.pascalCase)(name)}Instruction`,
  instructionSyncFunction: (name) => `get${(0, import_nodes.pascalCase)(name)}Instruction`,
  instructionSyncInputType: (name) => `${(0, import_nodes.pascalCase)(name)}Input`,
  instructionType: (name) => `${(0, import_nodes.pascalCase)(name)}Instruction`,
  isDiscriminatedUnionFunction: (name) => `is${(0, import_nodes.pascalCase)(name)}`,
  pdaFindFunction: (name) => `find${(0, import_nodes.pascalCase)(name)}Pda`,
  pdaSeedsType: (name) => `${(0, import_nodes.pascalCase)(name)}Seeds`,
  programAccountsEnum: (name) => `${(0, import_nodes.pascalCase)(name)}Account`,
  programAccountsEnumVariant: (name) => `${(0, import_nodes.pascalCase)(name)}`,
  programAccountsIdentifierFunction: (name) => `identify${(0, import_nodes.pascalCase)(name)}Account`,
  programAddressConstant: (name) => `${(0, import_nodes.snakeCase)(name).toUpperCase()}_PROGRAM_ADDRESS`,
  programErrorConstant: (name) => (0, import_nodes.snakeCase)(name).toUpperCase(),
  programErrorConstantPrefix: (name) => `${(0, import_nodes.snakeCase)(name).toUpperCase()}_ERROR__`,
  programErrorMessagesMap: (name) => `${(0, import_nodes.camelCase)(name)}ErrorMessages`,
  programErrorUnion: (name) => `${(0, import_nodes.pascalCase)(name)}Error`,
  programGetErrorMessageFunction: (name) => `get${(0, import_nodes.pascalCase)(name)}ErrorMessage`,
  programInstructionsEnum: (name) => `${(0, import_nodes.pascalCase)(name)}Instruction`,
  programInstructionsEnumVariant: (name) => `${(0, import_nodes.pascalCase)(name)}`,
  programInstructionsIdentifierFunction: (name) => `identify${(0, import_nodes.pascalCase)(name)}Instruction`,
  programInstructionsParsedUnionType: (name) => `Parsed${(0, import_nodes.pascalCase)(name)}Instruction`,
  programIsErrorFunction: (name) => `is${(0, import_nodes.pascalCase)(name)}Error`,
  resolverFunction: (name) => `${(0, import_nodes.camelCase)(name)}`
};

// src/utils/fragment.ts
var import_renderers_core = require("@codama/renderers-core");
function createFragment(content) {
  return Object.freeze({ content, features: /* @__PURE__ */ new Set(), imports: createImportMap() });
}
function isFragment(value) {
  return typeof value === "object" && value !== null && "content" in value;
}
function fragment(template, ...items) {
  return (0, import_renderers_core.createFragmentTemplate)(template, items, isFragment, mergeFragments);
}
function mergeFragments(fragments, mergeContent) {
  const filteredFragments = fragments.filter((f) => f !== void 0);
  return Object.freeze({
    content: mergeContent(filteredFragments.map((fragment2) => fragment2.content)),
    features: new Set(filteredFragments.flatMap((f) => [...f.features])),
    imports: mergeImportMaps(filteredFragments.map((f) => f.imports))
  });
}
function use(importInput, module2) {
  const importInfo = parseImportInput(importInput);
  return addFragmentImports(createFragment(importInfo.usedIdentifier), module2, [importInput]);
}
function mergeFragmentImports(fragment2, importMaps) {
  return Object.freeze({ ...fragment2, imports: mergeImportMaps([fragment2.imports, ...importMaps]) });
}
function addFragmentImports(fragment2, module2, importInputs) {
  return Object.freeze({ ...fragment2, imports: addToImportMap(fragment2.imports, module2, importInputs) });
}
function removeFragmentImports(fragment2, module2, usedIdentifiers) {
  return Object.freeze({ ...fragment2, imports: removeFromImportMap(fragment2.imports, module2, usedIdentifiers) });
}
function addFragmentFeatures(fragment2, features) {
  return Object.freeze({ ...fragment2, features: /* @__PURE__ */ new Set([...fragment2.features, ...features]) });
}
function getExportAllFragment(module2) {
  return fragment`export * from '${module2}';`;
}
function getDocblockFragment(lines, withLineJump = false) {
  const lineJump = withLineJump ? "\n" : "";
  if (lines.length === 0) return;
  if (lines.length === 1) return fragment`/** ${lines[0]} */${lineJump}`;
  const prefixedLines = lines.map((line) => line ? ` * ${line}` : " *");
  return fragment`/**\n${prefixedLines.join("\n")}\n */${lineJump}`;
}
function getPageFragment(page, scope) {
  const header = getDocblockFragment([
    "This code was AUTOGENERATED using the Codama library.",
    "Please DO NOT EDIT THIS FILE, instead use visitors",
    "to add features, then rerun Codama to update it.",
    "",
    "@see https://github.com/codama-idl/codama"
  ]);
  const imports = page.imports.size === 0 ? void 0 : fragment`${importMapToString(page.imports, scope.dependencyMap, scope.useGranularImports)}`;
  return mergeFragments([header, imports, page], (cs) => cs.join("\n\n"));
}

// src/utils/typeManifest.ts
function typeManifest(input = {}) {
  return Object.freeze({
    decoder: fragment``,
    encoder: fragment``,
    isEnum: false,
    looseType: fragment``,
    strictType: fragment``,
    value: fragment``,
    ...input
  });
}
function mergeTypeManifests(manifests, options = {}) {
  const { mergeTypes, mergeCodecs, mergeValues } = options;
  const merge = (fragmentFn, mergeFn) => mergeFn ? mergeFragments(manifests.map(fragmentFn), mergeFn) : fragment``;
  return Object.freeze({
    decoder: merge((m) => m.decoder, mergeCodecs),
    encoder: merge((m) => m.encoder, mergeCodecs),
    isEnum: false,
    looseType: merge((m) => m.looseType, mergeTypes),
    strictType: merge((m) => m.strictType, mergeTypes),
    value: merge((m) => m.value, mergeValues)
  });
}

// src/visitors/getRenderMapVisitor.ts
var import_nodes28 = require("@codama/nodes");
var import_renderers_core13 = require("@codama/renderers-core");
var import_visitors_core29 = require("@codama/visitors-core");

// src/fragments/accountFetchHelpers.ts
var import_visitors_core2 = require("@codama/visitors-core");

// src/utils/async.ts
var import_nodes2 = require("@codama/nodes");
var import_visitors_core = require("@codama/visitors-core");
function hasAsyncFunction(instructionNode, resolvedInputs, asyncResolvers) {
  const hasByteDeltasAsync = (instructionNode.byteDeltas ?? []).some(
    ({ value }) => (0, import_nodes2.isNode)(value, "resolverValueNode") && asyncResolvers.includes(value.name)
  );
  const hasRemainingAccountsAsync = (instructionNode.remainingAccounts ?? []).some(
    ({ value }) => (0, import_nodes2.isNode)(value, "resolverValueNode") && asyncResolvers.includes(value.name)
  );
  return hasAsyncDefaultValues(resolvedInputs, asyncResolvers) || hasByteDeltasAsync || hasRemainingAccountsAsync;
}
function hasAsyncDefaultValues(resolvedInputs, asyncResolvers) {
  return resolvedInputs.some(
    (input) => !!input.defaultValue && isAsyncDefaultValue(input.defaultValue, asyncResolvers)
  );
}
function isAsyncDefaultValue(defaultValue, asyncResolvers) {
  switch (defaultValue.kind) {
    case "pdaValueNode":
      return true;
    case "resolverValueNode":
      return asyncResolvers.includes(defaultValue.name);
    case "conditionalValueNode":
      return isAsyncDefaultValue(defaultValue.condition, asyncResolvers) || (defaultValue.ifFalse == null ? false : isAsyncDefaultValue(defaultValue.ifFalse, asyncResolvers)) || (defaultValue.ifTrue == null ? false : isAsyncDefaultValue(defaultValue.ifTrue, asyncResolvers));
    default:
      return false;
  }
}
function getInstructionDependencies(input, asyncResolvers, useAsync) {
  if ((0, import_nodes2.isNode)(input, "instructionNode")) {
    return (0, import_visitors_core.deduplicateInstructionDependencies)([
      ...input.accounts.flatMap((x) => getInstructionDependencies(x, asyncResolvers, useAsync)),
      ...input.arguments.flatMap((x) => getInstructionDependencies(x, asyncResolvers, useAsync)),
      ...(input.extraArguments ?? []).flatMap((x) => getInstructionDependencies(x, asyncResolvers, useAsync))
    ]);
  }
  if (!input.defaultValue) return [];
  const getNestedDependencies = (defaultValue) => {
    if (!defaultValue) return [];
    return getInstructionDependencies({ ...input, defaultValue }, asyncResolvers, useAsync);
  };
  if ((0, import_nodes2.isNode)(input.defaultValue, ["accountValueNode", "accountBumpValueNode"])) {
    return [(0, import_nodes2.accountValueNode)(input.defaultValue.name)];
  }
  if ((0, import_nodes2.isNode)(input.defaultValue, ["argumentValueNode"])) {
    return [(0, import_nodes2.argumentValueNode)(input.defaultValue.name)];
  }
  if ((0, import_nodes2.isNode)(input.defaultValue, "pdaValueNode")) {
    const dependencies = /* @__PURE__ */ new Map();
    input.defaultValue.seeds.forEach((seed) => {
      if ((0, import_nodes2.isNode)(seed.value, ["accountValueNode", "argumentValueNode"])) {
        dependencies.set(seed.value.name, { ...seed.value });
      }
    });
    return [...dependencies.values()];
  }
  if ((0, import_nodes2.isNode)(input.defaultValue, "resolverValueNode")) {
    const isSynchronousResolver = !asyncResolvers.includes(input.defaultValue.name);
    if (useAsync || isSynchronousResolver) {
      return input.defaultValue.dependsOn ?? [];
    }
  }
  if ((0, import_nodes2.isNode)(input.defaultValue, "conditionalValueNode")) {
    return (0, import_visitors_core.deduplicateInstructionDependencies)([
      ...getNestedDependencies(input.defaultValue.condition),
      ...getNestedDependencies(input.defaultValue.ifTrue),
      ...getNestedDependencies(input.defaultValue.ifFalse)
    ]);
  }
  return [];
}

// src/utils/codecs.ts
var import_codecs_strings = require("@solana/codecs-strings");
function getBytesFromBytesValueNode(node) {
  switch (node.encoding) {
    case "utf8":
      return (0, import_codecs_strings.getUtf8Encoder)().encode(node.data);
    case "base16":
      return (0, import_codecs_strings.getBase16Encoder)().encode(node.data);
    case "base58":
      return (0, import_codecs_strings.getBase58Encoder)().encode(node.data);
    case "base64":
    default:
      return (0, import_codecs_strings.getBase64Encoder)().encode(node.data);
  }
}

// src/utils/customData.ts
var import_nodes3 = require("@codama/nodes");
var parseCustomDataOptions = (customDataOptions, defaultSuffix) => new Map(
  customDataOptions.map((o) => {
    const options = typeof o === "string" ? { name: o } : o;
    const importAs = (0, import_nodes3.camelCase)(options.importAs ?? `${options.name}${defaultSuffix}`);
    const importFrom = options.importFrom ?? "hooked";
    return [
      (0, import_nodes3.camelCase)(options.name),
      {
        extract: options.extract ?? false,
        extractAs: options.extractAs ? (0, import_nodes3.camelCase)(options.extractAs) : importAs,
        importAs,
        importFrom,
        linkNode: (0, import_nodes3.definedTypeLinkNode)(importAs)
      }
    ];
  })
);
var getDefinedTypeNodesToExtract = (nodes, parsedCustomDataOptions) => nodes.flatMap((node) => {
  const options = parsedCustomDataOptions.get(node.name);
  if (!options || !options.extract) return [];
  if ((0, import_nodes3.isNode)(node, "accountNode")) {
    return [(0, import_nodes3.definedTypeNode)({ name: options.extractAs, type: { ...node.data } })];
  }
  return [
    (0, import_nodes3.definedTypeNode)({
      name: options.extractAs,
      type: (0, import_nodes3.structTypeNodeFromInstructionArgumentNodes)(node.arguments)
    })
  ];
});

// src/utils/linkOverrides.ts
var import_errors = require("@codama/errors");
function getImportFromFactory(overrides, customAccountData, customInstructionData) {
  const customDataOverrides = Object.fromEntries(
    [...customAccountData.values(), ...customInstructionData.values()].map(({ importFrom, importAs }) => [
      importAs,
      importFrom
    ])
  );
  const linkOverrides = {
    accounts: overrides.accounts ?? {},
    definedTypes: { ...customDataOverrides, ...overrides.definedTypes },
    instructions: overrides.instructions ?? {},
    pdas: overrides.pdas ?? {},
    programs: overrides.programs ?? {},
    resolvers: overrides.resolvers ?? {}
  };
  return (node) => {
    const kind = node.kind;
    switch (kind) {
      case "accountLinkNode":
        return linkOverrides.accounts[node.name] ?? "generatedAccounts";
      case "definedTypeLinkNode":
        return linkOverrides.definedTypes[node.name] ?? "generatedTypes";
      case "instructionLinkNode":
        return linkOverrides.instructions[node.name] ?? "generatedInstructions";
      case "pdaLinkNode":
        return linkOverrides.pdas[node.name] ?? "generatedPdas";
      case "programLinkNode":
        return linkOverrides.programs[node.name] ?? "generatedPrograms";
      case "resolverValueNode":
        return linkOverrides.resolvers[node.name] ?? "hooked";
      default:
        throw new import_errors.CodamaError(import_errors.CODAMA_ERROR__UNEXPECTED_NODE_KIND, {
          expectedKinds: [
            "AccountLinkNode",
            "DefinedTypeLinkNode",
            "InstructionLinkNode",
            "PdaLinkNode",
            "ProgramLinkNode",
            "resolverValueNode"
          ],
          kind,
          node
        });
    }
  };
}

// src/fragments/accountFetchHelpers.ts
function getAccountFetchHelpersFragment(scope) {
  const { accountPath, typeManifest: typeManifest2, nameApi, customAccountData } = scope;
  const accountNode = (0, import_visitors_core2.getLastNodeFromPath)(accountPath);
  const decodeFunction = nameApi.accountDecodeFunction(accountNode.name);
  const fetchAllFunction = nameApi.accountFetchAllFunction(accountNode.name);
  const fetchAllMaybeFunction = nameApi.accountFetchAllMaybeFunction(accountNode.name);
  const fetchFunction = nameApi.accountFetchFunction(accountNode.name);
  const fetchMaybeFunction = nameApi.accountFetchMaybeFunction(accountNode.name);
  const hasCustomData = customAccountData.has(accountNode.name);
  const accountType = hasCustomData ? typeManifest2.strictType : nameApi.dataType(accountNode.name);
  const decoderFunction = hasCustomData ? typeManifest2.decoder : `${nameApi.decoderFunction(accountNode.name)}()`;
  return (0, import_visitors_core2.pipe)(
    fragment`export function ${decodeFunction}<TAddress extends string = string>(encodedAccount: EncodedAccount<TAddress>): Account<${accountType}, TAddress>;
export function ${decodeFunction}<TAddress extends string = string>(encodedAccount: MaybeEncodedAccount<TAddress>): MaybeAccount<${accountType}, TAddress>;
export function ${decodeFunction}<TAddress extends string = string>(encodedAccount: EncodedAccount<TAddress> | MaybeEncodedAccount<TAddress>): Account<${accountType}, TAddress> | MaybeAccount<${accountType}, TAddress> {
  return decodeAccount(encodedAccount as MaybeEncodedAccount<TAddress>, ${decoderFunction});
}

export async function ${fetchFunction}<TAddress extends string = string>(
  rpc: Parameters<typeof fetchEncodedAccount>[0],
  address: Address<TAddress>,
  config?: FetchAccountConfig,
): Promise<Account<${accountType}, TAddress>> {
  const maybeAccount = await ${fetchMaybeFunction}(rpc, address, config);
  assertAccountExists(maybeAccount);
  return maybeAccount;
}

export async function ${fetchMaybeFunction}<TAddress extends string = string>(
  rpc: Parameters<typeof fetchEncodedAccount>[0],
  address: Address<TAddress>,
  config?: FetchAccountConfig,
): Promise<MaybeAccount<${accountType}, TAddress>> {
  const maybeAccount = await fetchEncodedAccount(rpc, address, config);
  return ${decodeFunction}(maybeAccount);
}

export async function ${fetchAllFunction}(
  rpc: Parameters<typeof fetchEncodedAccounts>[0],
  addresses: Array<Address>,
  config?: FetchAccountsConfig,
): Promise<Account<${accountType}>[]> {
  const maybeAccounts = await ${fetchAllMaybeFunction}(rpc, addresses, config);
  assertAccountsExist(maybeAccounts);
  return maybeAccounts;
}

export async function ${fetchAllMaybeFunction}(
  rpc: Parameters<typeof fetchEncodedAccounts>[0],
  addresses: Array<Address>,
  config?: FetchAccountsConfig,
): Promise<MaybeAccount<${accountType}>[]> {
  const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config);
  return maybeAccounts.map((maybeAccount) => ${decodeFunction}(maybeAccount));
}`,
    (f) => addFragmentImports(f, "solanaAddresses", ["type Address"]),
    (f) => addFragmentImports(f, "solanaAccounts", [
      "type Account",
      "assertAccountExists",
      "assertAccountsExist",
      "decodeAccount",
      "type EncodedAccount",
      "fetchEncodedAccount",
      "fetchEncodedAccounts",
      "type FetchAccountConfig",
      "type FetchAccountsConfig",
      "type MaybeAccount",
      "type MaybeEncodedAccount"
    ])
  );
}

// src/fragments/accountPage.ts
var import_nodes9 = require("@codama/nodes");
var import_visitors_core7 = require("@codama/visitors-core");

// src/fragments/accountPdaHelpers.ts
var import_nodes4 = require("@codama/nodes");
var import_visitors_core3 = require("@codama/visitors-core");
function getAccountPdaHelpersFragment(scope) {
  const { accountPath, nameApi, linkables, customAccountData, typeManifest: typeManifest2 } = scope;
  const accountNode = (0, import_visitors_core3.getLastNodeFromPath)(accountPath);
  const pdaNode = accountNode.pda ? linkables.get([...accountPath, accountNode.pda]) : void 0;
  if (!pdaNode) return;
  const accountType = customAccountData.has(accountNode.name) ? typeManifest2.strictType : nameApi.dataType(accountNode.name);
  const importFrom = "generatedPdas";
  const pdaSeedsType = nameApi.pdaSeedsType(pdaNode.name);
  const findPdaFunction = nameApi.pdaFindFunction(pdaNode.name);
  const hasVariableSeeds = pdaNode.seeds.filter((0, import_nodes4.isNodeFilter)("variablePdaSeedNode")).length > 0;
  const fetchFromSeedsFunction = nameApi.accountFetchFromSeedsFunction(accountNode.name);
  const fetchMaybeFromSeedsFunction = nameApi.accountFetchMaybeFromSeedsFunction(accountNode.name);
  const fetchMaybeFunction = nameApi.accountFetchMaybeFunction(accountNode.name);
  return (0, import_visitors_core3.pipe)(
    fragment`export async function ${fetchFromSeedsFunction}(
  rpc: Parameters<typeof fetchEncodedAccount>[0],
  ${hasVariableSeeds ? `seeds: ${pdaSeedsType},` : ""}
  config: FetchAccountConfig & { programAddress?: Address } = {},
): Promise<Account<${accountType}>> {
  const maybeAccount = await ${fetchMaybeFromSeedsFunction}(rpc, ${hasVariableSeeds ? "seeds, " : ""}config);
  assertAccountExists(maybeAccount);
  return maybeAccount;
}

export async function ${fetchMaybeFromSeedsFunction}(
  rpc: Parameters<typeof fetchEncodedAccount>[0],
  ${hasVariableSeeds ? `seeds: ${pdaSeedsType},` : ""}
  config: FetchAccountConfig & { programAddress?: Address } = {},
): Promise<MaybeAccount<${accountType}>> {
  const { programAddress, ...fetchConfig } = config;
  const [address] = await ${findPdaFunction}(${hasVariableSeeds ? "seeds, " : ""}{ programAddress });
  return await ${fetchMaybeFunction}(rpc, address, fetchConfig);
}`,
    (f) => addFragmentImports(f, importFrom, hasVariableSeeds ? [pdaSeedsType, findPdaFunction] : [findPdaFunction]),
    (f) => addFragmentImports(f, "solanaAddresses", ["type Address"]),
    (f) => addFragmentImports(f, "solanaAccounts", [
      "type Account",
      "assertAccountExists",
      "type FetchAccountConfig",
      "type MaybeAccount"
    ])
  );
}

// src/fragments/accountSizeHelpers.ts
var import_visitors_core4 = require("@codama/visitors-core");
function getAccountSizeHelpersFragment(scope) {
  const { accountPath, nameApi } = scope;
  const accountNode = (0, import_visitors_core4.getLastNodeFromPath)(accountPath);
  if (accountNode.size == null) return;
  const getSizeFunction = nameApi.accountGetSizeFunction(accountNode.name);
  return fragment`export function ${getSizeFunction}(): number {
  return ${accountNode.size};
}`;
}

// src/fragments/accountType.ts
var import_nodes7 = require("@codama/nodes");
var import_visitors_core5 = require("@codama/visitors-core");

// src/fragments/type.ts
function getTypeFragment(scope) {
  const { name, manifest, nameApi, docs = [] } = scope;
  const docblock = getDocblockFragment(docs, true);
  const strictName = nameApi.dataType(name);
  const looseName = nameApi.dataArgsType(name);
  const aliasedLooseName = `export type ${looseName} = ${strictName};`;
  if (manifest.isEnum) {
    return fragment`${docblock}export enum ${strictName} ${manifest.strictType};\n\n${aliasedLooseName}`;
  }
  const looseExport = manifest.strictType.content === manifest.looseType.content ? aliasedLooseName : fragment`export type ${looseName} = ${manifest.looseType};`;
  return fragment`${docblock}export type ${strictName} = ${manifest.strictType};\n\n${looseExport}`;
}

// src/fragments/typeDecoder.ts
var import_nodes5 = require("@codama/nodes");
function getTypeDecoderFragment(scope) {
  const { name, node, manifest, nameApi, docs = [] } = scope;
  const decoderFunction = nameApi.decoderFunction(name);
  const strictName = nameApi.dataType(name);
  const docblock = getDocblockFragment(docs, true);
  const decoderType = use(
    typeof scope.size === "number" ? "type FixedSizeDecoder" : "type Decoder",
    "solanaCodecsCore"
  );
  const useTypeCast = (0, import_nodes5.isNode)(node, "enumTypeNode") && (0, import_nodes5.isDataEnum)(node) && typeof scope.size === "number";
  const typeCast = useTypeCast ? fragment` as ${decoderType}<${strictName}>` : "";
  return fragment`${docblock}export function ${decoderFunction}(): ${decoderType}<${strictName}> {
    return ${manifest.decoder}${typeCast};
}`;
}

// src/fragments/typeEncoder.ts
var import_nodes6 = require("@codama/nodes");
function getTypeEncoderFragment(scope) {
  const { name, node, manifest, nameApi, docs = [] } = scope;
  const encoderFunction = nameApi.encoderFunction(name);
  const looseName = nameApi.dataArgsType(name);
  const docblock = getDocblockFragment(docs, true);
  const encoderType = use(
    typeof scope.size === "number" ? "type FixedSizeEncoder" : "type Encoder",
    "solanaCodecsCore"
  );
  const useTypeCast = (0, import_nodes6.isNode)(node, "enumTypeNode") && (0, import_nodes6.isDataEnum)(node) && typeof scope.size === "number";
  const typeCast = useTypeCast ? fragment` as ${encoderType}<${looseName}>` : "";
  return fragment`${docblock}export function ${encoderFunction}(): ${encoderType}<${looseName}> {
    return ${manifest.encoder}${typeCast};
}`;
}

// src/fragments/typeCodec.ts
function getTypeCodecFragment(scope) {
  const { codecDocs = [], name, nameApi } = scope;
  const codecFunction = nameApi.codecFunction(name);
  const decoderFunction = nameApi.decoderFunction(name);
  const encoderFunction = nameApi.encoderFunction(name);
  const looseName = nameApi.dataArgsType(name);
  const strictName = nameApi.dataType(name);
  const docblock = getDocblockFragment(codecDocs, true);
  const codecType = use(typeof scope.size === "number" ? "type FixedSizeCodec" : "type Codec", "solanaCodecsCore");
  return mergeFragments(
    [
      getTypeEncoderFragment({ ...scope, docs: scope.encoderDocs }),
      getTypeDecoderFragment({ ...scope, docs: scope.decoderDocs }),
      fragment`${docblock}export function ${codecFunction}(): ${codecType}<${looseName}, ${strictName}> {
    return ${use("combineCodec", "solanaCodecsCore")}(${encoderFunction}(), ${decoderFunction}());
}`
    ],
    (renders) => renders.join("\n\n")
  );
}

// src/fragments/typeWithCodec.ts
function getTypeWithCodecFragment(scope) {
  return mergeFragments(
    [getTypeFragment({ ...scope, docs: scope.typeDocs }), getTypeCodecFragment(scope)],
    (renders) => renders.join("\n\n")
  );
}

// src/fragments/accountType.ts
function getAccountTypeFragment(scope) {
  const { accountPath, typeManifest: typeManifest2, nameApi, customAccountData } = scope;
  const accountNode = (0, import_visitors_core5.getLastNodeFromPath)(accountPath);
  if (customAccountData.has(accountNode.name)) return;
  return getTypeWithCodecFragment({
    manifest: typeManifest2,
    name: accountNode.name,
    nameApi,
    node: (0, import_nodes7.resolveNestedTypeNode)(accountNode.data),
    size: scope.size
  });
}

// src/fragments/discriminatorConstants.ts
var import_nodes8 = require("@codama/nodes");
var import_visitors_core6 = require("@codama/visitors-core");
function getDiscriminatorConstantsFragment(scope) {
  const fragments = scope.discriminatorNodes.map((node) => getDiscriminatorConstantFragment(node, scope)).filter(Boolean);
  return mergeFragments(fragments, (c) => c.join("\n\n"));
}
function getDiscriminatorConstantFragment(discriminatorNode, scope) {
  switch (discriminatorNode.kind) {
    case "constantDiscriminatorNode":
      return getConstantDiscriminatorConstantFragment(discriminatorNode, scope);
    case "fieldDiscriminatorNode":
      return getFieldDiscriminatorConstantFragment(discriminatorNode, scope);
    default:
      return null;
  }
}
function getConstantDiscriminatorConstantFragment(discriminatorNode, scope) {
  const { discriminatorNodes, typeManifestVisitor, prefix } = scope;
  const index = discriminatorNodes.filter((0, import_nodes8.isNodeFilter)("constantDiscriminatorNode")).indexOf(discriminatorNode);
  const suffix = index <= 0 ? "" : `_${index + 1}`;
  const name = (0, import_nodes8.camelCase)(`${prefix}_discriminator${suffix}`);
  const encoder = (0, import_visitors_core6.visit)(discriminatorNode.constant.type, typeManifestVisitor).encoder;
  const value = (0, import_visitors_core6.visit)(discriminatorNode.constant.value, typeManifestVisitor).value;
  return getConstantFragment({ ...scope, encoder, name, value });
}
function getFieldDiscriminatorConstantFragment(discriminatorNode, scope) {
  const { fields, prefix, typeManifestVisitor } = scope;
  const field = fields.find((f) => f.name === discriminatorNode.name);
  if (!field || !field.defaultValue || !(0, import_nodes8.isNode)(field.defaultValue, import_nodes8.VALUE_NODES)) {
    return null;
  }
  const name = (0, import_nodes8.camelCase)(`${prefix}_${discriminatorNode.name}`);
  const encoder = (0, import_visitors_core6.visit)(field.type, typeManifestVisitor).encoder;
  const value = (0, import_visitors_core6.visit)(field.defaultValue, typeManifestVisitor).value;
  return getConstantFragment({ ...scope, encoder, name, value });
}
function getConstantFragment(scope) {
  const { encoder, name, nameApi, value } = scope;
  const constantName = nameApi.constant(name);
  const constantFunction = nameApi.constantFunction(name);
  return fragment`export const ${constantName} = ${value};\n\nexport function ${constantFunction}() { return ${encoder}.encode(${constantName}); }`;
}

// src/fragments/accountPage.ts
function getAccountPageFragment(scope) {
  const node = (0, import_visitors_core7.getLastNodeFromPath)(scope.accountPath);
  if (!(0, import_visitors_core7.findProgramNodeFromPath)(scope.accountPath)) {
    throw new Error("Account must be visited inside a program.");
  }
  const typeManifest2 = (0, import_visitors_core7.visit)(node, scope.typeManifestVisitor);
  const fields = (0, import_nodes9.resolveNestedTypeNode)(node.data).fields;
  return mergeFragments(
    [
      getDiscriminatorConstantsFragment({
        ...scope,
        discriminatorNodes: node.discriminators ?? [],
        fields,
        prefix: node.name
      }),
      getAccountTypeFragment({ ...scope, typeManifest: typeManifest2 }),
      getAccountFetchHelpersFragment({ ...scope, typeManifest: typeManifest2 }),
      getAccountSizeHelpersFragment(scope),
      getAccountPdaHelpersFragment({ ...scope, typeManifest: typeManifest2 })
    ],
    (cs) => cs.join("\n\n")
  );
}

// src/fragments/discriminatorCondition.ts
var import_nodes10 = require("@codama/nodes");
var import_renderers_core2 = require("@codama/renderers-core");
var import_visitors_core8 = require("@codama/visitors-core");
var import_codecs_strings2 = require("@solana/codecs-strings");
function getDiscriminatorConditionFragment(scope) {
  return (0, import_visitors_core8.pipe)(
    mergeFragments(
      scope.discriminators.flatMap((discriminator) => {
        if ((0, import_nodes10.isNode)(discriminator, "sizeDiscriminatorNode")) {
          return [getSizeConditionFragment(discriminator, scope)];
        }
        if ((0, import_nodes10.isNode)(discriminator, "constantDiscriminatorNode")) {
          return [getByteConditionFragment(discriminator, scope)];
        }
        if ((0, import_nodes10.isNode)(discriminator, "fieldDiscriminatorNode")) {
          return [getFieldConditionFragment(discriminator, scope)];
        }
        return [];
      }),
      (c) => c.join(" && ")
    ),
    (f) => (0, import_renderers_core2.mapFragmentContent)(f, (c) => `if (${c}) { ${scope.ifTrue} }`)
  );
}
function getSizeConditionFragment(discriminator, scope) {
  const { dataName } = scope;
  return fragment`${dataName}.length === ${discriminator.size}`;
}
function getByteConditionFragment(discriminator, scope) {
  const { dataName, typeManifestVisitor } = scope;
  const constant = (0, import_visitors_core8.visit)(discriminator.constant, typeManifestVisitor).value;
  return fragment`${use("containsBytes", "solanaCodecsCore")}(${dataName}, ${constant}, ${discriminator.offset})`;
}
function getFieldConditionFragment(discriminator, scope) {
  const field = scope.struct.fields.find((f) => f.name === discriminator.name);
  if (!field || !field.defaultValue) {
    throw new Error(
      `Field discriminator "${discriminator.name}" does not have a matching argument with default value.`
    );
  }
  if ((0, import_nodes10.isNode)(field.type, "arrayTypeNode") && (0, import_nodes10.isNode)(field.type.item, "numberTypeNode") && field.type.item.format === "u8" && (0, import_nodes10.isNode)(field.type.count, "fixedCountNode") && (0, import_nodes10.isNode)(field.defaultValue, "arrayValueNode") && field.defaultValue.items.every((0, import_nodes10.isNodeFilter)("numberValueNode"))) {
    const base64Bytes = (0, import_codecs_strings2.getBase64Decoder)().decode(
      new Uint8Array(field.defaultValue.items.map((node) => node.number))
    );
    return getByteConditionFragment(
      (0, import_nodes10.constantDiscriminatorNode)((0, import_nodes10.constantValueNodeFromBytes)("base64", base64Bytes), discriminator.offset),
      scope
    );
  }
  return getByteConditionFragment(
    (0, import_nodes10.constantDiscriminatorNode)((0, import_nodes10.constantValueNode)(field.type, field.defaultValue), discriminator.offset),
    scope
  );
}

// src/fragments/errorPage.ts
function getErrorPageFragment(scope) {
  return mergeFragments(
    [
      getConstantsFragment(scope),
      getConstantUnionTypeFragment(scope),
      getErrorMessagesFragment(scope),
      getErrorMessageFunctionFragment(scope),
      getIsErrorFunctionFragment(scope)
    ],
    (cs) => cs.join("\n\n")
  );
}
function getConstantsFragment(scope) {
  const constantPrefix = scope.nameApi.programErrorConstantPrefix(scope.programNode.name);
  return mergeFragments(
    [...scope.programNode.errors].sort((a, b) => a.code - b.code).map((error) => {
      const docs = getDocblockFragment(error.docs ?? [], true);
      const name = constantPrefix + scope.nameApi.programErrorConstant(error.name);
      return fragment`${docs}export const ${name} = 0x${error.code.toString(16)}; // ${error.code}`;
    }),
    (cs) => cs.join("\n")
  );
}
function getConstantUnionTypeFragment(scope) {
  const constantPrefix = scope.nameApi.programErrorConstantPrefix(scope.programNode.name);
  const typeName = scope.nameApi.programErrorUnion(scope.programNode.name);
  const errorTypes = mergeFragments(
    [...scope.programNode.errors].sort((a, b) => a.name.localeCompare(b.name)).map((error) => fragment`typeof ${constantPrefix + scope.nameApi.programErrorConstant(error.name)}`),
    (cs) => cs.join(" | ")
  );
  return fragment`export type ${typeName} = ${errorTypes};`;
}
function getErrorMessagesFragment(scope) {
  const mapName = scope.nameApi.programErrorMessagesMap(scope.programNode.name);
  const errorUnionType = scope.nameApi.programErrorUnion(scope.programNode.name);
  const constantPrefix = scope.nameApi.programErrorConstantPrefix(scope.programNode.name);
  const messageEntries = mergeFragments(
    [...scope.programNode.errors].sort((a, b) => a.name.localeCompare(b.name)).map((error) => {
      const constantName = constantPrefix + scope.nameApi.programErrorConstant(error.name);
      const escapedMessage = error.message.replace(/`/g, "\\`");
      return fragment`[${constantName}]: \`${escapedMessage}\``;
    }),
    (cs) => cs.join(", ")
  );
  return fragment`let ${mapName}: Record<${errorUnionType}, string> | undefined;
if (process.env.NODE_ENV !== 'production') {
  ${mapName} = { ${messageEntries} };
}`;
}
function getErrorMessageFunctionFragment(scope) {
  const functionName = scope.nameApi.programGetErrorMessageFunction(scope.programNode.name);
  const errorUnionType = scope.nameApi.programErrorUnion(scope.programNode.name);
  const messageMapName = scope.nameApi.programErrorMessagesMap(scope.programNode.name);
  return fragment`export function ${functionName}(code: ${errorUnionType}): string {
  if (process.env.NODE_ENV !== 'production') {
    return (${messageMapName} as Record<${errorUnionType}, string>)[code];
  }

  return 'Error message not available in production bundles.';
}`;
}
function getIsErrorFunctionFragment(scope) {
  const { programNode, nameApi } = scope;
  const programAddressConstant = use(nameApi.programAddressConstant(programNode.name), "generatedPrograms");
  const functionName = nameApi.programIsErrorFunction(programNode.name);
  const programErrorUnion = nameApi.programErrorUnion(programNode.name);
  return fragment`export function ${functionName}<TProgramErrorCode extends ${programErrorUnion}>(
    error: unknown,
    transactionMessage: { instructions: Record<number, { programAddress: ${use("type Address", "solanaAddresses")} }> },
    code?: TProgramErrorCode,
): error is ${use("type SolanaError", "solanaErrors")}<typeof ${use("type SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM", "solanaErrors")}> & Readonly<{ context: Readonly<{ code: TProgramErrorCode }> }> {
  return ${use("isProgramError", "solanaPrograms")}<TProgramErrorCode>(error, transactionMessage, ${programAddressConstant}, code);
}`;
}

// src/fragments/indexPage.ts
function getIndexPageFragment(items) {
  if (items.length === 0) return;
  const names = items.map((item) => item.name).sort((a, b) => a.localeCompare(b)).map((name) => getExportAllFragment(`./${name}`));
  return mergeFragments(names, (cs) => cs.join("\n"));
}

// src/fragments/instructionAccountMeta.ts
var import_nodes11 = require("@codama/nodes");
function getInstructionAccountMetaFragment(instructionAccountNode) {
  const typeParam = `TAccount${(0, import_nodes11.pascalCase)(instructionAccountNode.name)}`;
  if (instructionAccountNode.isSigner === true && instructionAccountNode.isWritable) {
    return fragment`${use("type WritableSignerAccount", "solanaInstructions")}<${typeParam}> & ${use("type AccountSignerMeta", "solanaSigners")}<${typeParam}>`;
  }
  if (instructionAccountNode.isSigner === true) {
    return fragment`${use("type ReadonlySignerAccount", "solanaInstructions")}<${typeParam}> & ${use("type AccountSignerMeta", "solanaSigners")}<${typeParam}>`;
  }
  if (instructionAccountNode.isWritable) {
    return fragment`${use("type WritableAccount", "solanaInstructions")}<${typeParam}>`;
  }
  return fragment`${use("type ReadonlyAccount", "solanaInstructions")}<${typeParam}>`;
}

// src/fragments/instructionAccountTypeParam.ts
var import_nodes12 = require("@codama/nodes");
var import_visitors_core9 = require("@codama/visitors-core");
function getInstructionAccountTypeParamFragment(scope) {
  const { instructionAccountPath, allowAccountMeta, linkables } = scope;
  const instructionAccountNode = (0, import_visitors_core9.getLastNodeFromPath)(instructionAccountPath);
  const instructionNode = (0, import_visitors_core9.findInstructionNodeFromPath)(instructionAccountPath);
  const programNode = (0, import_visitors_core9.findProgramNodeFromPath)(instructionAccountPath);
  const typeParam = `TAccount${(0, import_nodes12.pascalCase)(instructionAccountNode.name)}`;
  const accountMeta = allowAccountMeta ? fragment` | ${use("type AccountMeta", "solanaInstructions")}<string>` : void 0;
  if (instructionNode.optionalAccountStrategy === "omitted" && instructionAccountNode.isOptional) {
    return fragment`${typeParam} extends string${accountMeta} | undefined = undefined`;
  }
  const defaultAddress = getDefaultAddress(instructionAccountNode.defaultValue, programNode.publicKey, linkables);
  return fragment`${typeParam} extends string${accountMeta} = ${defaultAddress}`;
}
function getDefaultAddress(defaultValue, programId, linkables) {
  switch (defaultValue?.kind) {
    case "publicKeyValueNode":
      return `"${defaultValue.publicKey}"`;
    case "programLinkNode":
      const programNode = linkables.get([defaultValue]);
      return programNode ? `"${programNode.publicKey}"` : "string";
    case "programIdValueNode":
      return `"${programId}"`;
    default:
      return "string";
  }
}

// src/fragments/instructionByteDelta.ts
var import_nodes13 = require("@codama/nodes");
var import_renderers_core3 = require("@codama/renderers-core");
var import_visitors_core10 = require("@codama/visitors-core");
function getInstructionByteDeltaFragment(scope) {
  const { byteDeltas } = (0, import_visitors_core10.getLastNodeFromPath)(scope.instructionPath);
  const fragments = (byteDeltas ?? []).flatMap((c) => getByteDeltaFragment(c, scope));
  if (fragments.length === 0) return;
  return mergeFragments(
    fragments,
    (c) => `// Bytes created or reallocated by the instruction.
const byteDelta: number = [${c.join(",")}].reduce((a, b) => a + b, 0);`
  );
}
function getByteDeltaFragment(byteDelta, scope) {
  let bytesFragment = (() => {
    if ((0, import_nodes13.isNode)(byteDelta.value, "numberValueNode")) {
      return getNumberValueNodeFragment(byteDelta);
    }
    if ((0, import_nodes13.isNode)(byteDelta.value, "argumentValueNode")) {
      return getArgumentValueNodeFragment(byteDelta);
    }
    if ((0, import_nodes13.isNode)(byteDelta.value, "accountLinkNode")) {
      return getAccountLinkNodeFragment(byteDelta, scope);
    }
    if ((0, import_nodes13.isNode)(byteDelta.value, "resolverValueNode")) {
      return getResolverValueNodeFragment(byteDelta, scope);
    }
    return null;
  })();
  if (bytesFragment === null) return [];
  if (byteDelta.withHeader) {
    bytesFragment = fragment`${bytesFragment} + ${use("BASE_ACCOUNT_SIZE", "solanaAccounts")}`;
  }
  if (byteDelta.subtract) {
    bytesFragment = (0, import_visitors_core10.pipe)(bytesFragment, (f) => (0, import_renderers_core3.mapFragmentContent)(f, (c) => `- (${c})`));
  }
  return [bytesFragment];
}
function getNumberValueNodeFragment(byteDelta) {
  (0, import_nodes13.assertIsNode)(byteDelta.value, "numberValueNode");
  return fragment`${byteDelta.value.number}`;
}
function getArgumentValueNodeFragment(byteDelta) {
  (0, import_nodes13.assertIsNode)(byteDelta.value, "argumentValueNode");
  const argumentName = (0, import_nodes13.camelCase)(byteDelta.value.name);
  return fragment`Number(args.${argumentName})`;
}
function getAccountLinkNodeFragment(byteDelta, scope) {
  (0, import_nodes13.assertIsNode)(byteDelta.value, "accountLinkNode");
  const functionName = use(
    scope.nameApi.accountGetSizeFunction(byteDelta.value.name),
    scope.getImportFrom(byteDelta.value)
  );
  return fragment`${functionName}()`;
}
function getResolverValueNodeFragment(byteDelta, scope) {
  (0, import_nodes13.assertIsNode)(byteDelta.value, "resolverValueNode");
  const isAsync = scope.asyncResolvers.includes(byteDelta.value.name);
  if (!scope.useAsync && isAsync) return null;
  const awaitKeyword = scope.useAsync && isAsync ? "await " : "";
  const functionName = use(
    scope.nameApi.resolverFunction(byteDelta.value.name),
    scope.getImportFrom(byteDelta.value)
  );
  return (0, import_visitors_core10.pipe)(
    fragment`${awaitKeyword}${functionName}(resolverScope)`,
    (f) => addFragmentFeatures(f, ["instruction:resolverScopeVariable"])
  );
}

// src/fragments/instructionData.ts
var import_nodes14 = require("@codama/nodes");
var import_visitors_core11 = require("@codama/visitors-core");
function getInstructionDataFragment(scope) {
  const { instructionPath, dataArgsManifest, nameApi, customInstructionData } = scope;
  const instructionNode = (0, import_visitors_core11.getLastNodeFromPath)(instructionPath);
  if (instructionNode.arguments.length === 0 || customInstructionData.has(instructionNode.name)) return;
  const instructionDataName = nameApi.instructionDataType(instructionNode.name);
  return getTypeWithCodecFragment({
    manifest: dataArgsManifest,
    name: instructionDataName,
    nameApi,
    node: (0, import_nodes14.structTypeNodeFromInstructionArgumentNodes)(instructionNode.arguments),
    size: scope.size
  });
}

// src/fragments/instructionExtraArgs.ts
var import_renderers_core4 = require("@codama/renderers-core");
var import_visitors_core12 = require("@codama/visitors-core");
function getInstructionExtraArgsFragment(scope) {
  const { instructionPath, extraArgsManifest, nameApi } = scope;
  const instructionNode = (0, import_visitors_core12.getLastNodeFromPath)(instructionPath);
  if ((instructionNode.extraArguments ?? []).length === 0) return;
  const instructionExtraName = nameApi.instructionExtraType(instructionNode.name);
  const looseName = nameApi.dataArgsType(instructionExtraName);
  return (0, import_renderers_core4.mapFragmentContent)(extraArgsManifest.looseType, (c) => `export type ${looseName} = ${c};`);
}

// src/fragments/instructionFunction.ts
var import_nodes19 = require("@codama/nodes");
var import_renderers_core8 = require("@codama/renderers-core");
var import_visitors_core17 = require("@codama/visitors-core");

// src/fragments/instructionInputResolved.ts
var import_nodes16 = require("@codama/nodes");
var import_renderers_core6 = require("@codama/renderers-core");
var import_visitors_core14 = require("@codama/visitors-core");

// src/fragments/instructionInputDefault.ts
var import_nodes15 = require("@codama/nodes");
var import_renderers_core5 = require("@codama/renderers-core");
var import_visitors_core13 = require("@codama/visitors-core");
function getInstructionInputDefaultFragment(scope) {
  const { input, optionalAccountStrategy, asyncResolvers, useAsync, nameApi, typeManifestVisitor, getImportFrom } = scope;
  if (!input.defaultValue) {
    return fragment``;
  }
  if (!useAsync && isAsyncDefaultValue(input.defaultValue, asyncResolvers)) {
    return fragment``;
  }
  const { defaultValue } = input;
  const defaultFragment = (renderedValue, isWritable) => {
    const inputName = (0, import_nodes15.camelCase)(input.name);
    if (input.kind === "instructionAccountNode" && (0, import_nodes15.isNode)(defaultValue, "resolverValueNode")) {
      return fragment`accounts.${inputName} = { ...accounts.${inputName}, ...${renderedValue} };`;
    }
    if (input.kind === "instructionAccountNode" && isWritable === void 0) {
      return fragment`accounts.${inputName}.value = ${renderedValue};`;
    }
    if (input.kind === "instructionAccountNode") {
      return fragment`accounts.${inputName}.value = ${renderedValue};\naccounts.${inputName}.isWritable = ${isWritable ? "true" : "false"}`;
    }
    return fragment`args.${inputName} = ${renderedValue};`;
  };
  switch (defaultValue.kind) {
    case "accountValueNode":
      const name = (0, import_nodes15.camelCase)(defaultValue.name);
      if (input.kind === "instructionAccountNode" && input.resolvedIsSigner && !input.isSigner) {
        return (0, import_visitors_core13.pipe)(
          defaultFragment(`expectTransactionSigner(accounts.${name}.value).address`),
          (f) => addFragmentImports(f, "shared", ["expectTransactionSigner"])
        );
      }
      if (input.kind === "instructionAccountNode") {
        return (0, import_visitors_core13.pipe)(
          defaultFragment(`expectSome(accounts.${name}.value)`),
          (f) => addFragmentImports(f, "shared", ["expectSome"])
        );
      }
      return (0, import_visitors_core13.pipe)(
        defaultFragment(`expectAddress(accounts.${name}.value)`),
        (f) => addFragmentImports(f, "shared", ["expectAddress"])
      );
    case "pdaValueNode":
      if ((0, import_nodes15.isNode)(defaultValue.pda, "pdaNode")) {
        const pdaProgram = defaultValue.pda.programId ? (0, import_visitors_core13.pipe)(
          fragment`'${defaultValue.pda.programId}' as Address<'${defaultValue.pda.programId}'>`,
          (f) => addFragmentImports(f, "solanaAddresses", ["type Address"])
        ) : fragment`programAddress`;
        const pdaSeeds2 = defaultValue.pda.seeds.flatMap((seed) => {
          if ((0, import_nodes15.isNode)(seed, "constantPdaSeedNode") && (0, import_nodes15.isNode)(seed.value, "programIdValueNode")) {
            return [
              (0, import_visitors_core13.pipe)(
                fragment`getAddressEncoder().encode(${pdaProgram})`,
                (f) => addFragmentImports(f, "solanaAddresses", ["getAddressEncoder"])
              )
            ];
          }
          if ((0, import_nodes15.isNode)(seed, "constantPdaSeedNode") && !(0, import_nodes15.isNode)(seed.value, "programIdValueNode")) {
            const typeManifest2 = (0, import_visitors_core13.visit)(seed.type, typeManifestVisitor);
            const valueManifest2 = (0, import_visitors_core13.visit)(seed.value, typeManifestVisitor);
            return [fragment`${typeManifest2.encoder}.encode(${valueManifest2.value})`];
          }
          if ((0, import_nodes15.isNode)(seed, "variablePdaSeedNode")) {
            const typeManifest2 = (0, import_visitors_core13.visit)(seed.type, typeManifestVisitor);
            const valueSeed = defaultValue.seeds.find((s) => s.name === seed.name)?.value;
            if (!valueSeed) return [];
            if ((0, import_nodes15.isNode)(valueSeed, "accountValueNode")) {
              return [
                (0, import_visitors_core13.pipe)(
                  fragment`${typeManifest2.encoder}.encode(expectAddress(accounts.${(0, import_nodes15.camelCase)(valueSeed.name)}.value))`,
                  (f) => addFragmentImports(f, "shared", ["expectAddress"])
                )
              ];
            }
            if ((0, import_nodes15.isNode)(valueSeed, "argumentValueNode")) {
              return [
                (0, import_visitors_core13.pipe)(
                  fragment`${typeManifest2.encoder}.encode(expectSome(args.${(0, import_nodes15.camelCase)(valueSeed.name)}))`,
                  (f) => addFragmentImports(f, "shared", ["expectSome"])
                )
              ];
            }
            const valueManifest2 = (0, import_visitors_core13.visit)(valueSeed, typeManifestVisitor);
            return [fragment`${typeManifest2.encoder}.encode(${valueManifest2.value})`];
          }
          return [];
        });
        return (0, import_visitors_core13.pipe)(
          mergeFragments([pdaProgram, ...pdaSeeds2], ([p, ...s]) => {
            const programAddress2 = p === "programAddress" ? p : `programAddress: ${p}`;
            return `await getProgramDerivedAddress({ ${programAddress2}, seeds: [${s.join(", ")}] })`;
          }),
          (f) => addFragmentImports(f, "solanaAddresses", ["getProgramDerivedAddress"]),
          (f) => (0, import_renderers_core5.mapFragmentContent)(f, (c) => defaultFragment(c).content)
        );
      }
      const pdaFunction = nameApi.pdaFindFunction(defaultValue.pda.name);
      const pdaArgs = [];
      const pdaSeeds = defaultValue.seeds.map((seed) => {
        if ((0, import_nodes15.isNode)(seed.value, "accountValueNode")) {
          return (0, import_visitors_core13.pipe)(
            fragment`${seed.name}: expectAddress(accounts.${(0, import_nodes15.camelCase)(seed.value.name)}.value)`,
            (f) => addFragmentImports(f, "shared", ["expectAddress"])
          );
        }
        if ((0, import_nodes15.isNode)(seed.value, "argumentValueNode")) {
          return (0, import_visitors_core13.pipe)(
            fragment`${seed.name}: expectSome(args.${(0, import_nodes15.camelCase)(seed.value.name)})`,
            (f) => addFragmentImports(f, "shared", ["expectSome"])
          );
        }
        return (0, import_visitors_core13.pipe)(
          (0, import_visitors_core13.visit)(seed.value, typeManifestVisitor).value,
          (f) => (0, import_renderers_core5.mapFragmentContent)(f, (c) => `${seed.name}: ${c}`)
        );
      });
      const pdaSeedsFragment = (0, import_visitors_core13.pipe)(
        mergeFragments(pdaSeeds, (renders) => renders.join(", ")),
        (f) => (0, import_renderers_core5.mapFragmentContent)(f, (c) => `{ ${c} }`)
      );
      if (pdaSeeds.length > 0) {
        pdaArgs.push(pdaSeedsFragment.content);
      }
      const module2 = getImportFrom(defaultValue.pda);
      return (0, import_visitors_core13.pipe)(
        defaultFragment(`await ${pdaFunction}(${pdaArgs.join(", ")})`),
        (f) => mergeFragmentImports(f, [pdaSeedsFragment.imports]),
        (f) => addFragmentImports(f, module2, [pdaFunction])
      );
    case "publicKeyValueNode":
      return (0, import_visitors_core13.pipe)(
        defaultFragment(`'${defaultValue.publicKey}' as Address<'${defaultValue.publicKey}'>`),
        (f) => addFragmentImports(f, "solanaAddresses", ["type Address"])
      );
    case "programLinkNode":
      const programAddress = nameApi.programAddressConstant(defaultValue.name);
      return (0, import_visitors_core13.pipe)(
        defaultFragment(programAddress, false),
        (f) => addFragmentImports(f, getImportFrom(defaultValue), [programAddress])
      );
    case "programIdValueNode":
      if (optionalAccountStrategy === "programId" && input.kind === "instructionAccountNode" && input.isOptional) {
        return fragment``;
      }
      return defaultFragment("programAddress", false);
    case "identityValueNode":
    case "payerValueNode":
      return fragment``;
    case "accountBumpValueNode":
      return (0, import_visitors_core13.pipe)(
        defaultFragment(`expectProgramDerivedAddress(accounts.${(0, import_nodes15.camelCase)(defaultValue.name)}.value)[1]`),
        (f) => addFragmentImports(f, "shared", ["expectProgramDerivedAddress"])
      );
    case "argumentValueNode":
      return (0, import_visitors_core13.pipe)(
        defaultFragment(`expectSome(args.${(0, import_nodes15.camelCase)(defaultValue.name)})`),
        (f) => addFragmentImports(f, "shared", ["expectSome"])
      );
    case "resolverValueNode":
      const resolverFunction = nameApi.resolverFunction(defaultValue.name);
      const resolverAwait = useAsync && asyncResolvers.includes(defaultValue.name) ? "await " : "";
      return (0, import_visitors_core13.pipe)(
        defaultFragment(`${resolverAwait}${resolverFunction}(resolverScope)`),
        (f) => addFragmentImports(f, getImportFrom(defaultValue), [resolverFunction]),
        (f) => addFragmentFeatures(f, ["instruction:resolverScopeVariable"])
      );
    case "conditionalValueNode":
      const ifTrueRenderer = renderNestedInstructionDefault({
        ...scope,
        defaultValue: defaultValue.ifTrue
      });
      const ifFalseRenderer = renderNestedInstructionDefault({
        ...scope,
        defaultValue: defaultValue.ifFalse
      });
      if (!ifTrueRenderer && !ifFalseRenderer) {
        return fragment``;
      }
      let conditionalFragment = fragment``;
      if (ifTrueRenderer) {
        conditionalFragment = mergeFragments([conditionalFragment, ifTrueRenderer], (c) => c[0]);
      }
      if (ifFalseRenderer) {
        conditionalFragment = mergeFragments([conditionalFragment, ifFalseRenderer], (c) => c[0]);
      }
      const negatedCondition = !ifTrueRenderer;
      let condition = "true";
      if ((0, import_nodes15.isNode)(defaultValue.condition, "resolverValueNode")) {
        const conditionalResolverFunction = nameApi.resolverFunction(defaultValue.condition.name);
        const module3 = getImportFrom(defaultValue.condition);
        conditionalFragment = (0, import_visitors_core13.pipe)(
          conditionalFragment,
          (f) => addFragmentImports(f, module3, [conditionalResolverFunction]),
          (f) => addFragmentFeatures(f, ["instruction:resolverScopeVariable"])
        );
        const conditionalResolverAwait = useAsync && asyncResolvers.includes(defaultValue.condition.name) ? "await " : "";
        condition = `${conditionalResolverAwait}${conditionalResolverFunction}(resolverScope)`;
        condition = negatedCondition ? `!${condition}` : condition;
      } else {
        const comparedInputName = (0, import_nodes15.isNode)(defaultValue.condition, "accountValueNode") ? `accounts.${(0, import_nodes15.camelCase)(defaultValue.condition.name)}.value` : `args.${(0, import_nodes15.camelCase)(defaultValue.condition.name)}`;
        if (defaultValue.value) {
          const comparedValue = (0, import_visitors_core13.visit)(defaultValue.value, typeManifestVisitor).value;
          conditionalFragment = mergeFragments([conditionalFragment, comparedValue], (c) => c[0]);
          const operator = negatedCondition ? "!==" : "===";
          condition = `${comparedInputName} ${operator} ${comparedValue.content}`;
        } else {
          condition = negatedCondition ? `!${comparedInputName}` : comparedInputName;
        }
      }
      if (ifTrueRenderer && ifFalseRenderer) {
        return (0, import_renderers_core5.setFragmentContent)(
          conditionalFragment,
          `if (${condition}) {
${ifTrueRenderer.content}
} else {
${ifFalseRenderer.content}
}`
        );
      }
      return (0, import_renderers_core5.setFragmentContent)(
        conditionalFragment,
        `if (${condition}) {
${ifTrueRenderer ? ifTrueRenderer.content : ifFalseRenderer?.content}
}`
      );
    default:
      const valueManifest = (0, import_visitors_core13.visit)(defaultValue, typeManifestVisitor).value;
      return (0, import_visitors_core13.pipe)(valueManifest, (f) => (0, import_renderers_core5.mapFragmentContent)(f, (c) => defaultFragment(c).content));
  }
}
function renderNestedInstructionDefault(scope) {
  const { input, defaultValue } = scope;
  if (!defaultValue) return void 0;
  return getInstructionInputDefaultFragment({
    ...scope,
    input: { ...input, defaultValue }
  });
}

// src/fragments/instructionInputResolved.ts
function getInstructionInputResolvedFragment(scope) {
  const instructionNode = (0, import_visitors_core14.getLastNodeFromPath)(scope.instructionPath);
  const resolvedInputFragments = scope.resolvedInputs.flatMap((input) => {
    const inputFragment = getInstructionInputDefaultFragment({
      ...scope,
      input,
      optionalAccountStrategy: (0, import_nodes16.parseOptionalAccountStrategy)(instructionNode.optionalAccountStrategy)
    });
    if (!inputFragment.content) return [];
    const camelName = (0, import_nodes16.camelCase)(input.name);
    return [
      (0, import_renderers_core6.mapFragmentContent)(
        inputFragment,
        (c) => (0, import_nodes16.isNode)(input, "instructionArgumentNode") ? `if (!args.${camelName}) {
${c}
}` : `if (!accounts.${camelName}.value) {
${c}
}`
      )
    ];
  });
  if (resolvedInputFragments.length === 0) {
    return fragment``;
  }
  return mergeFragments([fragment`// Resolve default values.`, ...resolvedInputFragments], (c) => c.join("\n"));
}

// src/fragments/instructionInputType.ts
var import_nodes17 = require("@codama/nodes");
var import_renderers_core7 = require("@codama/renderers-core");
var import_visitors_core15 = require("@codama/visitors-core");
function getInstructionInputTypeFragment(scope) {
  const { instructionPath, useAsync, nameApi } = scope;
  const instructionNode = (0, import_visitors_core15.getLastNodeFromPath)(instructionPath);
  const instructionInputType = useAsync ? nameApi.instructionAsyncInputType(instructionNode.name) : nameApi.instructionSyncInputType(instructionNode.name);
  const [dataArgumentsFragment, customDataArgumentsFragment] = getDataArgumentsFragments(scope);
  let accountTypeParams = "";
  if (instructionNode.accounts.length > 0) {
    accountTypeParams = instructionNode.accounts.map((account) => `TAccount${(0, import_nodes17.pascalCase)(account.name)} extends string = string`).join(", ");
    accountTypeParams = `<${accountTypeParams}>`;
  }
  const typeBodyFragment = mergeFragments(
    [
      getAccountsFragment(scope),
      dataArgumentsFragment,
      getExtraArgumentsFragment(scope),
      getRemainingAccountsFragment(instructionNode)
    ],
    (c) => c.join("\n")
  );
  return fragment`export type ${instructionInputType}${accountTypeParams} = ${customDataArgumentsFragment} {
  ${typeBodyFragment}
}`;
}
function getAccountsFragment(scope) {
  const { instructionPath, resolvedInputs, useAsync, asyncResolvers } = scope;
  const instructionNode = (0, import_visitors_core15.getLastNodeFromPath)(instructionPath);
  const fragments = instructionNode.accounts.map((account) => {
    const resolvedAccount = resolvedInputs.find(
      (input) => input.kind === "instructionAccountNode" && input.name === account.name
    );
    const hasDefaultValue = !!resolvedAccount.defaultValue && !(0, import_nodes17.isNode)(resolvedAccount.defaultValue, ["identityValueNode", "payerValueNode"]) && (useAsync || !isAsyncDefaultValue(resolvedAccount.defaultValue, asyncResolvers));
    const docs = getDocblockFragment(account.docs ?? [], true);
    const optionalSign = hasDefaultValue || resolvedAccount.isOptional ? "?" : "";
    return fragment`${docs}${(0, import_nodes17.camelCase)(account.name)}${optionalSign}: ${getAccountTypeFragment2(resolvedAccount)};`;
  });
  return mergeFragments(fragments, (c) => c.join("\n"));
}
function getAccountTypeFragment2(account) {
  const typeParam = `TAccount${(0, import_nodes17.pascalCase)(account.name)}`;
  const address = use("type Address", "solanaAddresses");
  const signer = use("type TransactionSigner", "solanaSigners");
  const pda = use("type ProgramDerivedAddress", "solanaAddresses");
  if (account.isPda && account.isSigner === false) return fragment`${pda}<${typeParam}>`;
  if (account.isPda && account.isSigner === "either") return fragment`${pda}<${typeParam}> | ${signer}<${typeParam}>`;
  if (account.isSigner === "either") return fragment`${address}<${typeParam}> | ${signer}<${typeParam}>`;
  if (account.isSigner) return fragment`${signer}<${typeParam}>`;
  return fragment`${address}<${typeParam}>`;
}
function getDataArgumentsFragments(scope) {
  const { instructionPath, nameApi } = scope;
  const instructionNode = (0, import_visitors_core15.getLastNodeFromPath)(instructionPath);
  const customData = scope.customInstructionData.get(instructionNode.name);
  if (customData) {
    return [
      void 0,
      (0, import_visitors_core15.pipe)(
        fragment`${nameApi.dataArgsType(customData.importAs)}`,
        (f) => mergeFragmentImports(f, [scope.dataArgsManifest.looseType.imports]),
        (f) => (0, import_renderers_core7.mapFragmentContent)(f, (c) => `${c} & `)
      )
    ];
  }
  const instructionDataName = nameApi.instructionDataType(instructionNode.name);
  const dataArgsType = nameApi.dataArgsType(instructionDataName);
  const fragments = instructionNode.arguments.flatMap((arg) => {
    const argFragment = getArgumentFragment(arg, dataArgsType, scope.resolvedInputs, scope.renamedArgs);
    return argFragment ? [argFragment] : [];
  });
  return [fragments.length === 0 ? void 0 : mergeFragments(fragments, (c) => c.join("\n")), fragment``];
}
function getExtraArgumentsFragment(scope) {
  const { instructionPath, nameApi } = scope;
  const instructionNode = (0, import_visitors_core15.getLastNodeFromPath)(instructionPath);
  const instructionExtraName = nameApi.instructionExtraType(instructionNode.name);
  const extraArgsType = nameApi.dataArgsType(instructionExtraName);
  const fragments = (instructionNode.extraArguments ?? []).flatMap((arg) => {
    const argFragment = getArgumentFragment(arg, extraArgsType, scope.resolvedInputs, scope.renamedArgs);
    return argFragment ? [argFragment] : [];
  });
  if (fragments.length === 0) return;
  return mergeFragments(fragments, (c) => c.join("\n"));
}
function getArgumentFragment(arg, argsType, resolvedInputs, renamedArgs) {
  const resolvedArg = resolvedInputs.find(
    (input) => (0, import_nodes17.isNode)(input, "instructionArgumentNode") && input.name === arg.name
  );
  if (arg.defaultValue && arg.defaultValueStrategy === "omitted") return null;
  const renamedName = renamedArgs.get(arg.name) ?? arg.name;
  const optionalSign = arg.defaultValue || resolvedArg?.defaultValue ? "?" : "";
  return fragment`${(0, import_nodes17.camelCase)(renamedName)}${optionalSign}: ${argsType}["${(0, import_nodes17.camelCase)(arg.name)}"];`;
}
function getRemainingAccountsFragment(instructionNode) {
  const fragments = (instructionNode.remainingAccounts ?? []).flatMap((remainingAccountsNode) => {
    if ((0, import_nodes17.isNode)(remainingAccountsNode.value, "resolverValueNode")) return [];
    const { name } = remainingAccountsNode.value;
    const allArguments = (0, import_nodes17.getAllInstructionArguments)(instructionNode);
    const argumentExists = allArguments.some((arg) => arg.name === name);
    if (argumentExists) return [];
    const isSigner = remainingAccountsNode.isSigner ?? false;
    const optionalSign = remainingAccountsNode.isOptional ?? false ? "?" : "";
    const signerFragment = use("type TransactionSigner", "solanaSigners");
    const addressFragment = use("type Address", "solanaAddresses");
    const typeFragment = (() => {
      if (isSigner === "either") return fragment`${signerFragment} | ${addressFragment}`;
      return isSigner ? signerFragment : addressFragment;
    })();
    return fragment`${(0, import_nodes17.camelCase)(name)}${optionalSign}: Array<${typeFragment}>;`;
  });
  if (fragments.length === 0) return;
  return mergeFragments(fragments, (c) => c.join("\n"));
}

// src/fragments/instructionRemainingAccounts.ts
var import_nodes18 = require("@codama/nodes");
var import_visitors_core16 = require("@codama/visitors-core");
function getInstructionRemainingAccountsFragment(scope) {
  const { remainingAccounts } = (0, import_visitors_core16.getLastNodeFromPath)(scope.instructionPath);
  const fragments = (remainingAccounts ?? []).flatMap((a) => getRemainingAccountsFragment2(a, scope));
  if (fragments.length === 0) return;
  return (0, import_visitors_core16.pipe)(
    mergeFragments(
      fragments,
      (c) => `// Remaining accounts.
const remainingAccounts: AccountMeta[] = ${c.length === 1 ? c[0] : `[...${c.join(", ...")}]`}`
    ),
    (f) => addFragmentImports(f, "solanaInstructions", ["type AccountMeta"])
  );
}
function getRemainingAccountsFragment2(remainingAccounts, scope) {
  const remainingAccountsFragment = (() => {
    if ((0, import_nodes18.isNode)(remainingAccounts.value, "argumentValueNode")) {
      return getArgumentValueNodeFragment2(remainingAccounts, scope);
    }
    if ((0, import_nodes18.isNode)(remainingAccounts.value, "resolverValueNode")) {
      return getResolverValueNodeFragment2(remainingAccounts, scope);
    }
    return null;
  })();
  if (remainingAccountsFragment === null) return [];
  return [remainingAccountsFragment];
}
function getArgumentValueNodeFragment2(remainingAccounts, scope) {
  const instructionNode = (0, import_visitors_core16.getLastNodeFromPath)(scope.instructionPath);
  (0, import_nodes18.assertIsNode)(remainingAccounts.value, "argumentValueNode");
  const argumentName = (0, import_nodes18.camelCase)(remainingAccounts.value.name);
  const isOptional = remainingAccounts.isOptional ?? false;
  const isSigner = remainingAccounts.isSigner ?? false;
  const isWritable = remainingAccounts.isWritable ?? false;
  const accountRole = use("AccountRole", "solanaInstructions");
  const nonSignerRole = isWritable ? fragment`${accountRole}.WRITABLE` : fragment`${accountRole}.READONLY`;
  const signerRole = isWritable ? fragment`${accountRole}.WRITABLE_SIGNER` : fragment`${accountRole}.READONLY_SIGNER`;
  const role = isSigner === true ? signerRole : nonSignerRole;
  const argumentArray = isOptional ? `(args.${argumentName} ?? [])` : `args.${argumentName}`;
  const allArguments = (0, import_nodes18.getAllInstructionArguments)(instructionNode);
  const argumentExists = allArguments.some((arg) => arg.name === remainingAccounts.value.name);
  if (argumentExists || isSigner === false) {
    return fragment`${argumentArray}.map((address) => ({ address, role: ${role} }))`;
  }
  if (isSigner === "either") {
    return fragment`${argumentArray}.map((addressOrSigner) => (${use("isTransactionSigner", "shared")}(addressOrSigner) ? { address: addressOrSigner.address, role: ${role}, signer: addressOrSigner } : { address: addressOrSigner, role: ${role} }))`;
  }
  return fragment`${argumentArray}.map((signer) => ({ address: signer.address, role: ${signerRole}, signer }))`;
}
function getResolverValueNodeFragment2(remainingAccounts, scope) {
  (0, import_nodes18.assertIsNode)(remainingAccounts.value, "resolverValueNode");
  const isAsync = scope.asyncResolvers.includes(remainingAccounts.value.name);
  if (!scope.useAsync && isAsync) return null;
  const awaitKeyword = scope.useAsync && isAsync ? "await " : "";
  const functionName = use(
    scope.nameApi.resolverFunction(remainingAccounts.value.name),
    scope.getImportFrom(remainingAccounts.value)
  );
  return (0, import_visitors_core16.pipe)(
    fragment`${awaitKeyword}${functionName}(resolverScope)`,
    (f) => addFragmentFeatures(f, ["instruction:resolverScopeVariable"])
  );
}

// src/fragments/instructionFunction.ts
function getInstructionFunctionFragment(scope) {
  const { useAsync, instructionPath, resolvedInputs, renamedArgs, asyncResolvers, nameApi, customInstructionData } = scope;
  const instructionNode = (0, import_visitors_core17.getLastNodeFromPath)(instructionPath);
  const programNode = (0, import_visitors_core17.findProgramNodeFromPath)(instructionPath);
  if (useAsync && !hasAsyncFunction(instructionNode, resolvedInputs, asyncResolvers)) return;
  const customData = customInstructionData.get(instructionNode.name);
  const hasAccounts = instructionNode.accounts.length > 0;
  const instructionDependencies = getInstructionDependencies(instructionNode, asyncResolvers, useAsync);
  const argDependencies = instructionDependencies.filter((0, import_nodes19.isNodeFilter)("argumentValueNode")).map((node) => node.name);
  const hasData = !!customData || instructionNode.arguments.length > 0;
  const argIsNotOmitted = (arg) => !(arg.defaultValue && arg.defaultValueStrategy === "omitted");
  const argIsDependent = (arg) => argDependencies.includes(arg.name);
  const argHasDefaultValue = (arg) => {
    if (!arg.defaultValue) return false;
    if (useAsync) return true;
    return !isAsyncDefaultValue(arg.defaultValue, asyncResolvers);
  };
  const hasDataArgs = !!customData || instructionNode.arguments.filter(argIsNotOmitted).length > 0;
  const hasExtraArgs = (instructionNode.extraArguments ?? []).filter(
    (field) => argIsNotOmitted(field) && (argIsDependent(field) || argHasDefaultValue(field))
  ).length > 0;
  const hasRemainingAccountArgs = (instructionNode.remainingAccounts ?? []).filter(({ value }) => (0, import_nodes19.isNode)(value, "argumentValueNode")).length > 0;
  const hasAnyArgs = hasDataArgs || hasExtraArgs || hasRemainingAccountArgs;
  const hasInput = hasAccounts || hasAnyArgs;
  const programAddressConstant = use(nameApi.programAddressConstant(programNode.name), "generatedPrograms");
  const functionName = useAsync ? nameApi.instructionAsyncFunction(instructionNode.name) : nameApi.instructionSyncFunction(instructionNode.name);
  const resolvedInputsFragment = getInstructionInputResolvedFragment(scope);
  const remainingAccountsFragment = getInstructionRemainingAccountsFragment(scope);
  const byteDeltaFragment = getInstructionByteDeltaFragment(scope);
  const resolvedInputFragment = mergeFragments(
    [resolvedInputsFragment, remainingAccountsFragment, byteDeltaFragment],
    (content) => content.join("\n\n")
  );
  const hasRemainingAccounts = !!remainingAccountsFragment;
  const hasByteDeltas = !!byteDeltaFragment;
  const hasResolver = resolvedInputFragment.features.has("instruction:resolverScopeVariable");
  const instructionTypeFragment = getInstructionTypeFragment(scope);
  const typeParams = getTypeParamsFragment(instructionNode, programAddressConstant);
  const returnType = getReturnTypeFragment(instructionTypeFragment, hasByteDeltas, useAsync);
  const inputType = getInstructionInputTypeFragment(scope);
  const inputArg = (0, import_renderers_core8.mapFragmentContent)(getInputTypeCallFragment(scope), (c) => hasInput ? `input: ${c}, ` : "");
  const functionBody = mergeFragments(
    [
      getProgramAddressInitializationFragment(programAddressConstant),
      getAccountsInitializationFragment(instructionNode),
      getArgumentsInitializationFragment(hasAnyArgs, renamedArgs),
      getResolverScopeInitializationFragment(hasResolver, hasAccounts, hasAnyArgs),
      resolvedInputFragment,
      getReturnStatementFragment({
        ...scope,
        hasByteDeltas,
        hasData,
        hasDataArgs,
        hasRemainingAccounts,
        instructionNode,
        syncReturnTypeFragment: getReturnTypeFragment(instructionTypeFragment, hasByteDeltas, false)
      })
    ],
    (cs) => cs.join("\n\n")
  );
  return fragment`${inputType}\n\nexport ${useAsync ? "async " : ""}function ${functionName}${typeParams}(${inputArg}config?: { programAddress?: TProgramAddress } ): ${returnType} {
  ${functionBody}
}`;
}
function getProgramAddressInitializationFragment(programAddressConstant) {
  return fragment`// Program address.
const programAddress = config?.programAddress ?? ${programAddressConstant};`;
}
function getAccountsInitializationFragment(instructionNode) {
  if (instructionNode.accounts.length === 0) return;
  const accounts = mergeFragments(
    instructionNode.accounts.map((account) => {
      const name = (0, import_nodes19.camelCase)(account.name);
      const isWritable = account.isWritable ? "true" : "false";
      return fragment`${name}: { value: input.${name} ?? null, isWritable: ${isWritable} }`;
    }),
    (cs) => cs.join(", ")
  );
  return fragment` // Original accounts.
const originalAccounts = { ${accounts} }
const accounts = originalAccounts as Record<keyof typeof originalAccounts, ${use("type ResolvedAccount", "shared")}>;
`;
}
function getArgumentsInitializationFragment(hasAnyArgs, renamedArgs) {
  if (!hasAnyArgs) return;
  const renamedArgsText = [...renamedArgs.entries()].map(([k, v]) => `${k}: input.${v}`).join(", ");
  return fragment`// Original args.
const args = { ...input, ${renamedArgsText} };
`;
}
function getResolverScopeInitializationFragment(hasResolver, hasAccounts, hasAnyArgs) {
  if (!hasResolver) return;
  const resolverAttributes = [
    "programAddress",
    ...hasAccounts ? ["accounts"] : [],
    ...hasAnyArgs ? ["args"] : []
  ].join(", ");
  return fragment`// Resolver scope.
const resolverScope = { ${resolverAttributes} };`;
}
function getReturnStatementFragment(scope) {
  const { instructionNode, hasByteDeltas, hasData, hasDataArgs, hasRemainingAccounts, nameApi } = scope;
  const optionalAccountStrategy = instructionNode.optionalAccountStrategy ?? "programId";
  const hasAccounts = instructionNode.accounts.length > 0;
  const hasLegacyOptionalAccounts = instructionNode.optionalAccountStrategy === "omitted" && instructionNode.accounts.some((account) => account.isOptional);
  const getAccountMeta = hasAccounts ? fragment`const getAccountMeta = ${use("getAccountMetaFactory", "shared")}(programAddress, '${optionalAccountStrategy}');` : "";
  const accountItems = [
    ...instructionNode.accounts.map((account) => `getAccountMeta(accounts.${(0, import_nodes19.camelCase)(account.name)})`),
    ...hasRemainingAccounts ? ["...remainingAccounts"] : []
  ].join(", ");
  let accounts;
  if (hasAccounts && hasLegacyOptionalAccounts) {
    accounts = fragment`accounts: [${accountItems}].filter(<T>(x: T | undefined): x is T => x !== undefined)`;
  } else if (hasAccounts) {
    accounts = fragment`accounts: [${accountItems}]`;
  } else if (hasRemainingAccounts) {
    accounts = fragment`accounts: remainingAccounts`;
  }
  const customData = scope.customInstructionData.get(instructionNode.name);
  const instructionDataName = nameApi.instructionDataType(instructionNode.name);
  const encoderFunctionFragment = customData ? scope.dataArgsManifest.encoder : `${nameApi.encoderFunction(instructionDataName)}()`;
  const argsTypeFragment = customData ? scope.dataArgsManifest.looseType : nameApi.dataArgsType(instructionDataName);
  let data;
  if (hasDataArgs) {
    data = fragment`data: ${encoderFunctionFragment}.encode(args as ${argsTypeFragment})`;
  } else if (hasData) {
    data = fragment`data: ${encoderFunctionFragment}.encode({})`;
  }
  const instructionAttributes = (0, import_visitors_core17.pipe)(
    [accounts, hasByteDeltas ? fragment`byteDelta` : void 0, data, fragment`programAddress`],
    (fs) => mergeFragments(fs, (cs) => cs.join(", "))
  );
  return fragment`${getAccountMeta}\nreturn Object.freeze({ ${instructionAttributes} } as ${scope.syncReturnTypeFragment});`;
}
function getReturnTypeFragment(instructionTypeFragment, hasByteDeltas, useAsync) {
  return (0, import_visitors_core17.pipe)(
    instructionTypeFragment,
    (f) => hasByteDeltas ? fragment`${f} & ${use("type InstructionWithByteDelta", "shared")}` : f,
    (f) => useAsync ? fragment`Promise<${f}>` : f
  );
}
function getTypeParamsFragment(instructionNode, programAddressConstant) {
  return mergeFragments(
    [
      ...instructionNode.accounts.map((account) => fragment`TAccount${(0, import_nodes19.pascalCase)(account.name)} extends string`),
      fragment`TProgramAddress extends ${use("type Address", "solanaAddresses")} = typeof ${programAddressConstant}`
    ],
    (cs) => `<${cs.join(", ")}>`
  );
}
function getInstructionTypeFragment(scope) {
  const { instructionPath, nameApi } = scope;
  const instructionNode = (0, import_visitors_core17.getLastNodeFromPath)(instructionPath);
  const instructionTypeName = nameApi.instructionType(instructionNode.name);
  const accountTypeParamsFragments = instructionNode.accounts.map((account) => {
    const typeParam = fragment`TAccount${(0, import_nodes19.pascalCase)(account.name)}`;
    const camelName = (0, import_nodes19.camelCase)(account.name);
    if (account.isSigner === "either") {
      const signerRole = use(
        account.isWritable ? "type WritableSignerAccount" : "type ReadonlySignerAccount",
        "solanaInstructions"
      );
      return (0, import_visitors_core17.pipe)(
        fragment`typeof input["${camelName}"] extends TransactionSigner<${typeParam}> ? ${signerRole}<${typeParam}> & AccountSignerMeta<${typeParam}> : ${typeParam}`,
        (f) => addFragmentImports(f, "solanaSigners", ["type AccountSignerMeta", "type TransactionSigner"])
      );
    }
    return typeParam;
  });
  return (0, import_visitors_core17.pipe)(
    mergeFragments([fragment`TProgramAddress`, ...accountTypeParamsFragments], (c) => c.join(", ")),
    (f) => (0, import_renderers_core8.mapFragmentContent)(f, (c) => `${instructionTypeName}<${c}>`)
  );
}
function getInputTypeCallFragment(scope) {
  const { instructionPath, useAsync, nameApi } = scope;
  const instructionNode = (0, import_visitors_core17.getLastNodeFromPath)(instructionPath);
  const inputTypeName = useAsync ? nameApi.instructionAsyncInputType(instructionNode.name) : nameApi.instructionSyncInputType(instructionNode.name);
  if (instructionNode.accounts.length === 0) return fragment`${inputTypeName}`;
  const accountTypeParams = instructionNode.accounts.map((account) => `TAccount${(0, import_nodes19.pascalCase)(account.name)}`).join(", ");
  return fragment`${inputTypeName}<${accountTypeParams}>`;
}

// src/fragments/instructionPage.ts
var import_errors2 = require("@codama/errors");
var import_nodes22 = require("@codama/nodes");
var import_visitors_core20 = require("@codama/visitors-core");

// src/fragments/instructionParseFunction.ts
var import_nodes20 = require("@codama/nodes");
var import_visitors_core18 = require("@codama/visitors-core");
function getInstructionParseFunctionFragment(scope) {
  const instructionNode = (0, import_visitors_core18.getLastNodeFromPath)(scope.instructionPath);
  const programNode = (0, import_visitors_core18.findProgramNodeFromPath)(scope.instructionPath);
  const programAddressConstant = use(scope.nameApi.programAddressConstant(programNode.name), "generatedPrograms");
  const childScope = { ...scope, instructionNode, programAddressConstant };
  return mergeFragments([getTypeFragment2(childScope), getFunctionFragment(childScope)], (cs) => cs.join("\n\n"));
}
function getTypeFragment2(scope) {
  const customData = scope.customInstructionData.get(scope.instructionNode.name);
  const instructionParsedType = scope.nameApi.instructionParsedType(scope.instructionNode.name);
  const instructionDataName = scope.nameApi.instructionDataType(scope.instructionNode.name);
  const hasData = !!customData || scope.instructionNode.arguments.length > 0;
  const hasAccounts = scope.instructionNode.accounts.length > 0;
  const typeParamDeclarations = mergeFragments(
    [
      fragment`TProgram extends string = typeof ${scope.programAddressConstant}`,
      hasAccounts ? fragment`TAccountMetas extends readonly ${use("type AccountMeta", "solanaInstructions")}[] = readonly AccountMeta[]` : void 0
    ],
    (cs) => cs.join(", ")
  );
  const accounts = mergeFragments(
    scope.instructionNode.accounts.map((account, i) => {
      const docs = getDocblockFragment(account.docs ?? [], true);
      const name = (0, import_nodes20.camelCase)(account.name);
      return fragment`${docs}${name}${account.isOptional ? "?" : ""}: TAccountMetas[${i}]${account.isOptional ? " | undefined" : ""};`;
    }),
    (cs) => hasAccounts ? `
accounts: {
${cs.join("\n")}
};` : ""
  );
  const dataTypeFragment = customData ? scope.dataArgsManifest.strictType : fragment`${scope.nameApi.dataType(instructionDataName)}`;
  const data = hasData ? fragment`\ndata: ${dataTypeFragment};` : fragment``;
  return fragment`export type ${instructionParsedType}<${typeParamDeclarations}> = { programAddress: ${use("type Address", "solanaAddresses")}<TProgram>;${accounts}${data} };`;
}
function getFunctionFragment(scope) {
  const customData = scope.customInstructionData.get(scope.instructionNode.name);
  const instructionParsedType = scope.nameApi.instructionParsedType(scope.instructionNode.name);
  const instructionParseFunction = scope.nameApi.instructionParseFunction(scope.instructionNode.name);
  const instructionDataName = scope.nameApi.instructionDataType(scope.instructionNode.name);
  const decoderFunction = customData ? scope.dataArgsManifest.decoder : fragment`${scope.nameApi.decoderFunction(instructionDataName)}()`;
  const hasData = !!customData || scope.instructionNode.arguments.length > 0;
  const hasAccounts = scope.instructionNode.accounts.length > 0;
  const hasOptionalAccounts = scope.instructionNode.accounts.some((account) => account.isOptional);
  const minimumNumberOfAccounts = scope.instructionNode.optionalAccountStrategy === "omitted" ? scope.instructionNode.accounts.filter((account) => !account.isOptional).length : scope.instructionNode.accounts.length;
  const typeParams = ["TProgram", hasAccounts ? "TAccountMetas" : void 0].filter(Boolean).join(", ");
  const typeParamDeclarations = mergeFragments(
    [
      fragment`TProgram extends string`,
      hasAccounts ? fragment`TAccountMetas extends readonly ${use("type AccountMeta", "solanaInstructions")}[]` : void 0
    ],
    (cs) => cs.join(", ")
  );
  const instructionType = mergeFragments(
    [
      fragment`${use("type Instruction", "solanaInstructions")}<TProgram>`,
      hasAccounts ? fragment`${use("type InstructionWithAccounts", "solanaInstructions")}<TAccountMetas>` : void 0,
      hasData ? (0, import_visitors_core18.pipe)(
        fragment`InstructionWithData<ReadonlyUint8Array>`,
        (f) => addFragmentImports(f, "solanaInstructions", ["type InstructionWithData"]),
        (f) => addFragmentImports(f, "solanaCodecsCore", ["type ReadonlyUint8Array"])
      ) : void 0
    ],
    (cs) => cs.join(" & ")
  );
  let accountHelpers;
  if (hasAccounts) {
    accountHelpers = fragment`if (instruction.accounts.length < ${minimumNumberOfAccounts}) {
  // TODO: Coded error.
  throw new Error('Not enough accounts');
}
let accountIndex = 0;
const getNextAccount = () => {
  const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;
  accountIndex += 1;
  return accountMeta;
}`;
  }
  if (hasOptionalAccounts && scope.instructionNode.optionalAccountStrategy === "omitted") {
    accountHelpers = fragment`${accountHelpers}
let optionalAccountsRemaining = instruction.accounts.length - ${minimumNumberOfAccounts};
const getNextOptionalAccount = () => {
  if (optionalAccountsRemaining === 0) return undefined;
  optionalAccountsRemaining -= 1;
  return getNextAccount();
};`;
  } else if (hasOptionalAccounts) {
    accountHelpers = fragment`${accountHelpers}
const getNextOptionalAccount = () => {
  const accountMeta = getNextAccount();
  return accountMeta.address === ${scope.programAddressConstant} ? undefined : accountMeta;
};`;
  }
  const accounts = mergeFragments(
    scope.instructionNode.accounts.map(
      (account) => account.isOptional ? fragment`${(0, import_nodes20.camelCase)(account.name)}: getNextOptionalAccount()` : fragment`${(0, import_nodes20.camelCase)(account.name)}: getNextAccount()`
    ),
    (cs) => hasAccounts ? `, accounts: { ${cs.join(", ")} }` : ""
  );
  const data = hasData ? fragment`, data: ${decoderFunction}.decode(instruction.data)` : fragment``;
  return fragment`export function ${instructionParseFunction}<${typeParamDeclarations}>(instruction: ${instructionType}): ${instructionParsedType}<${typeParams}> {
  ${accountHelpers}
  return { programAddress: instruction.programAddress${accounts}${data} };
}`;
}

// src/fragments/instructionType.ts
var import_nodes21 = require("@codama/nodes");
var import_renderers_core9 = require("@codama/renderers-core");
var import_visitors_core19 = require("@codama/visitors-core");
function getInstructionTypeFragment2(scope) {
  const { instructionPath, nameApi, customInstructionData } = scope;
  const instructionNode = (0, import_visitors_core19.getLastNodeFromPath)(instructionPath);
  const programNode = (0, import_visitors_core19.findProgramNodeFromPath)(instructionPath);
  const hasAccounts = instructionNode.accounts.length > 0;
  const customData = customInstructionData.get(instructionNode.name);
  const hasData = !!customData || instructionNode.arguments.length > 0;
  const instructionType = nameApi.instructionType(instructionNode.name);
  const programAddressConstant = use(nameApi.programAddressConstant(programNode.name), "generatedPrograms");
  const accountTypeParams = mergeFragments(
    instructionNode.accounts.map(
      (account) => getInstructionAccountTypeParamFragment({
        ...scope,
        allowAccountMeta: true,
        instructionAccountPath: [...instructionPath, account]
      })
    ),
    (cs) => cs.length > 0 ? `${cs.join(", ")}, ` : ""
  );
  const data = hasData ? fragment` & ${use("type InstructionWithData", "solanaInstructions")}<${use("type ReadonlyUint8Array", "solanaCodecsCore")}>` : void 0;
  const usesLegacyOptionalAccounts = instructionNode.optionalAccountStrategy === "omitted";
  const accountMetasFragment = mergeFragments(
    instructionNode.accounts.map(
      (account) => (0, import_renderers_core9.mapFragmentContent)(getInstructionAccountMetaFragment(account), (c) => {
        const typeParam = `TAccount${(0, import_nodes21.pascalCase)(account.name)}`;
        const isLegacyOptional = account.isOptional && usesLegacyOptionalAccounts;
        const type = `${typeParam} extends string ? ${c} : ${typeParam}`;
        if (!isLegacyOptional) return type;
        return `...(${typeParam} extends undefined ? [] : [${type}])`;
      })
    ),
    (c) => c.join(", ")
  );
  const instructionWithAccounts = use("type InstructionWithAccounts", "solanaInstructions");
  const accounts = hasAccounts ? fragment` & ${instructionWithAccounts}<[${accountMetasFragment}, ...TRemainingAccounts]>` : fragment` & ${instructionWithAccounts}<TRemainingAccounts>`;
  return fragment`export type ${instructionType}<TProgram extends string = typeof ${programAddressConstant}, ${accountTypeParams}TRemainingAccounts extends readonly ${use("type AccountMeta", "solanaInstructions")}<string>[] = []> =
${use("type Instruction", "solanaInstructions")}<TProgram>${data}${accounts};`;
}

// src/fragments/instructionPage.ts
function getInstructionPageFragment(scope) {
  const node = (0, import_visitors_core20.getLastNodeFromPath)(scope.instructionPath);
  if (!(0, import_visitors_core20.findProgramNodeFromPath)(scope.instructionPath)) {
    throw new Error("Instruction must be visited inside a program.");
  }
  const childScope = {
    ...scope,
    dataArgsManifest: (0, import_visitors_core20.visit)(node, scope.typeManifestVisitor),
    extraArgsManifest: (0, import_visitors_core20.visit)(
      (0, import_nodes22.definedTypeNode)({
        name: scope.nameApi.instructionExtraType(node.name),
        type: (0, import_nodes22.structTypeNodeFromInstructionArgumentNodes)(node.extraArguments ?? [])
      }),
      scope.typeManifestVisitor
    ),
    renamedArgs: getRenamedArgsMap(node)
  };
  return mergeFragments(
    [
      getDiscriminatorConstantsFragment({
        ...childScope,
        discriminatorNodes: node.discriminators ?? [],
        fields: node.arguments,
        prefix: node.name
      }),
      getInstructionTypeFragment2(childScope),
      getInstructionDataFragment(childScope),
      getInstructionExtraArgsFragment(childScope),
      getInstructionFunctionFragment({ ...childScope, useAsync: true }),
      getInstructionFunctionFragment({ ...childScope, useAsync: false }),
      getInstructionParseFunctionFragment(childScope)
    ],
    (cs) => cs.join("\n\n")
  );
}
function getRenamedArgsMap(instruction) {
  const argNames = [
    ...instruction.arguments.map((a) => a.name),
    ...(instruction.extraArguments ?? []).map((a) => a.name)
  ];
  const duplicateArgs = argNames.filter((e, i, a) => a.indexOf(e) !== i);
  if (duplicateArgs.length > 0) {
    throw new Error(`Duplicate args found: [${duplicateArgs.join(", ")}] in instruction [${instruction.name}].`);
  }
  const allNames = [...instruction.accounts.map((account) => account.name), ...argNames];
  const duplicates = allNames.filter((e, i, a) => a.indexOf(e) !== i);
  if (duplicates.length === 0) return /* @__PURE__ */ new Map();
  (0, import_errors2.logWarn)(
    `[JavaScript] Accounts and args of instruction [${instruction.name}] have the following conflicting attributes [${duplicates.join(", ")}]. Thus, the arguments have been renamed to avoid conflicts in the input type.`
  );
  return new Map(duplicates.map((name) => [(0, import_nodes22.camelCase)(name), (0, import_nodes22.camelCase)(`${name}Arg`)]));
}

// src/fragments/pdaFunction.ts
var import_nodes23 = require("@codama/nodes");
var import_visitors_core21 = require("@codama/visitors-core");
function getPdaFunctionFragment(scope) {
  const pdaNode = (0, import_visitors_core21.getLastNodeFromPath)(scope.pdaPath);
  const seeds = parsePdaSeedNodes(pdaNode.seeds, scope);
  return mergeFragments(
    [getSeedInputTypeFragment(seeds, scope), getFunctionFragment2(seeds, scope)],
    (cs) => cs.join("\n\n")
  );
}
function getSeedInputTypeFragment(seeds, scope) {
  const variableSeeds = seeds.filter((0, import_nodes23.isNodeFilter)("variablePdaSeedNode"));
  if (variableSeeds.length === 0) return;
  const pdaNode = (0, import_visitors_core21.getLastNodeFromPath)(scope.pdaPath);
  const seedTypeName = scope.nameApi.pdaSeedsType(pdaNode.name);
  const seedAttributes = mergeFragments(
    variableSeeds.map((seed) => seed.inputAttribute),
    (cs) => cs.join("\n")
  );
  return fragment`export type ${seedTypeName} = {\n${seedAttributes}\n};`;
}
function getFunctionFragment2(seeds, scope) {
  const pdaNode = (0, import_visitors_core21.getLastNodeFromPath)(scope.pdaPath);
  const programNode = (0, import_visitors_core21.findProgramNodeFromPath)(scope.pdaPath);
  const addressType = use("type Address", "solanaAddresses");
  const pdaType = use("type ProgramDerivedAddress", "solanaAddresses");
  const getPdaFunction = use("getProgramDerivedAddress", "solanaAddresses");
  const seedTypeName = scope.nameApi.pdaSeedsType(pdaNode.name);
  const findPdaFunction = scope.nameApi.pdaFindFunction(pdaNode.name);
  const docs = getDocblockFragment(pdaNode.docs ?? [], true);
  const hasVariableSeeds = seeds.filter((0, import_nodes23.isNodeFilter)("variablePdaSeedNode")).length > 0;
  const seedArgument = hasVariableSeeds ? `seeds: ${seedTypeName}, ` : "";
  const programAddress = pdaNode.programId ?? programNode.publicKey;
  const encodedSeeds = mergeFragments(
    seeds.map((s) => s.encodedValue),
    (cs) => cs.join(", ")
  );
  return fragment`${docs}export async function ${findPdaFunction}(${seedArgument}config: { programAddress?: ${addressType} | undefined } = {}): Promise<${pdaType}> {
  const { programAddress = '${programAddress}' as ${addressType}<'${programAddress}'> } = config;
  return await ${getPdaFunction}({ programAddress, seeds: [${encodedSeeds}]});
}`;
}
function parsePdaSeedNodes(seeds, scope) {
  return seeds.map((seed) => {
    if ((0, import_nodes23.isNode)(seed, "variablePdaSeedNode")) {
      const name = (0, import_nodes23.camelCase)(seed.name);
      const docs = getDocblockFragment(seed.docs ?? [], true);
      const { encoder: encoder2, looseType } = (0, import_visitors_core21.visit)(seed.type, scope.typeManifestVisitor);
      return {
        ...seed,
        encodedValue: fragment`${encoder2}.encode(seeds.${name})`,
        inputAttribute: fragment`${docs}${name}: ${looseType};`
      };
    }
    if ((0, import_nodes23.isNode)(seed.value, "programIdValueNode")) {
      const addressEncoder = use("getAddressEncoder", "solanaAddresses");
      return { ...seed, encodedValue: fragment`${addressEncoder}().encode(programAddress)` };
    }
    const { encoder } = (0, import_visitors_core21.visit)(seed.type, scope.typeManifestVisitor);
    const { value } = (0, import_visitors_core21.visit)(seed.value, scope.typeManifestVisitor);
    return { ...seed, encodedValue: fragment`${encoder}.encode(${value})` };
  });
}

// src/fragments/pdaPage.ts
var import_visitors_core22 = require("@codama/visitors-core");
function getPdaPageFragment(scope) {
  if (!(0, import_visitors_core22.findProgramNodeFromPath)(scope.pdaPath)) {
    throw new Error("PDA must be visited inside a program.");
  }
  return getPdaFunctionFragment(scope);
}

// src/fragments/programAccounts.ts
var import_nodes24 = require("@codama/nodes");
var import_renderers_core10 = require("@codama/renderers-core");
var import_visitors_core23 = require("@codama/visitors-core");
function getProgramAccountsFragment(scope) {
  if (scope.programNode.accounts.length === 0) return;
  return mergeFragments(
    [getProgramAccountsEnumFragment(scope), getProgramAccountsIdentifierFunctionFragment(scope)],
    (c) => c.join("\n\n")
  );
}
function getProgramAccountsEnumFragment(scope) {
  const { programNode, nameApi } = scope;
  const programAccountsEnum = nameApi.programAccountsEnum(programNode.name);
  const programAccountsEnumVariants = programNode.accounts.map(
    (account) => nameApi.programAccountsEnumVariant(account.name)
  );
  return fragment`export enum ${programAccountsEnum} { ${programAccountsEnumVariants.join(", ")} }`;
}
function getProgramAccountsIdentifierFunctionFragment(scope) {
  const { programNode, nameApi } = scope;
  const accountsWithDiscriminators = programNode.accounts.filter(
    (account) => (account.discriminators ?? []).length > 0
  );
  const hasAccountDiscriminators = accountsWithDiscriminators.length > 0;
  if (!hasAccountDiscriminators) return;
  const programAccountsEnum = nameApi.programAccountsEnum(programNode.name);
  const programAccountsIdentifierFunction = nameApi.programAccountsIdentifierFunction(programNode.name);
  return (0, import_visitors_core23.pipe)(
    mergeFragments(
      accountsWithDiscriminators.map((account) => {
        const variant = nameApi.programAccountsEnumVariant(account.name);
        return getDiscriminatorConditionFragment({
          ...scope,
          dataName: "data",
          discriminators: account.discriminators ?? [],
          ifTrue: `return ${programAccountsEnum}.${variant};`,
          struct: (0, import_nodes24.resolveNestedTypeNode)(account.data)
        });
      }),
      (c) => c.join("\n")
    ),
    (f) => (0, import_renderers_core10.mapFragmentContent)(
      f,
      (discriminators) => `export function ${programAccountsIdentifierFunction}(account: { data: ReadonlyUint8Array } | ReadonlyUint8Array): ${programAccountsEnum} {
const data = 'data' in account ? account.data : account;
${discriminators}
throw new Error("The provided account could not be identified as a ${programNode.name} account.")
}`
    ),
    (f) => addFragmentImports(f, "solanaCodecsCore", ["type ReadonlyUint8Array"])
  );
}

// src/fragments/programConstant.ts
var import_visitors_core24 = require("@codama/visitors-core");
function getProgramConstantFragment(scope) {
  const { programNode, nameApi } = scope;
  const programAddressConstant = nameApi.programAddressConstant(programNode.name);
  return (0, import_visitors_core24.pipe)(
    fragment`export const ${programAddressConstant} = '${programNode.publicKey}' as Address<'${programNode.publicKey}'>;`,
    (f) => addFragmentImports(f, "solanaAddresses", ["type Address"])
  );
}

// src/fragments/programInstructions.ts
var import_nodes25 = require("@codama/nodes");
var import_renderers_core11 = require("@codama/renderers-core");
var import_visitors_core25 = require("@codama/visitors-core");
function getProgramInstructionsFragment(scope) {
  if (scope.programNode.instructions.length === 0) return;
  const allInstructions = (0, import_nodes25.getAllInstructionsWithSubs)(scope.programNode, {
    leavesOnly: !scope.renderParentInstructions,
    subInstructionsFirst: true
  });
  const scopeWithInstructions = { ...scope, allInstructions };
  return mergeFragments(
    [
      getProgramInstructionsEnumFragment(scopeWithInstructions),
      getProgramInstructionsIdentifierFunctionFragment(scopeWithInstructions),
      getProgramInstructionsParsedUnionTypeFragment(scopeWithInstructions)
    ],
    (c) => c.join("\n\n")
  );
}
function getProgramInstructionsEnumFragment(scope) {
  const { programNode, allInstructions, nameApi } = scope;
  const programInstructionsEnum = nameApi.programInstructionsEnum(programNode.name);
  const programInstructionsEnumVariants = allInstructions.map(
    (instruction) => nameApi.programInstructionsEnumVariant(instruction.name)
  );
  return fragment`export enum ${programInstructionsEnum} { ${programInstructionsEnumVariants.join(", ")} }`;
}
function getProgramInstructionsIdentifierFunctionFragment(scope) {
  const { programNode, nameApi, allInstructions } = scope;
  const instructionsWithDiscriminators = allInstructions.filter(
    (instruction) => (instruction.discriminators ?? []).length > 0
  );
  const hasInstructionDiscriminators = instructionsWithDiscriminators.length > 0;
  if (!hasInstructionDiscriminators) return;
  const programInstructionsEnum = nameApi.programInstructionsEnum(programNode.name);
  const programInstructionsIdentifierFunction = nameApi.programInstructionsIdentifierFunction(programNode.name);
  const discriminatorsFragment = mergeFragments(
    instructionsWithDiscriminators.map((instruction) => {
      const variant = nameApi.programInstructionsEnumVariant(instruction.name);
      return getDiscriminatorConditionFragment({
        ...scope,
        dataName: "data",
        discriminators: instruction.discriminators ?? [],
        ifTrue: `return ${programInstructionsEnum}.${variant};`,
        struct: (0, import_nodes25.structTypeNodeFromInstructionArgumentNodes)(instruction.arguments)
      });
    }),
    (c) => c.join("\n")
  );
  return (0, import_visitors_core25.pipe)(
    discriminatorsFragment,
    (f) => (0, import_renderers_core11.mapFragmentContent)(
      f,
      (discriminators) => `export function ${programInstructionsIdentifierFunction}(instruction: { data: ReadonlyUint8Array } | ReadonlyUint8Array): ${programInstructionsEnum} {
const data = 'data' in instruction ? instruction.data : instruction;
${discriminators}
throw new Error("The provided instruction could not be identified as a ${programNode.name} instruction.")
}`
    ),
    (f) => addFragmentImports(f, "solanaCodecsCore", ["type ReadonlyUint8Array"])
  );
}
function getProgramInstructionsParsedUnionTypeFragment(scope) {
  const { programNode, allInstructions, nameApi } = scope;
  const programAddress = programNode.publicKey;
  const programInstructionsType = nameApi.programInstructionsParsedUnionType(programNode.name);
  const programInstructionsEnum = nameApi.programInstructionsEnum(programNode.name);
  const typeVariants = allInstructions.map((instruction) => {
    const instructionEnumVariant = nameApi.programInstructionsEnumVariant(instruction.name);
    const parsedInstructionType = use(
      `type ${nameApi.instructionParsedType(instruction.name)}`,
      "generatedInstructions"
    );
    return fragment`| { instructionType: ${programInstructionsEnum}.${instructionEnumVariant} } & ${parsedInstructionType}<TProgram>`;
  });
  return mergeFragments(
    [
      fragment`export type ${programInstructionsType}<TProgram extends string = '${programAddress}'> =`,
      ...typeVariants
    ],
    (c) => c.join("\n")
  );
}

// src/fragments/programPage.ts
function getProgramPageFragment(scope) {
  return mergeFragments(
    [getProgramConstantFragment(scope), getProgramAccountsFragment(scope), getProgramInstructionsFragment(scope)],
    (cs) => cs.join("\n\n")
  );
}

// src/fragments/rootIndexPage.ts
function getRootIndexPageFragment(scope) {
  const hasAnythingToExport = scope.programsToExport.length > 0 || scope.accountsToExport.length > 0 || scope.instructionsToExport.length > 0 || scope.definedTypesToExport.length > 0;
  if (!hasAnythingToExport) {
    return fragment`export default {};`;
  }
  const programsWithErrorsToExport = scope.programsToExport.filter((p) => p.errors.length > 0);
  return mergeFragments(
    [
      scope.accountsToExport.length > 0 ? getExportAllFragment("./accounts") : void 0,
      programsWithErrorsToExport.length > 0 ? getExportAllFragment("./errors") : void 0,
      scope.instructionsToExport.length > 0 ? getExportAllFragment("./instructions") : void 0,
      scope.pdasToExport.length > 0 ? getExportAllFragment("./pdas") : void 0,
      scope.programsToExport.length > 0 ? getExportAllFragment("./programs") : void 0,
      scope.definedTypesToExport.length > 0 ? getExportAllFragment("./types") : void 0
    ],
    (cs) => cs.join("\n")
  );
}

// src/fragments/sharedPage.ts
var import_visitors_core26 = require("@codama/visitors-core");
function getSharedPageFragment() {
  const sharedPage = fragment`/**
 * Asserts that the given value is not null or undefined.
 * @internal
 */
export function expectSome<T>(value: T | null | undefined): T {
  if (value === null || value === undefined) {
    throw new Error('Expected a value but received null or undefined.');
  }
  return value;
}

/**
 * Asserts that the given value is a PublicKey.
 * @internal
 */
export function expectAddress<T extends string = string>(
  value: Address<T> | ProgramDerivedAddress<T> | TransactionSigner<T> | null | undefined
): Address<T> {
  if (!value) {
    throw new Error('Expected a Address.');
  }
  if (typeof value === 'object' && "address" in value) {
    return value.address;
  }
  if (Array.isArray(value)) {
    return value[0] as Address<T>;
  }
  return value as Address<T>;
}

/**
 * Asserts that the given value is a PDA.
 * @internal
 */
export function expectProgramDerivedAddress<T extends string = string>(
  value: Address<T> | ProgramDerivedAddress<T> | TransactionSigner<T> | null | undefined
): ProgramDerivedAddress<T> {
  if (!value || !Array.isArray(value) || !isProgramDerivedAddress(value)) {
    throw new Error('Expected a ProgramDerivedAddress.');
  }
  return value;
}

/**
 * Asserts that the given value is a TransactionSigner.
 * @internal
 */
export function expectTransactionSigner<T extends string = string>(
  value: Address<T> | ProgramDerivedAddress<T> | TransactionSigner<T> | null | undefined
): TransactionSigner<T> {
  if (!value || !isTransactionSigner(value)) {
    throw new Error('Expected a TransactionSigner.');
  }
  return value;
}

/**
 * Defines an instruction account to resolve.
 * @internal
 */
export type ResolvedAccount<T extends string = string, U extends Address<T> | ProgramDerivedAddress<T> | TransactionSigner<T> | null = Address<T> | ProgramDerivedAddress<T> | TransactionSigner<T> | null> = {
  isWritable: boolean;
  value: U;
};

 /**
 * Defines an instruction that stores additional bytes on-chain.
 * @internal
 */
export type InstructionWithByteDelta = {
  byteDelta: number;
};

/**
* Get account metas and signers from resolved accounts.
* @internal
*/
export function getAccountMetaFactory(
  programAddress: Address,
  optionalAccountStrategy: 'omitted' | 'programId',
) {
  return (account: ResolvedAccount): AccountMeta | AccountSignerMeta | undefined => {
    if (!account.value) {
      if (optionalAccountStrategy === 'omitted') return;
      return Object.freeze({ address: programAddress, role: AccountRole.READONLY });
    }

    const writableRole = account.isWritable ? AccountRole.WRITABLE : AccountRole.READONLY;
    return Object.freeze({
      address: expectAddress(account.value),
      role: isTransactionSigner(account.value) ? upgradeRoleToSigner(writableRole) : writableRole,
      ...(isTransactionSigner(account.value) ? { signer: account.value } : {})
    });
  };
}

export function isTransactionSigner<TAddress extends string = string>(value: Address<TAddress> | ProgramDerivedAddress<TAddress> | TransactionSigner<TAddress>): value is TransactionSigner<TAddress> {
  return !!value && typeof value === 'object' && 'address' in value && kitIsTransactionSigner(value);
}`;
  return (0, import_visitors_core26.pipe)(
    sharedPage,
    (f) => addFragmentImports(f, "solanaAddresses", [
      "type Address",
      "isProgramDerivedAddress",
      "type ProgramDerivedAddress"
    ]),
    (f) => addFragmentImports(f, "solanaInstructions", ["AccountRole", "type AccountMeta", "upgradeRoleToSigner"]),
    (f) => addFragmentImports(f, "solanaSigners", [
      "type AccountSignerMeta",
      "isTransactionSigner as kitIsTransactionSigner",
      "type TransactionSigner"
    ])
  );
}

// src/fragments/typeDiscriminatedUnionHelpers.ts
var import_nodes26 = require("@codama/nodes");
function getTypeDiscriminatedUnionHelpersFragment(scope) {
  const { name, typeNode, nameApi } = scope;
  const isDiscriminatedUnion = (0, import_nodes26.isNode)(typeNode, "enumTypeNode") && (0, import_nodes26.isDataEnum)(typeNode);
  if (!isDiscriminatedUnion) return;
  const functionName = nameApi.discriminatedUnionFunction(name);
  const isDiscriminatedUnionFunctionName = nameApi.isDiscriminatedUnionFunction(name);
  const discriminatorName = nameApi.discriminatedUnionDiscriminator(name);
  const strictName = nameApi.dataType(name);
  const looseName = nameApi.dataArgsType(name);
  const getVariantContentType = use("type GetDiscriminatedUnionVariantContent", "solanaCodecsDataStructures");
  const getVariantType = use("type GetDiscriminatedUnionVariant", "solanaCodecsDataStructures");
  const variantSignatures = mergeFragments(
    typeNode.variants.map((variant) => {
      const variantName = nameApi.discriminatedUnionVariant(variant.name);
      if ((0, import_nodes26.isNode)(variant, "enumStructVariantTypeNode")) {
        return fragment`export function ${functionName}(kind: '${variantName}', data: ${getVariantContentType}<${looseName}, '${discriminatorName}', '${variantName}'>): ${getVariantType}<${looseName}, '${discriminatorName}', '${variantName}'>;`;
      }
      if ((0, import_nodes26.isNode)(variant, "enumTupleVariantTypeNode")) {
        return fragment`export function ${functionName}(kind: '${variantName}', data: ${getVariantContentType}<${looseName}, '${discriminatorName}', '${variantName}'>['fields']): ${getVariantType}<${looseName}, '${discriminatorName}', '${variantName}'>;`;
      }
      return fragment`export function ${functionName}(kind: '${variantName}'): ${getVariantType}<${looseName}, '${discriminatorName}', '${variantName}'>;`;
    }),
    (cs) => cs.length > 0 ? `${cs.join("\n")}
` : ""
  );
  return fragment`// Data Enum Helpers.
${variantSignatures}export function ${functionName}<K extends ${looseName}['${discriminatorName}'], Data>(kind: K, data?: Data) {
  return Array.isArray(data) ? { ${discriminatorName}: kind, fields: data } : { ${discriminatorName}: kind, ...(data ?? {}) };
}

export function ${isDiscriminatedUnionFunctionName}<K extends ${strictName}['${discriminatorName}']>(kind: K, value: ${strictName}): value is ${strictName} & { ${discriminatorName}: K } {
  return value.${discriminatorName} === kind;
};
`;
}

// src/fragments/typePage.ts
var import_visitors_core27 = require("@codama/visitors-core");
function getTypePageFragment(scope) {
  const node = scope.node;
  const manifest = (0, import_visitors_core27.visit)(node, scope.typeManifestVisitor);
  return (0, import_visitors_core27.pipe)(
    mergeFragments(
      [
        getTypeWithCodecFragment({ ...scope, manifest, name: node.name, node: node.type, typeDocs: node.docs }),
        getTypeDiscriminatedUnionHelpersFragment({ ...scope, name: node.name, typeNode: node.type })
      ],
      (cs) => cs.join("\n\n")
    ),
    (f) => removeFragmentImports(f, "generatedTypes", [
      scope.nameApi.dataType(node.name),
      scope.nameApi.dataArgsType(node.name),
      scope.nameApi.encoderFunction(node.name),
      scope.nameApi.decoderFunction(node.name),
      scope.nameApi.codecFunction(node.name)
    ])
  );
}

// src/visitors/getTypeManifestVisitor.ts
var import_nodes27 = require("@codama/nodes");
var import_renderers_core12 = require("@codama/renderers-core");
var import_visitors_core28 = require("@codama/visitors-core");
function getTypeManifestVisitor(input) {
  const { nameApi, linkables, nonScalarEnums, customAccountData, customInstructionData, getImportFrom } = input;
  const stack = input.stack ?? new import_visitors_core28.NodeStack();
  let parentName = null;
  return (0, import_visitors_core28.pipe)(
    (0, import_visitors_core28.staticVisitor)(() => typeManifest(), {
      keys: [
        ...import_nodes27.REGISTERED_TYPE_NODE_KINDS,
        ...import_nodes27.REGISTERED_VALUE_NODE_KINDS,
        "definedTypeLinkNode",
        "definedTypeNode",
        "accountNode",
        "instructionNode"
      ]
    }),
    (visitor) => (0, import_visitors_core28.extendVisitor)(visitor, {
      visitAccount(account, { self }) {
        parentName = {
          loose: nameApi.dataArgsType(account.name),
          strict: nameApi.dataType(account.name)
        };
        const link = customAccountData.get(account.name)?.linkNode;
        const manifest = link ? (0, import_visitors_core28.visit)(link, self) : (0, import_visitors_core28.visit)(account.data, self);
        parentName = null;
        return manifest;
      },
      visitAmountType(amountType, { self }) {
        return (0, import_visitors_core28.visit)(amountType.number, self);
      },
      visitArrayType(arrayType, { self }) {
        const childManifest = (0, import_visitors_core28.visit)(arrayType.item, self);
        const sizeManifest = getArrayLikeSizeOption(arrayType.count, self);
        const encoderOptions = sizeManifest.encoder ? fragment`, { ${sizeManifest.encoder} }` : "";
        const decoderOptions = sizeManifest.decoder ? fragment`, { ${sizeManifest.decoder} }` : "";
        return typeManifest({
          ...childManifest,
          decoder: fragment`${use("getArrayDecoder", "solanaCodecsDataStructures")}(${childManifest.decoder}${decoderOptions})`,
          encoder: fragment`${use("getArrayEncoder", "solanaCodecsDataStructures")}(${childManifest.encoder}${encoderOptions})`,
          looseType: fragment`Array<${childManifest.looseType}>`,
          strictType: fragment`Array<${childManifest.strictType}>`
        });
      },
      visitArrayValue(node, { self }) {
        return mergeTypeManifests(
          node.items.map((v) => (0, import_visitors_core28.visit)(v, self)),
          { mergeValues: (renders) => `[${renders.join(", ")}]` }
        );
      },
      visitBooleanType(booleanType, { self }) {
        let sizeEncoder = fragment``;
        let sizeDecoder = fragment``;
        const resolvedSize = (0, import_nodes27.resolveNestedTypeNode)(booleanType.size);
        if (resolvedSize.format !== "u8" || resolvedSize.endian !== "le") {
          const size = (0, import_visitors_core28.visit)(booleanType.size, self);
          sizeEncoder = fragment`{ size: ${size.encoder} }`;
          sizeDecoder = fragment`{ size: ${size.decoder} }`;
        }
        return typeManifest({
          decoder: fragment`${use("getBooleanDecoder", "solanaCodecsDataStructures")}(${sizeDecoder})`,
          encoder: fragment`${use("getBooleanEncoder", "solanaCodecsDataStructures")}(${sizeEncoder})`,
          looseType: fragment`boolean`,
          strictType: fragment`boolean`
        });
      },
      visitBooleanValue(node) {
        return typeManifest({ value: fragment`${JSON.stringify(node.boolean)}` });
      },
      visitBytesType() {
        const readonlyUint8Array = use("type ReadonlyUint8Array", "solanaCodecsCore");
        return typeManifest({
          decoder: fragment`${use("getBytesDecoder", "solanaCodecsDataStructures")}()`,
          encoder: fragment`${use("getBytesEncoder", "solanaCodecsDataStructures")}()`,
          looseType: readonlyUint8Array,
          strictType: readonlyUint8Array
        });
      },
      visitBytesValue(node) {
        const bytes = getBytesFromBytesValueNode(node);
        return typeManifest({ value: fragment`new Uint8Array([${Array.from(bytes).join(", ")}])` });
      },
      visitConstantValue(node, { self }) {
        if ((0, import_nodes27.isNode)(node.type, "bytesTypeNode") && (0, import_nodes27.isNode)(node.value, "bytesValueNode")) {
          return (0, import_visitors_core28.visit)(node.value, self);
        }
        return typeManifest({
          value: fragment`${(0, import_visitors_core28.visit)(node.type, self).encoder}.encode(${(0, import_visitors_core28.visit)(node.value, self).value})`
        });
      },
      visitDateTimeType(dateTimeType, { self }) {
        return (0, import_visitors_core28.visit)(dateTimeType.number, self);
      },
      visitDefinedType(definedType, { self }) {
        parentName = {
          loose: nameApi.dataArgsType(definedType.name),
          strict: nameApi.dataType(definedType.name)
        };
        const manifest = (0, import_visitors_core28.visit)(definedType.type, self);
        parentName = null;
        return manifest;
      },
      visitDefinedTypeLink(node) {
        const strictName = nameApi.dataType(node.name);
        const looseName = nameApi.dataArgsType(node.name);
        const encoderFunction = nameApi.encoderFunction(node.name);
        const decoderFunction = nameApi.decoderFunction(node.name);
        const importFrom = getImportFrom(node);
        return typeManifest({
          decoder: fragment`${use(decoderFunction, importFrom)}()`,
          encoder: fragment`${use(encoderFunction, importFrom)}()`,
          looseType: use(`type ${looseName}`, importFrom),
          strictType: use(`type ${strictName}`, importFrom)
        });
      },
      visitEnumEmptyVariantType(enumEmptyVariantType) {
        const discriminator = nameApi.discriminatedUnionDiscriminator((0, import_nodes27.camelCase)(parentName?.strict ?? ""));
        const name = nameApi.discriminatedUnionVariant(enumEmptyVariantType.name);
        const kindAttribute = `${discriminator}: "${name}"`;
        return typeManifest({
          decoder: fragment`['${name}', ${use("getUnitDecoder", "solanaCodecsDataStructures")}()]`,
          encoder: fragment`['${name}', ${use("getUnitEncoder", "solanaCodecsDataStructures")}()]`,
          looseType: fragment`{ ${kindAttribute} }`,
          strictType: fragment`{ ${kindAttribute} }`
        });
      },
      visitEnumStructVariantType(enumStructVariantType, { self }) {
        const currentParentName = parentName;
        const discriminator = nameApi.discriminatedUnionDiscriminator(
          (0, import_nodes27.camelCase)(currentParentName?.strict ?? "")
        );
        const name = nameApi.discriminatedUnionVariant(enumStructVariantType.name);
        const kindAttribute = `${discriminator}: "${name}"`;
        parentName = null;
        const structManifest = (0, import_visitors_core28.visit)(enumStructVariantType.struct, self);
        parentName = currentParentName;
        return typeManifest({
          ...structManifest,
          decoder: fragment`['${name}', ${structManifest.decoder}]`,
          encoder: fragment`['${name}', ${structManifest.encoder}]`,
          looseType: (0, import_visitors_core28.pipe)(
            structManifest.looseType,
            (f) => (0, import_renderers_core12.mapFragmentContent)(f, (c) => `{ ${kindAttribute},${c.slice(1, -1)}}`)
          ),
          strictType: (0, import_visitors_core28.pipe)(
            structManifest.strictType,
            (f) => (0, import_renderers_core12.mapFragmentContent)(f, (c) => `{ ${kindAttribute},${c.slice(1, -1)}}`)
          )
        });
      },
      visitEnumTupleVariantType(enumTupleVariantType, { self }) {
        const currentParentName = parentName;
        const discriminator = nameApi.discriminatedUnionDiscriminator(
          (0, import_nodes27.camelCase)(currentParentName?.strict ?? "")
        );
        const name = nameApi.discriminatedUnionVariant(enumTupleVariantType.name);
        const kindAttribute = `${discriminator}: "${name}"`;
        const struct = (0, import_nodes27.structTypeNode)([
          (0, import_nodes27.structFieldTypeNode)({
            name: "fields",
            type: enumTupleVariantType.tuple
          })
        ]);
        parentName = null;
        const structManifest = (0, import_visitors_core28.visit)(struct, self);
        parentName = currentParentName;
        return typeManifest({
          ...structManifest,
          decoder: fragment`['${name}', ${structManifest.decoder}]`,
          encoder: fragment`['${name}', ${structManifest.encoder}]`,
          looseType: (0, import_visitors_core28.pipe)(
            structManifest.looseType,
            (f) => (0, import_renderers_core12.mapFragmentContent)(f, (c) => `{ ${kindAttribute},${c.slice(1, -1)}}`)
          ),
          strictType: (0, import_visitors_core28.pipe)(
            structManifest.strictType,
            (f) => (0, import_renderers_core12.mapFragmentContent)(f, (c) => `{ ${kindAttribute},${c.slice(1, -1)}}`)
          )
        });
      },
      visitEnumType(enumType, { self }) {
        const currentParentName = parentName;
        const encoderOptions = [];
        const decoderOptions = [];
        const enumSize = (0, import_nodes27.resolveNestedTypeNode)(enumType.size);
        if (enumSize.format !== "u8" || enumSize.endian !== "le") {
          const sizeManifest = (0, import_visitors_core28.visit)(enumType.size, self);
          encoderOptions.push(fragment`size: ${sizeManifest.encoder}`);
          decoderOptions.push(fragment`size: ${sizeManifest.decoder}`);
        }
        const discriminator = nameApi.discriminatedUnionDiscriminator(
          (0, import_nodes27.camelCase)(currentParentName?.strict ?? "")
        );
        if (!(0, import_nodes27.isScalarEnum)(enumType) && discriminator !== "__kind") {
          encoderOptions.push(fragment`discriminator: '${discriminator}'`);
          decoderOptions.push(fragment`discriminator: '${discriminator}'`);
        }
        const encoderOptionsFragment = mergeFragments(
          encoderOptions,
          (cs) => cs.length > 0 ? `, { ${cs.join(", ")} }` : ""
        );
        const decoderOptionsFragment = mergeFragments(
          decoderOptions,
          (cs) => cs.length > 0 ? `, { ${cs.join(", ")} }` : ""
        );
        if ((0, import_nodes27.isScalarEnum)(enumType)) {
          if (currentParentName === null) {
            throw new Error(
              "Scalar enums cannot be inlined and must be introduced via a defined type. Ensure you are not inlining a defined type that is a scalar enum through a visitor."
            );
          }
          const variantNames = enumType.variants.map(({ name }) => nameApi.enumVariant(name));
          return typeManifest({
            decoder: fragment`${use("getEnumDecoder", "solanaCodecsDataStructures")}(${currentParentName.strict}${decoderOptionsFragment})`,
            encoder: fragment`${use("getEnumEncoder", "solanaCodecsDataStructures")}(${currentParentName.strict}${encoderOptionsFragment})`,
            isEnum: true,
            looseType: fragment`{ ${variantNames.join(", ")} }`,
            strictType: fragment`{ ${variantNames.join(", ")} }`
          });
        }
        const mergedManifest = mergeTypeManifests(
          enumType.variants.map((variant) => (0, import_visitors_core28.visit)(variant, self)),
          {
            mergeCodecs: (renders) => renders.join(", "),
            mergeTypes: (renders) => renders.join(" | ")
          }
        );
        return typeManifest({
          ...mergedManifest,
          decoder: fragment`${use("getDiscriminatedUnionDecoder", "solanaCodecsDataStructures")}([${mergedManifest.decoder}]${decoderOptionsFragment})`,
          encoder: fragment`${use("getDiscriminatedUnionEncoder", "solanaCodecsDataStructures")}([${mergedManifest.encoder}]${encoderOptionsFragment})`
        });
      },
      visitEnumValue(node, { self }) {
        const manifest = typeManifest();
        const enumName = nameApi.dataType(node.enum.name);
        const enumFunction = nameApi.discriminatedUnionFunction(node.enum.name);
        const importFrom = getImportFrom(node.enum);
        const enumNode = linkables.get([...stack.getPath(), node.enum])?.type;
        const isScalar = enumNode && (0, import_nodes27.isNode)(enumNode, "enumTypeNode") ? (0, import_nodes27.isScalarEnum)(enumNode) : !nonScalarEnums.includes(node.enum.name);
        if (!node.value && isScalar) {
          const variantName2 = nameApi.enumVariant(node.variant);
          return typeManifest({
            ...manifest,
            value: (0, import_visitors_core28.pipe)(
              manifest.value,
              (f) => (0, import_renderers_core12.setFragmentContent)(f, `${enumName}.${variantName2}`),
              (f) => addFragmentImports(f, importFrom, [enumName])
            )
          });
        }
        const variantName = nameApi.discriminatedUnionVariant(node.variant);
        if (!node.value) {
          return typeManifest({
            ...manifest,
            value: (0, import_visitors_core28.pipe)(
              manifest.value,
              (f) => (0, import_renderers_core12.setFragmentContent)(f, `${enumFunction}('${variantName}')`),
              (f) => addFragmentImports(f, importFrom, [enumFunction])
            )
          });
        }
        return typeManifest({
          ...manifest,
          value: (0, import_visitors_core28.pipe)(
            (0, import_visitors_core28.visit)(node.value, self).value,
            (f) => (0, import_renderers_core12.mapFragmentContent)(f, (c) => `${enumFunction}('${variantName}', ${c})`),
            (f) => addFragmentImports(f, importFrom, [enumFunction])
          )
        });
      },
      visitFixedSizeType(node, { self }) {
        const manifest = (0, import_visitors_core28.visit)(node.type, self);
        return typeManifest({
          ...manifest,
          decoder: fragment`${use("fixDecoderSize", "solanaCodecsCore")}(${manifest.decoder}, ${node.size})`,
          encoder: fragment`${use("fixEncoderSize", "solanaCodecsCore")}(${manifest.encoder}, ${node.size})`
        });
      },
      visitHiddenPrefixType(node, { self }) {
        const manifest = (0, import_visitors_core28.visit)(node.type, self);
        const prefixes = node.prefix.map((c) => (0, import_visitors_core28.visit)(c, self).value);
        const prefixEncoders = (0, import_visitors_core28.pipe)(
          mergeFragments(prefixes, (cs) => cs.map((c) => `getConstantEncoder(${c})`).join(", ")),
          (f) => addFragmentImports(f, "solanaCodecsCore", ["getConstantEncoder"])
        );
        const prefixDecoders = (0, import_visitors_core28.pipe)(
          mergeFragments(prefixes, (cs) => cs.map((c) => `getConstantDecoder(${c})`).join(", ")),
          (f) => addFragmentImports(f, "solanaCodecsCore", ["getConstantDecoder"])
        );
        return typeManifest({
          ...manifest,
          decoder: fragment`${use("getHiddenPrefixDecoder", "solanaCodecsDataStructures")}(${manifest.decoder}, [${prefixDecoders}])`,
          encoder: fragment`${use("getHiddenPrefixEncoder", "solanaCodecsDataStructures")}(${manifest.encoder}, [${prefixEncoders}])`
        });
      },
      visitHiddenSuffixType(node, { self }) {
        const manifest = (0, import_visitors_core28.visit)(node.type, self);
        const suffixes = node.suffix.map((c) => (0, import_visitors_core28.visit)(c, self).value);
        const suffixEncoders = (0, import_visitors_core28.pipe)(
          mergeFragments(suffixes, (cs) => cs.map((c) => `getConstantEncoder(${c})`).join(", ")),
          (f) => addFragmentImports(f, "solanaCodecsCore", ["getConstantEncoder"])
        );
        const suffixDecoders = (0, import_visitors_core28.pipe)(
          mergeFragments(suffixes, (cs) => cs.map((c) => `getConstantDecoder(${c})`).join(", ")),
          (f) => addFragmentImports(f, "solanaCodecsCore", ["getConstantDecoder"])
        );
        return typeManifest({
          ...manifest,
          decoder: fragment`${use("getHiddenSuffixDecoder", "solanaCodecsDataStructures")}(${manifest.decoder}, [${suffixDecoders}])`,
          encoder: fragment`${use("getHiddenSuffixEncoder", "solanaCodecsDataStructures")}(${manifest.encoder}, [${suffixEncoders}])`
        });
      },
      visitInstruction(instruction, { self }) {
        const instructionDataName = nameApi.instructionDataType(instruction.name);
        parentName = {
          loose: nameApi.dataArgsType(instructionDataName),
          strict: nameApi.dataType(instructionDataName)
        };
        const link = customInstructionData.get(instruction.name)?.linkNode;
        const struct = (0, import_nodes27.structTypeNodeFromInstructionArgumentNodes)(instruction.arguments);
        const manifest = link ? (0, import_visitors_core28.visit)(link, self) : (0, import_visitors_core28.visit)(struct, self);
        parentName = null;
        return manifest;
      },
      visitMapEntryValue(node, { self }) {
        return mergeTypeManifests([(0, import_visitors_core28.visit)(node.key, self), (0, import_visitors_core28.visit)(node.value, self)], {
          mergeValues: (renders) => `[${renders.join(", ")}]`
        });
      },
      visitMapType(mapType, { self }) {
        const key = (0, import_visitors_core28.visit)(mapType.key, self);
        const value = (0, import_visitors_core28.visit)(mapType.value, self);
        const mergedManifest = mergeTypeManifests([key, value], {
          mergeCodecs: ([k, v]) => `${k}, ${v}`,
          mergeTypes: ([k, v]) => `Map<${k}, ${v}>`
        });
        const sizeManifest = getArrayLikeSizeOption(mapType.count, self);
        const encoderOptions = sizeManifest.encoder ? fragment`, { ${sizeManifest.encoder} }` : "";
        const decoderOptions = sizeManifest.decoder ? fragment`, { ${sizeManifest.decoder} }` : "";
        return typeManifest({
          ...mergedManifest,
          decoder: fragment`${use("getMapDecoder", "solanaCodecsDataStructures")}(${mergedManifest.decoder}${decoderOptions})`,
          encoder: fragment`${use("getMapEncoder", "solanaCodecsDataStructures")}(${mergedManifest.encoder}${encoderOptions})`
        });
      },
      visitMapValue(node, { self }) {
        const entryFragments = node.entries.map((entry) => (0, import_visitors_core28.visit)(entry, self));
        return mergeTypeManifests(entryFragments, {
          mergeValues: (renders) => `new Map([${renders.join(", ")}])`
        });
      },
      visitNoneValue() {
        return typeManifest({
          value: fragment`${use("none", "solanaOptions")}()`
        });
      },
      visitNumberType(numberType) {
        const encoderFunction = use(nameApi.encoderFunction(numberType.format), "solanaCodecsNumbers");
        const decoderFunction = use(nameApi.decoderFunction(numberType.format), "solanaCodecsNumbers");
        const isBigNumber = ["u64", "u128", "i64", "i128"].includes(numberType.format);
        const endianness = numberType.endian === "be" ? fragment`{ endian: ${use("Endian", "solanaCodecsNumbers")}.Big }` : "";
        return typeManifest({
          decoder: fragment`${decoderFunction}(${endianness})`,
          encoder: fragment`${encoderFunction}(${endianness})`,
          looseType: fragment`${isBigNumber ? "number | bigint" : "number"}`,
          strictType: fragment`${isBigNumber ? "bigint" : "number"}`
        });
      },
      visitNumberValue(node) {
        return typeManifest({ value: fragment`${JSON.stringify(node.number)}` });
      },
      visitOptionType(optionType, { self }) {
        const childManifest = (0, import_visitors_core28.visit)(optionType.item, self);
        const encoderOptions = [];
        const decoderOptions = [];
        const optionPrefix = (0, import_nodes27.resolveNestedTypeNode)(optionType.prefix);
        if (optionPrefix.format !== "u8" || optionPrefix.endian !== "le") {
          const prefixManifest = (0, import_visitors_core28.visit)(optionType.prefix, self);
          encoderOptions.push(fragment`prefix: ${prefixManifest.encoder}`);
          decoderOptions.push(fragment`prefix: ${prefixManifest.decoder}`);
        }
        if (optionType.fixed) {
          encoderOptions.push(fragment`noneValue: "zeroes"`);
          decoderOptions.push(fragment`noneValue: "zeroes"`);
        }
        const encoderOptionsFragment = mergeFragments(
          encoderOptions,
          (cs) => cs.length > 0 ? `, { ${cs.join(", ")} }` : ""
        );
        const decoderOptionsFragment = mergeFragments(
          decoderOptions,
          (cs) => cs.length > 0 ? `, { ${cs.join(", ")} }` : ""
        );
        return typeManifest({
          ...childManifest,
          decoder: fragment`${use("getOptionDecoder", "solanaOptions")}(${childManifest.decoder}${decoderOptionsFragment})`,
          encoder: fragment`${use("getOptionEncoder", "solanaOptions")}(${childManifest.encoder}${encoderOptionsFragment})`,
          looseType: fragment`${use("type OptionOrNullable", "solanaOptions")}<${childManifest.looseType}>`,
          strictType: fragment`${use("type Option", "solanaOptions")}<${childManifest.strictType}>`
        });
      },
      visitPostOffsetType(node, { self }) {
        const manifest = (0, import_visitors_core28.visit)(node.type, self);
        if (node.strategy === "padded") {
          return typeManifest({
            ...manifest,
            decoder: fragment`${use("padRightDecoder", "solanaCodecsCore")}(${manifest.decoder}, ${node.offset})`,
            encoder: fragment`${use("padRightEncoder", "solanaCodecsCore")}(${manifest.encoder}, ${node.offset})`
          });
        }
        const fn = (() => {
          switch (node.strategy) {
            case "absolute":
              return node.offset < 0 ? `({ wrapBytes }) => wrapBytes(${node.offset})` : `() => ${node.offset}`;
            case "preOffset":
              return node.offset < 0 ? `({ preOffset }) => preOffset ${node.offset}` : `({ preOffset }) => preOffset + ${node.offset}`;
            case "relative":
            default:
              return node.offset < 0 ? `({ postOffset }) => postOffset ${node.offset}` : `({ postOffset }) => postOffset + ${node.offset}`;
          }
        })();
        return typeManifest({
          ...manifest,
          decoder: fragment`${use("offsetDecoder", "solanaCodecsCore")}(${manifest.decoder}, { postOffset: ${fn} })`,
          encoder: fragment`${use("offsetEncoder", "solanaCodecsCore")}(${manifest.encoder}, { postOffset: ${fn} })`
        });
      },
      visitPreOffsetType(node, { self }) {
        const manifest = (0, import_visitors_core28.visit)(node.type, self);
        if (node.strategy === "padded") {
          return typeManifest({
            ...manifest,
            decoder: fragment`${use("padLeftDecoder", "solanaCodecsCore")}(${manifest.decoder}, ${node.offset})`,
            encoder: fragment`${use("padLeftEncoder", "solanaCodecsCore")}(${manifest.encoder}, ${node.offset})`
          });
        }
        const fn = (() => {
          switch (node.strategy) {
            case "absolute":
              return node.offset < 0 ? `({ wrapBytes }) => wrapBytes(${node.offset})` : `() => ${node.offset}`;
            case "relative":
            default:
              return node.offset < 0 ? `({ preOffset }) => preOffset ${node.offset}` : `({ preOffset }) => preOffset + ${node.offset}`;
          }
        })();
        return typeManifest({
          ...manifest,
          decoder: fragment`${use("offsetDecoder", "solanaCodecsCore")}(${manifest.decoder}, { preOffset: ${fn} })`,
          encoder: fragment`${use("offsetEncoder", "solanaCodecsCore")}(${manifest.encoder}, { preOffset: ${fn} })`
        });
      },
      visitPublicKeyType() {
        return typeManifest({
          decoder: fragment`${use("getAddressDecoder", "solanaAddresses")}()`,
          encoder: fragment`${use("getAddressEncoder", "solanaAddresses")}()`,
          looseType: use("type Address", "solanaAddresses"),
          strictType: use("type Address", "solanaAddresses")
        });
      },
      visitPublicKeyValue(node) {
        return typeManifest({
          value: fragment`${use("address", "solanaAddresses")}("${node.publicKey}")`
        });
      },
      visitRemainderOptionType(node, { self }) {
        const childManifest = (0, import_visitors_core28.visit)(node.item, self);
        const encoderOptions = ["prefix: null"];
        const decoderOptions = ["prefix: null"];
        const encoderOptionsAsString = encoderOptions.length > 0 ? `, { ${encoderOptions.join(", ")} }` : "";
        const decoderOptionsAsString = decoderOptions.length > 0 ? `, { ${decoderOptions.join(", ")} }` : "";
        return typeManifest({
          ...childManifest,
          decoder: fragment`${use("getOptionDecoder", "solanaOptions")}(${childManifest.decoder}${decoderOptionsAsString})`,
          encoder: fragment`${use("getOptionEncoder", "solanaOptions")}(${childManifest.encoder}${encoderOptionsAsString})`,
          looseType: fragment`${use("type OptionOrNullable", "solanaOptions")}<${childManifest.looseType}>`,
          strictType: fragment`${use("type Option", "solanaOptions")}<${childManifest.strictType}>`
        });
      },
      visitSentinelType(node, { self }) {
        const manifest = (0, import_visitors_core28.visit)(node.type, self);
        const sentinel = (0, import_visitors_core28.visit)(node.sentinel, self).value;
        return typeManifest({
          ...manifest,
          decoder: fragment`${use("addDecoderSentinel", "solanaCodecsCore")}(${manifest.decoder}, ${sentinel})`,
          encoder: fragment`${use("addEncoderSentinel", "solanaCodecsCore")}(${manifest.encoder}, ${sentinel})`
        });
      },
      visitSetType(setType, { self }) {
        const childManifest = (0, import_visitors_core28.visit)(setType.item, self);
        const sizeManifest = getArrayLikeSizeOption(setType.count, self);
        const encoderOptions = sizeManifest.encoder ? fragment`, { ${sizeManifest.encoder} }` : "";
        const decoderOptions = sizeManifest.decoder ? fragment`, { ${sizeManifest.decoder} }` : "";
        return typeManifest({
          ...childManifest,
          decoder: fragment`${use("getSetDecoder", "solanaCodecsDataStructures")}(${childManifest.decoder}${decoderOptions})`,
          encoder: fragment`${use("getSetEncoder", "solanaCodecsDataStructures")}(${childManifest.encoder}${encoderOptions})`,
          looseType: fragment`Set<${childManifest.looseType}>`,
          strictType: fragment`Set<${childManifest.strictType}>`
        });
      },
      visitSetValue(node, { self }) {
        return mergeTypeManifests(
          node.items.map((v) => (0, import_visitors_core28.visit)(v, self)),
          { mergeValues: (renders) => `new Set([${renders.join(", ")}])` }
        );
      },
      visitSizePrefixType(node, { self }) {
        const manifest = (0, import_visitors_core28.visit)(node.type, self);
        const prefix = (0, import_visitors_core28.visit)(node.prefix, self);
        return typeManifest({
          ...manifest,
          decoder: fragment`${use("addDecoderSizePrefix", "solanaCodecsCore")}(${manifest.decoder}, ${prefix.decoder})`,
          encoder: fragment`${use("addEncoderSizePrefix", "solanaCodecsCore")}(${manifest.encoder}, ${prefix.encoder})`
        });
      },
      visitSolAmountType({ number }, { self }) {
        const numberManifest = (0, import_visitors_core28.visit)(number, self);
        return typeManifest({
          ...numberManifest,
          decoder: fragment`${use("getLamportsDecoder", "solanaRpcTypes")}(${numberManifest.decoder})`,
          encoder: fragment`${use("getLamportsEncoder", "solanaRpcTypes")}(${numberManifest.encoder})`,
          looseType: use("type Lamports", "solanaRpcTypes"),
          strictType: use("type Lamports", "solanaRpcTypes")
        });
      },
      visitSomeValue(node, { self }) {
        const innerValue = (0, import_visitors_core28.visit)(node.value, self).value;
        return typeManifest({
          value: fragment`${use("some", "solanaOptions")}(${innerValue})`
        });
      },
      visitStringType(stringType) {
        const [encoder, decoder] = (() => {
          switch (stringType.encoding) {
            case "base16":
              return ["getBase16Encoder", "getBase16Decoder"];
            case "base58":
              return ["getBase58Encoder", "getBase58Decoder"];
            case "base64":
              return ["getBase64Encoder", "getBase64Decoder"];
            case "utf8":
              return ["getUtf8Encoder", "getUtf8Decoder"];
            default:
              throw new Error(`Unsupported string encoding: ${stringType.encoding}`);
          }
        })();
        return typeManifest({
          decoder: fragment`${use(decoder, "solanaCodecsStrings")}()`,
          encoder: fragment`${use(encoder, "solanaCodecsStrings")}()`,
          looseType: fragment`string`,
          strictType: fragment`string`
        });
      },
      visitStringValue(node) {
        return typeManifest({
          value: fragment`${JSON.stringify(node.string)}`
        });
      },
      visitStructFieldType(structFieldType, { self }) {
        const name = (0, import_nodes27.camelCase)(structFieldType.name);
        const originalChildManifest = (0, import_visitors_core28.visit)(structFieldType.type, self);
        let docs = getDocblockFragment(structFieldType.docs ?? [], true);
        docs = docs ? fragment`\n${docs}` : docs;
        const childManifest = typeManifest({
          ...originalChildManifest,
          decoder: fragment`['${name}', ${originalChildManifest.decoder}]`,
          encoder: fragment`['${name}', ${originalChildManifest.encoder}]`,
          looseType: fragment`${docs}${name}: ${originalChildManifest.looseType}; `,
          strictType: fragment`${docs}${name}: ${originalChildManifest.strictType}; `
        });
        if (!structFieldType.defaultValue) {
          return childManifest;
        }
        if (structFieldType.defaultValueStrategy !== "omitted") {
          return typeManifest({
            ...childManifest,
            looseType: fragment`${docs}${name}?: ${originalChildManifest.looseType}; `
          });
        }
        return typeManifest({ ...childManifest, looseType: fragment`` });
      },
      visitStructFieldValue(node, { self }) {
        const innerValue = (0, import_visitors_core28.visit)(node.value, self).value;
        return typeManifest({
          value: fragment`${node.name}: ${innerValue}`
        });
      },
      visitStructType(structType, { self }) {
        const optionalFields = structType.fields.filter((f) => !!f.defaultValue);
        const mergedManifest = (0, import_visitors_core28.pipe)(
          mergeTypeManifests(
            structType.fields.map((field) => (0, import_visitors_core28.visit)(field, self)),
            {
              mergeCodecs: (renders) => `([${renders.join(", ")}])`,
              mergeTypes: (renders) => `{ ${renders.join("")} }`
            }
          ),
          (manifest) => typeManifest({
            ...manifest,
            decoder: fragment`${use("getStructDecoder", "solanaCodecsDataStructures")}${manifest.decoder}`,
            encoder: fragment`${use("getStructEncoder", "solanaCodecsDataStructures")}${manifest.encoder}`
          })
        );
        if (optionalFields.length === 0) {
          return mergedManifest;
        }
        const parentPath = stack.getPath();
        const instructionNode = (0, import_visitors_core28.findLastNodeFromPath)(parentPath, "instructionNode");
        const accountNode = (0, import_visitors_core28.findLastNodeFromPath)(parentPath, "accountNode");
        const discriminatorPrefix = instructionNode ? instructionNode.name : accountNode?.name;
        const discriminators = (instructionNode ? instructionNode.discriminators : accountNode?.discriminators) ?? [];
        const fieldDiscriminators = discriminators.filter((0, import_nodes27.isNodeFilter)("fieldDiscriminatorNode"));
        const defaultValues = mergeFragments(
          optionalFields.map((f) => {
            const key = (0, import_nodes27.camelCase)(f.name);
            if (fieldDiscriminators.some((d) => d.name === f.name)) {
              const constantName = nameApi.constant((0, import_nodes27.camelCase)(`${discriminatorPrefix}_${f.name}`));
              return f.defaultValueStrategy === "omitted" ? fragment`${key}: ${constantName}` : fragment`${key}: value.${key} ?? ${constantName}`;
            }
            const defaultValue = f.defaultValue;
            const value = (0, import_visitors_core28.visit)(defaultValue, self).value;
            return f.defaultValueStrategy === "omitted" ? fragment`${key}: ${value}` : fragment`${key}: value.${key} ?? ${value}`;
          }),
          (cs) => cs.join(", ")
        );
        return typeManifest({
          ...mergedManifest,
          encoder: fragment`${use("transformEncoder", "solanaCodecsCore")}(${mergedManifest.encoder}, (value) => ({ ...value, ${defaultValues} }))`
        });
      },
      visitStructValue(node, { self }) {
        return mergeTypeManifests(
          node.fields.map((field) => (0, import_visitors_core28.visit)(field, self)),
          { mergeValues: (renders) => `{ ${renders.join(", ")} }` }
        );
      },
      visitTupleType(tupleType, { self }) {
        const items = tupleType.items.map((item) => (0, import_visitors_core28.visit)(item, self));
        const mergedManifest = mergeTypeManifests(items, {
          mergeCodecs: (codecs) => `[${codecs.join(", ")}]`,
          mergeTypes: (types) => `readonly [${types.join(", ")}]`
        });
        return typeManifest({
          ...mergedManifest,
          decoder: fragment`${use("getTupleDecoder", "solanaCodecsDataStructures")}(${mergedManifest.decoder})`,
          encoder: fragment`${use("getTupleEncoder", "solanaCodecsDataStructures")}(${mergedManifest.encoder})`
        });
      },
      visitTupleValue(node, { self }) {
        return mergeTypeManifests(
          node.items.map((v) => (0, import_visitors_core28.visit)(v, self)),
          { mergeValues: (renders) => `[${renders.join(", ")}]` }
        );
      },
      visitZeroableOptionType(node, { self }) {
        const childManifest = (0, import_visitors_core28.visit)(node.item, self);
        const encoderOptions = [fragment`prefix: null`];
        const decoderOptions = [fragment`prefix: null`];
        if (node.zeroValue) {
          const zeroValueManifest = (0, import_visitors_core28.visit)(node.zeroValue, self);
          encoderOptions.push(fragment`noneValue: ${zeroValueManifest.value}`);
          decoderOptions.push(fragment`noneValue: ${zeroValueManifest.value}`);
        } else {
          encoderOptions.push(fragment`noneValue: "zeroes"`);
          decoderOptions.push(fragment`noneValue: "zeroes"`);
        }
        const encoderOptionsFragment = mergeFragments(
          encoderOptions,
          (cs) => cs.length > 0 ? `, { ${cs.join(", ")} }` : ""
        );
        const decoderOptionsFragment = mergeFragments(
          decoderOptions,
          (cs) => cs.length > 0 ? `, { ${cs.join(", ")} }` : ""
        );
        return typeManifest({
          ...childManifest,
          decoder: fragment`${use("getOptionDecoder", "solanaOptions")}(${childManifest.decoder}${decoderOptionsFragment})`,
          encoder: fragment`${use("getOptionEncoder", "solanaOptions")}(${childManifest.encoder}${encoderOptionsFragment})`,
          looseType: fragment`${use("type OptionOrNullable", "solanaOptions")}<${childManifest.looseType}>`,
          strictType: fragment`${use("type Option", "solanaOptions")}<${childManifest.strictType}>`
        });
      }
    }),
    (visitor) => (0, import_visitors_core28.recordNodeStackVisitor)(visitor, stack)
  );
}
function getArrayLikeSizeOption(count, visitor) {
  if ((0, import_nodes27.isNode)(count, "fixedCountNode")) {
    return {
      decoder: fragment`size: ${count.value}`,
      encoder: fragment`size: ${count.value}`
    };
  }
  if ((0, import_nodes27.isNode)(count, "remainderCountNode")) {
    return {
      decoder: fragment`size: 'remainder'`,
      encoder: fragment`size: 'remainder'`
    };
  }
  const prefix = (0, import_nodes27.resolveNestedTypeNode)(count.prefix);
  if (prefix.format === "u32" && prefix.endian === "le") {
    return { decoder: void 0, encoder: void 0 };
  }
  const prefixManifest = (0, import_visitors_core28.visit)(count.prefix, visitor);
  return {
    decoder: (0, import_visitors_core28.pipe)(prefixManifest.decoder, (f) => (0, import_renderers_core12.mapFragmentContent)(f, (c) => `size: ${c}`)),
    encoder: (0, import_visitors_core28.pipe)(prefixManifest.encoder, (f) => (0, import_renderers_core12.mapFragmentContent)(f, (c) => `size: ${c}`))
  };
}

// src/visitors/getRenderMapVisitor.ts
function getRenderMapVisitor(options = {}) {
  const linkables = new import_visitors_core29.LinkableDictionary();
  const stack = new import_visitors_core29.NodeStack();
  const customAccountData = parseCustomDataOptions(options.customAccountData ?? [], "AccountData");
  const customInstructionData = parseCustomDataOptions(options.customInstructionData ?? [], "InstructionData");
  const renderScopeWithTypeManifestVisitor = {
    asyncResolvers: (options.asyncResolvers ?? []).map(import_nodes28.camelCase),
    customAccountData,
    customInstructionData,
    dependencyMap: options.dependencyMap ?? {},
    getImportFrom: getImportFromFactory(options.linkOverrides ?? {}, customAccountData, customInstructionData),
    linkables,
    nameApi: getNameApi({ ...DEFAULT_NAME_TRANSFORMERS, ...options.nameTransformers }),
    nonScalarEnums: (options.nonScalarEnums ?? []).map(import_nodes28.camelCase),
    renderParentInstructions: options.renderParentInstructions ?? false,
    useGranularImports: options.useGranularImports ?? false
  };
  const typeManifestVisitor = getTypeManifestVisitor({ ...renderScopeWithTypeManifestVisitor, stack });
  const renderScope = { ...renderScopeWithTypeManifestVisitor, typeManifestVisitor };
  const internalNodes = (options.internalNodes ?? []).map(import_nodes28.camelCase);
  const resolvedInstructionInputVisitor = (0, import_visitors_core29.getResolvedInstructionInputsVisitor)();
  const byteSizeVisitor = (0, import_visitors_core29.getByteSizeVisitor)(linkables, { stack });
  const asPage = (fragment2, dependencyMap = {}) => {
    if (!fragment2) return void 0;
    return getPageFragment(fragment2, {
      ...renderScope,
      dependencyMap: { ...renderScope.dependencyMap, ...dependencyMap }
    });
  };
  return (0, import_visitors_core29.pipe)(
    (0, import_visitors_core29.staticVisitor)(() => (0, import_renderers_core13.createRenderMap)(), {
      keys: ["rootNode", "programNode", "pdaNode", "accountNode", "definedTypeNode", "instructionNode"]
    }),
    (v) => (0, import_visitors_core29.extendVisitor)(v, {
      visitAccount(node) {
        return (0, import_renderers_core13.createRenderMap)(
          `accounts/${(0, import_nodes28.camelCase)(node.name)}.ts`,
          asPage(
            getAccountPageFragment({
              ...renderScope,
              accountPath: stack.getPath("accountNode"),
              size: (0, import_visitors_core29.visit)(node, byteSizeVisitor)
            })
          )
        );
      },
      visitDefinedType(node) {
        return (0, import_renderers_core13.createRenderMap)(
          `types/${(0, import_nodes28.camelCase)(node.name)}.ts`,
          asPage(getTypePageFragment({ ...renderScope, node, size: (0, import_visitors_core29.visit)(node, byteSizeVisitor) }), {
            generatedTypes: "."
          })
        );
      },
      visitInstruction(node) {
        return (0, import_renderers_core13.createRenderMap)(
          `instructions/${(0, import_nodes28.camelCase)(node.name)}.ts`,
          asPage(
            getInstructionPageFragment({
              ...renderScope,
              instructionPath: stack.getPath("instructionNode"),
              resolvedInputs: (0, import_visitors_core29.visit)(node, resolvedInstructionInputVisitor),
              size: (0, import_visitors_core29.visit)(node, byteSizeVisitor)
            })
          )
        );
      },
      visitPda(node) {
        return (0, import_renderers_core13.createRenderMap)(
          `pdas/${(0, import_nodes28.camelCase)(node.name)}.ts`,
          asPage(getPdaPageFragment({ ...renderScope, pdaPath: stack.getPath("pdaNode") }))
        );
      },
      visitProgram(node, { self }) {
        const customDataDefinedType = [
          ...getDefinedTypeNodesToExtract(node.accounts, customAccountData),
          ...getDefinedTypeNodesToExtract(node.instructions, customInstructionData)
        ];
        const scope = { ...renderScope, programNode: node };
        return (0, import_renderers_core13.mergeRenderMaps)([
          (0, import_renderers_core13.createRenderMap)({
            [`programs/${(0, import_nodes28.camelCase)(node.name)}.ts`]: asPage(getProgramPageFragment(scope)),
            [`errors/${(0, import_nodes28.camelCase)(node.name)}.ts`]: node.errors.length > 0 ? asPage(getErrorPageFragment(scope)) : void 0
          }),
          ...node.pdas.map((p) => (0, import_visitors_core29.visit)(p, self)),
          ...node.accounts.map((a) => (0, import_visitors_core29.visit)(a, self)),
          ...node.definedTypes.map((t) => (0, import_visitors_core29.visit)(t, self)),
          ...customDataDefinedType.map((t) => (0, import_visitors_core29.visit)(t, self)),
          ...(0, import_nodes28.getAllInstructionsWithSubs)(node, { leavesOnly: !renderScope.renderParentInstructions }).map(
            (i) => (0, import_visitors_core29.visit)(i, self)
          )
        ]);
      },
      visitRoot(node, { self }) {
        const isNotInternal = (n) => !internalNodes.includes(n.name);
        const programsToExport = (0, import_nodes28.getAllPrograms)(node).filter(isNotInternal);
        const programsWithErrorsToExport = programsToExport.filter((p) => p.errors.length > 0);
        const pdasToExport = (0, import_nodes28.getAllPdas)(node);
        const accountsToExport = (0, import_nodes28.getAllAccounts)(node).filter(isNotInternal);
        const instructionsToExport = (0, import_nodes28.getAllInstructionsWithSubs)(node, {
          leavesOnly: !renderScope.renderParentInstructions
        }).filter(isNotInternal);
        const definedTypesToExport = (0, import_nodes28.getAllDefinedTypes)(node).filter(isNotInternal);
        const hasAnythingToExport = programsToExport.length > 0 || accountsToExport.length > 0 || instructionsToExport.length > 0 || definedTypesToExport.length > 0;
        const scope = {
          ...renderScope,
          accountsToExport,
          definedTypesToExport,
          instructionsToExport,
          pdasToExport,
          programsToExport
        };
        return (0, import_renderers_core13.mergeRenderMaps)([
          (0, import_renderers_core13.createRenderMap)({
            ["accounts/index.ts"]: asPage(getIndexPageFragment(accountsToExport)),
            ["errors/index.ts"]: asPage(getIndexPageFragment(programsWithErrorsToExport)),
            ["index.ts"]: asPage(getRootIndexPageFragment(scope)),
            ["instructions/index.ts"]: asPage(getIndexPageFragment(instructionsToExport)),
            ["pdas/index.ts"]: asPage(getIndexPageFragment(pdasToExport)),
            ["programs/index.ts"]: asPage(getIndexPageFragment(programsToExport)),
            ["shared/index.ts"]: hasAnythingToExport ? asPage(getSharedPageFragment()) : void 0,
            ["types/index.ts"]: asPage(getIndexPageFragment(definedTypesToExport))
          }),
          ...(0, import_nodes28.getAllPrograms)(node).map((p) => (0, import_visitors_core29.visit)(p, self))
        ]);
      }
    }),
    (v) => (0, import_visitors_core29.recordNodeStackVisitor)(v, stack),
    (v) => (0, import_visitors_core29.recordLinkablesOnFirstVisitVisitor)(v, linkables)
  );
}

// src/visitors/renderVisitor.ts
var import_renderers_core14 = require("@codama/renderers-core");
var import_visitors_core30 = require("@codama/visitors-core");
var estreePlugin = __toESM(require("prettier/plugins/estree"));
var typeScriptPlugin = __toESM(require("prettier/plugins/typescript"));
var import_standalone = require("prettier/standalone");
var DEFAULT_PRETTIER_OPTIONS = {
  arrowParens: "always",
  parser: "typescript",
  plugins: [estreePlugin, typeScriptPlugin],
  printWidth: 80,
  semi: true,
  singleQuote: true,
  tabWidth: 2,
  trailingComma: "es5",
  useTabs: false
};
function renderVisitor(path, options = {}) {
  return (0, import_visitors_core30.rootNodeVisitor)(async (root) => {
    if (options.deleteFolderBeforeRendering ?? true) {
      (0, import_renderers_core14.deleteDirectory)(path);
    }
    let renderMap = (0, import_visitors_core30.visit)(root, getRenderMapVisitor(options));
    if (options.formatCode ?? true) {
      const prettierOptions = { ...DEFAULT_PRETTIER_OPTIONS, ...options.prettierOptions };
      renderMap = await (0, import_renderers_core14.mapRenderMapContentAsync)(renderMap, (code) => (0, import_standalone.format)(code, prettierOptions));
    }
    (0, import_renderers_core14.writeRenderMap)(renderMap, path);
  });
}
//# sourceMappingURL=index.browser.cjs.map