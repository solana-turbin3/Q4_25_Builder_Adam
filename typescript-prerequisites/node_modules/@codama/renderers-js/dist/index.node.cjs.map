{"version":3,"sources":["../src/index.ts","../src/utils/importMap.ts","../src/utils/nameTransformers.ts","../src/utils/fragment.ts","../src/utils/typeManifest.ts","../src/visitors/getRenderMapVisitor.ts","../src/fragments/accountFetchHelpers.ts","../src/utils/async.ts","../src/utils/codecs.ts","../src/utils/customData.ts","../src/utils/linkOverrides.ts","../src/fragments/accountPage.ts","../src/fragments/accountPdaHelpers.ts","../src/fragments/accountSizeHelpers.ts","../src/fragments/accountType.ts","../src/fragments/type.ts","../src/fragments/typeDecoder.ts","../src/fragments/typeEncoder.ts","../src/fragments/typeCodec.ts","../src/fragments/typeWithCodec.ts","../src/fragments/discriminatorConstants.ts","../src/fragments/discriminatorCondition.ts","../src/fragments/errorPage.ts","../src/fragments/indexPage.ts","../src/fragments/instructionAccountMeta.ts","../src/fragments/instructionAccountTypeParam.ts","../src/fragments/instructionByteDelta.ts","../src/fragments/instructionData.ts","../src/fragments/instructionExtraArgs.ts","../src/fragments/instructionFunction.ts","../src/fragments/instructionInputResolved.ts","../src/fragments/instructionInputDefault.ts","../src/fragments/instructionInputType.ts","../src/fragments/instructionRemainingAccounts.ts","../src/fragments/instructionPage.ts","../src/fragments/instructionParseFunction.ts","../src/fragments/instructionType.ts","../src/fragments/pdaFunction.ts","../src/fragments/pdaPage.ts","../src/fragments/programAccounts.ts","../src/fragments/programConstant.ts","../src/fragments/programInstructions.ts","../src/fragments/programPage.ts","../src/fragments/rootIndexPage.ts","../src/fragments/sharedPage.ts","../src/fragments/typeDiscriminatedUnionHelpers.ts","../src/fragments/typePage.ts","../src/visitors/getTypeManifestVisitor.ts","../src/visitors/renderVisitor.ts"],"sourcesContent":["export * from './utils/importMap';\nexport * from './utils/nameTransformers';\nexport * from './utils/typeManifest';\nexport * from './visitors';\n\nexport { renderVisitor as default } from './visitors';\n","const DEFAULT_EXTERNAL_MODULE_MAP: Record<string, string> = {\n    solanaAccounts: '@solana/kit',\n    solanaAddresses: '@solana/kit',\n    solanaCodecsCore: '@solana/kit',\n    solanaCodecsDataStructures: '@solana/kit',\n    solanaCodecsNumbers: '@solana/kit',\n    solanaCodecsStrings: '@solana/kit',\n    solanaErrors: '@solana/kit',\n    solanaInstructions: '@solana/kit',\n    solanaOptions: '@solana/kit',\n    solanaPrograms: '@solana/kit',\n    solanaRpcTypes: '@solana/kit',\n    solanaSigners: '@solana/kit',\n};\n\nconst DEFAULT_GRANULAR_EXTERNAL_MODULE_MAP: Record<string, string> = {\n    solanaAccounts: '@solana/accounts',\n    solanaAddresses: '@solana/addresses',\n    solanaCodecsCore: '@solana/codecs',\n    solanaCodecsDataStructures: '@solana/codecs',\n    solanaCodecsNumbers: '@solana/codecs',\n    solanaCodecsStrings: '@solana/codecs',\n    solanaErrors: '@solana/errors',\n    solanaInstructions: '@solana/instructions',\n    solanaOptions: '@solana/codecs',\n    solanaPrograms: '@solana/programs',\n    solanaRpcTypes: '@solana/rpc-types',\n    solanaSigners: '@solana/signers',\n};\n\nconst DEFAULT_INTERNAL_MODULE_MAP: Record<string, string> = {\n    errors: '../errors',\n    generated: '..',\n    generatedAccounts: '../accounts',\n    generatedErrors: '../errors',\n    generatedInstructions: '../instructions',\n    generatedPdas: '../pdas',\n    generatedPrograms: '../programs',\n    generatedTypes: '../types',\n    hooked: '../../hooked',\n    shared: '../shared',\n    types: '../types',\n};\n\ntype ImportInput = string;\ntype Module = string;\ntype UsedIdentifier = string;\ntype ImportInfo = Readonly<{\n    importedIdentifier: string;\n    isType: boolean;\n    usedIdentifier: UsedIdentifier;\n}>;\n\nexport type ImportMap = ReadonlyMap<Module, ReadonlyMap<UsedIdentifier, ImportInfo>>;\n\nexport function createImportMap(): ImportMap {\n    return Object.freeze(new Map());\n}\n\nexport function parseImportInput(input: ImportInput): ImportInfo {\n    const matches = input.match(/^(type )?([^ ]+)(?: as (.+))?$/);\n    if (!matches) return Object.freeze({ importedIdentifier: input, isType: false, usedIdentifier: input });\n\n    const [_, isType, name, alias] = matches;\n    return Object.freeze({\n        importedIdentifier: name,\n        isType: !!isType,\n        usedIdentifier: alias ?? name,\n    });\n}\n\nexport function addToImportMap(importMap: ImportMap, module: Module, imports: ImportInput[]): ImportMap {\n    const parsedImports = imports.map(parseImportInput).map(i => [i.usedIdentifier, i] as const);\n    return mergeImportMaps([importMap, new Map([[module, new Map(parsedImports)]])]);\n}\n\nexport function removeFromImportMap(\n    importMap: ImportMap,\n    module: Module,\n    usedIdentifiers: UsedIdentifier[],\n): ImportMap {\n    const newMap = new Map(importMap);\n    const newModuleMap = new Map(newMap.get(module));\n    usedIdentifiers.forEach(usedIdentifier => {\n        newModuleMap.delete(usedIdentifier);\n    });\n    if (newModuleMap.size === 0) {\n        newMap.delete(module);\n    } else {\n        newMap.set(module, newModuleMap);\n    }\n    return Object.freeze(newMap);\n}\n\nexport function mergeImportMaps(importMaps: ImportMap[]): ImportMap {\n    if (importMaps.length === 0) return createImportMap();\n    if (importMaps.length === 1) return importMaps[0];\n    const mergedMap = new Map(importMaps[0]);\n    for (const map of importMaps.slice(1)) {\n        for (const [module, imports] of map) {\n            const mergedModuleMap = (mergedMap.get(module) ?? new Map()) as Map<UsedIdentifier, ImportInfo>;\n            for (const [usedIdentifier, importInfo] of imports) {\n                const existingImportInfo = mergedModuleMap.get(usedIdentifier);\n                // If two identical imports exist such that\n                // one is a type import and the other is not,\n                // then we must only keep the non-type import.\n                const shouldOverwriteTypeOnly =\n                    existingImportInfo &&\n                    existingImportInfo.importedIdentifier === importInfo.importedIdentifier &&\n                    existingImportInfo.isType &&\n                    !importInfo.isType;\n                if (!existingImportInfo || shouldOverwriteTypeOnly) {\n                    mergedModuleMap.set(usedIdentifier, importInfo);\n                }\n            }\n            mergedMap.set(module, mergedModuleMap);\n        }\n    }\n    return Object.freeze(mergedMap);\n}\n\nexport function importMapToString(\n    importMap: ImportMap,\n    dependencyMap: Record<string, string> = {},\n    useGranularImports = false,\n): string {\n    const resolvedMap = resolveImportMapModules(importMap, dependencyMap, useGranularImports);\n\n    return [...resolvedMap.entries()]\n        .sort(([a], [b]) => {\n            const relative = Number(a.startsWith('.')) - Number(b.startsWith('.'));\n            // Relative imports go last.\n            if (relative !== 0) return relative;\n            // Otherwise, sort alphabetically.\n            return a.localeCompare(b);\n        })\n        .map(([module, imports]) => {\n            const innerImports = [...imports.values()]\n                .map(importInfoToString)\n                .sort((a, b) => a.localeCompare(b))\n                .join(', ');\n            return `import { ${innerImports} } from '${module}';`;\n        })\n        .join('\\n');\n}\n\nfunction resolveImportMapModules(\n    importMap: ImportMap,\n    dependencyMap: Record<string, string>,\n    useGranularImports: boolean,\n): ImportMap {\n    const dependencyMapWithDefaults = {\n        ...(useGranularImports ? DEFAULT_GRANULAR_EXTERNAL_MODULE_MAP : DEFAULT_EXTERNAL_MODULE_MAP),\n        ...DEFAULT_INTERNAL_MODULE_MAP,\n        ...dependencyMap,\n    };\n\n    return mergeImportMaps(\n        [...importMap.entries()].map(([module, imports]) => {\n            const resolvedModule = dependencyMapWithDefaults[module] ?? module;\n            return new Map([[resolvedModule, imports]]);\n        }),\n    );\n}\n\nfunction importInfoToString({ importedIdentifier, isType, usedIdentifier }: ImportInfo): string {\n    const alias = importedIdentifier !== usedIdentifier ? ` as ${usedIdentifier}` : '';\n    return `${isType ? 'type ' : ''}${importedIdentifier}${alias}`;\n}\n","import { camelCase, capitalize, kebabCase, pascalCase, snakeCase, titleCase } from '@codama/nodes';\n\nexport type NameTransformerHelpers = {\n    camelCase: (name: string) => string;\n    capitalize: (name: string) => string;\n    kebabCase: (name: string) => string;\n    pascalCase: (name: string) => string;\n    snakeCase: (name: string) => string;\n    titleCase: (name: string) => string;\n};\n\nexport type NameTransformer = (name: string, helpers: NameTransformerHelpers) => string;\n\nexport type NameTransformerKey =\n    | 'accountDecodeFunction'\n    | 'accountFetchAllFunction'\n    | 'accountFetchAllMaybeFunction'\n    | 'accountFetchFromSeedsFunction'\n    | 'accountFetchFunction'\n    | 'accountFetchMaybeFromSeedsFunction'\n    | 'accountFetchMaybeFunction'\n    | 'accountGetSizeFunction'\n    | 'codecFunction'\n    | 'constant'\n    | 'constantFunction'\n    | 'dataArgsType'\n    | 'dataType'\n    | 'decoderFunction'\n    | 'discriminatedUnionDiscriminator'\n    | 'discriminatedUnionFunction'\n    | 'discriminatedUnionVariant'\n    | 'encoderFunction'\n    | 'enumVariant'\n    | 'instructionAsyncFunction'\n    | 'instructionAsyncInputType'\n    | 'instructionDataType'\n    | 'instructionExtraType'\n    | 'instructionParsedType'\n    | 'instructionParseFunction'\n    | 'instructionSyncFunction'\n    | 'instructionSyncInputType'\n    | 'instructionType'\n    | 'isDiscriminatedUnionFunction'\n    | 'pdaFindFunction'\n    | 'pdaSeedsType'\n    | 'programAccountsEnum'\n    | 'programAccountsEnumVariant'\n    | 'programAccountsIdentifierFunction'\n    | 'programAddressConstant'\n    | 'programErrorConstant'\n    | 'programErrorConstantPrefix'\n    | 'programErrorMessagesMap'\n    | 'programErrorUnion'\n    | 'programGetErrorMessageFunction'\n    | 'programInstructionsEnum'\n    | 'programInstructionsEnumVariant'\n    | 'programInstructionsIdentifierFunction'\n    | 'programInstructionsParsedUnionType'\n    | 'programIsErrorFunction'\n    | 'resolverFunction';\n\nexport type NameTransformers = Record<NameTransformerKey, NameTransformer>;\n\nexport type NameApi = Record<NameTransformerKey, (name: string) => string>;\n\nexport function getNameApi(transformers: NameTransformers): NameApi {\n    const helpers = {\n        camelCase,\n        capitalize,\n        kebabCase,\n        pascalCase,\n        snakeCase,\n        titleCase,\n    };\n    return Object.fromEntries(\n        Object.entries(transformers).map(([key, transformer]) => [key, (name: string) => transformer(name, helpers)]),\n    ) as NameApi;\n}\n\nexport const DEFAULT_NAME_TRANSFORMERS: NameTransformers = {\n    accountDecodeFunction: name => `decode${pascalCase(name)}`,\n    accountFetchAllFunction: name => `fetchAll${pascalCase(name)}`,\n    accountFetchAllMaybeFunction: name => `fetchAllMaybe${pascalCase(name)}`,\n    accountFetchFromSeedsFunction: name => `fetch${pascalCase(name)}FromSeeds`,\n    accountFetchFunction: name => `fetch${pascalCase(name)}`,\n    accountFetchMaybeFromSeedsFunction: name => `fetchMaybe${pascalCase(name)}FromSeeds`,\n    accountFetchMaybeFunction: name => `fetchMaybe${pascalCase(name)}`,\n    accountGetSizeFunction: name => `get${pascalCase(name)}Size`,\n    codecFunction: name => `get${pascalCase(name)}Codec`,\n    constant: name => snakeCase(name).toUpperCase(),\n    constantFunction: name => `get${pascalCase(name)}Bytes`,\n    dataArgsType: name => `${pascalCase(name)}Args`,\n    dataType: name => `${pascalCase(name)}`,\n    decoderFunction: name => `get${pascalCase(name)}Decoder`,\n    discriminatedUnionDiscriminator: () => '__kind',\n    discriminatedUnionFunction: name => `${camelCase(name)}`,\n    discriminatedUnionVariant: name => `${pascalCase(name)}`,\n    encoderFunction: name => `get${pascalCase(name)}Encoder`,\n    enumVariant: name => `${pascalCase(name)}`,\n    instructionAsyncFunction: name => `get${pascalCase(name)}InstructionAsync`,\n    instructionAsyncInputType: name => `${pascalCase(name)}AsyncInput`,\n    instructionDataType: name => `${pascalCase(name)}InstructionData`,\n    instructionExtraType: name => `${pascalCase(name)}InstructionExtra`,\n    instructionParseFunction: name => `parse${pascalCase(name)}Instruction`,\n    instructionParsedType: name => `Parsed${pascalCase(name)}Instruction`,\n    instructionSyncFunction: name => `get${pascalCase(name)}Instruction`,\n    instructionSyncInputType: name => `${pascalCase(name)}Input`,\n    instructionType: name => `${pascalCase(name)}Instruction`,\n    isDiscriminatedUnionFunction: name => `is${pascalCase(name)}`,\n    pdaFindFunction: name => `find${pascalCase(name)}Pda`,\n    pdaSeedsType: name => `${pascalCase(name)}Seeds`,\n    programAccountsEnum: name => `${pascalCase(name)}Account`,\n    programAccountsEnumVariant: name => `${pascalCase(name)}`,\n    programAccountsIdentifierFunction: name => `identify${pascalCase(name)}Account`,\n    programAddressConstant: name => `${snakeCase(name).toUpperCase()}_PROGRAM_ADDRESS`,\n    programErrorConstant: name => snakeCase(name).toUpperCase(),\n    programErrorConstantPrefix: name => `${snakeCase(name).toUpperCase()}_ERROR__`,\n    programErrorMessagesMap: name => `${camelCase(name)}ErrorMessages`,\n    programErrorUnion: name => `${pascalCase(name)}Error`,\n    programGetErrorMessageFunction: name => `get${pascalCase(name)}ErrorMessage`,\n    programInstructionsEnum: name => `${pascalCase(name)}Instruction`,\n    programInstructionsEnumVariant: name => `${pascalCase(name)}`,\n    programInstructionsIdentifierFunction: name => `identify${pascalCase(name)}Instruction`,\n    programInstructionsParsedUnionType: name => `Parsed${pascalCase(name)}Instruction`,\n    programIsErrorFunction: name => `is${pascalCase(name)}Error`,\n    resolverFunction: name => `${camelCase(name)}`,\n};\n","import { Docs } from '@codama/nodes';\nimport { BaseFragment, createFragmentTemplate } from '@codama/renderers-core';\n\nimport {\n    addToImportMap,\n    createImportMap,\n    ImportMap,\n    importMapToString,\n    mergeImportMaps,\n    parseImportInput,\n    removeFromImportMap,\n} from './importMap';\nimport { RenderScope } from './options';\n\nexport type FragmentFeature = 'instruction:resolverScopeVariable';\n\nexport type Fragment = BaseFragment &\n    Readonly<{\n        features: ReadonlySet<FragmentFeature>;\n        imports: ImportMap;\n    }>;\n\nfunction createFragment(content: string): Fragment {\n    return Object.freeze({ content, features: new Set<FragmentFeature>(), imports: createImportMap() });\n}\n\nfunction isFragment(value: unknown): value is Fragment {\n    return typeof value === 'object' && value !== null && 'content' in value;\n}\n\nexport function fragment(template: TemplateStringsArray, ...items: unknown[]): Fragment {\n    return createFragmentTemplate(template, items, isFragment, mergeFragments);\n}\n\nexport function mergeFragments(fragments: (Fragment | undefined)[], mergeContent: (contents: string[]) => string) {\n    const filteredFragments = fragments.filter((f): f is Fragment => f !== undefined);\n    return Object.freeze({\n        content: mergeContent(filteredFragments.map(fragment => fragment.content)),\n        features: new Set(filteredFragments.flatMap(f => [...f.features])),\n        imports: mergeImportMaps(filteredFragments.map(f => f.imports)),\n    });\n}\n\nexport function use(importInput: string, module: string): Fragment {\n    const importInfo = parseImportInput(importInput);\n    return addFragmentImports(createFragment(importInfo.usedIdentifier), module, [importInput]);\n}\n\nexport function mergeFragmentImports(fragment: Fragment, importMaps: ImportMap[]): Fragment {\n    return Object.freeze({ ...fragment, imports: mergeImportMaps([fragment.imports, ...importMaps]) });\n}\n\nexport function addFragmentImports(fragment: Fragment, module: string, importInputs: string[]): Fragment {\n    return Object.freeze({ ...fragment, imports: addToImportMap(fragment.imports, module, importInputs) });\n}\n\nexport function removeFragmentImports(fragment: Fragment, module: string, usedIdentifiers: string[]): Fragment {\n    return Object.freeze({ ...fragment, imports: removeFromImportMap(fragment.imports, module, usedIdentifiers) });\n}\n\nexport function addFragmentFeatures(fragment: Fragment, features: FragmentFeature[]): Fragment {\n    return Object.freeze({ ...fragment, features: new Set([...fragment.features, ...features]) });\n}\n\nexport function getExportAllFragment(module: string): Fragment {\n    return fragment`export * from '${module}';`;\n}\n\nexport function getDocblockFragment(lines: Docs, withLineJump = false): Fragment | undefined {\n    const lineJump = withLineJump ? '\\n' : '';\n    if (lines.length === 0) return;\n    if (lines.length === 1) return fragment`/** ${lines[0]} */${lineJump}`;\n    const prefixedLines = lines.map(line => (line ? ` * ${line}` : ' *'));\n    return fragment`/**\\n${prefixedLines.join('\\n')}\\n */${lineJump}`;\n}\n\nexport function getPageFragment(\n    page: Fragment,\n    scope: Pick<RenderScope, 'dependencyMap' | 'useGranularImports'>,\n): Fragment {\n    const header = getDocblockFragment([\n        'This code was AUTOGENERATED using the Codama library.',\n        'Please DO NOT EDIT THIS FILE, instead use visitors',\n        'to add features, then rerun Codama to update it.',\n        '',\n        '@see https://github.com/codama-idl/codama',\n    ]);\n    const imports =\n        page.imports.size === 0\n            ? undefined\n            : fragment`${importMapToString(page.imports, scope.dependencyMap, scope.useGranularImports)}`;\n    return mergeFragments([header, imports, page], cs => cs.join('\\n\\n'));\n}\n","import { Fragment, fragment, mergeFragments } from './fragment';\n\nexport type TypeManifest = Readonly<{\n    decoder: Fragment;\n    encoder: Fragment;\n    isEnum: boolean;\n    looseType: Fragment;\n    strictType: Fragment;\n    value: Fragment;\n}>;\n\nexport function typeManifest(input: Partial<TypeManifest> = {}): TypeManifest {\n    return Object.freeze({\n        decoder: fragment``,\n        encoder: fragment``,\n        isEnum: false,\n        looseType: fragment``,\n        strictType: fragment``,\n        value: fragment``,\n        ...input,\n    });\n}\n\nexport function mergeTypeManifests(\n    manifests: TypeManifest[],\n    options: {\n        mergeCodecs?: (renders: string[]) => string;\n        mergeTypes?: (renders: string[]) => string;\n        mergeValues?: (renders: string[]) => string;\n    } = {},\n): TypeManifest {\n    const { mergeTypes, mergeCodecs, mergeValues } = options;\n    const merge = (fragmentFn: (m: TypeManifest) => Fragment, mergeFn?: (r: string[]) => string) =>\n        mergeFn ? mergeFragments(manifests.map(fragmentFn), mergeFn) : fragment``;\n    return Object.freeze({\n        decoder: merge(m => m.decoder, mergeCodecs),\n        encoder: merge(m => m.encoder, mergeCodecs),\n        isEnum: false,\n        looseType: merge(m => m.looseType, mergeTypes),\n        strictType: merge(m => m.strictType, mergeTypes),\n        value: merge(m => m.value, mergeValues),\n    });\n}\n","import {\n    camelCase,\n    CamelCaseString,\n    getAllAccounts,\n    getAllDefinedTypes,\n    getAllInstructionsWithSubs,\n    getAllPdas,\n    getAllPrograms,\n} from '@codama/nodes';\nimport { createRenderMap, mergeRenderMaps } from '@codama/renderers-core';\nimport {\n    extendVisitor,\n    getByteSizeVisitor,\n    getResolvedInstructionInputsVisitor,\n    LinkableDictionary,\n    NodeStack,\n    pipe,\n    recordLinkablesOnFirstVisitVisitor,\n    recordNodeStackVisitor,\n    staticVisitor,\n    visit,\n} from '@codama/visitors-core';\n\nimport {\n    getAccountPageFragment,\n    getErrorPageFragment,\n    getIndexPageFragment,\n    getInstructionPageFragment,\n    getPdaPageFragment,\n    getProgramPageFragment,\n    getRootIndexPageFragment,\n    getSharedPageFragment,\n    getTypePageFragment,\n} from '../fragments';\nimport {\n    DEFAULT_NAME_TRANSFORMERS,\n    Fragment,\n    getDefinedTypeNodesToExtract,\n    getImportFromFactory,\n    getNameApi,\n    getPageFragment,\n    GetRenderMapOptions,\n    parseCustomDataOptions,\n    RenderScope,\n} from '../utils';\nimport { getTypeManifestVisitor } from './getTypeManifestVisitor';\n\nexport function getRenderMapVisitor(options: GetRenderMapOptions = {}) {\n    const linkables = new LinkableDictionary();\n    const stack = new NodeStack();\n\n    const customAccountData = parseCustomDataOptions(options.customAccountData ?? [], 'AccountData');\n    const customInstructionData = parseCustomDataOptions(options.customInstructionData ?? [], 'InstructionData');\n    const renderScopeWithTypeManifestVisitor: Omit<RenderScope, 'typeManifestVisitor'> = {\n        asyncResolvers: (options.asyncResolvers ?? []).map(camelCase),\n        customAccountData,\n        customInstructionData,\n        dependencyMap: options.dependencyMap ?? {},\n        getImportFrom: getImportFromFactory(options.linkOverrides ?? {}, customAccountData, customInstructionData),\n        linkables,\n        nameApi: getNameApi({ ...DEFAULT_NAME_TRANSFORMERS, ...options.nameTransformers }),\n        nonScalarEnums: (options.nonScalarEnums ?? []).map(camelCase),\n        renderParentInstructions: options.renderParentInstructions ?? false,\n        useGranularImports: options.useGranularImports ?? false,\n    };\n\n    const typeManifestVisitor = getTypeManifestVisitor({ ...renderScopeWithTypeManifestVisitor, stack });\n    const renderScope: RenderScope = { ...renderScopeWithTypeManifestVisitor, typeManifestVisitor };\n\n    const internalNodes = (options.internalNodes ?? []).map(camelCase);\n    const resolvedInstructionInputVisitor = getResolvedInstructionInputsVisitor();\n    const byteSizeVisitor = getByteSizeVisitor(linkables, { stack });\n    const asPage = <TFragment extends Fragment | undefined>(\n        fragment: TFragment,\n        dependencyMap: Record<string, string> = {},\n    ): TFragment => {\n        if (!fragment) return undefined as TFragment;\n        return getPageFragment(fragment, {\n            ...renderScope,\n            dependencyMap: { ...renderScope.dependencyMap, ...dependencyMap },\n        }) as TFragment;\n    };\n\n    return pipe(\n        staticVisitor(() => createRenderMap(), {\n            keys: ['rootNode', 'programNode', 'pdaNode', 'accountNode', 'definedTypeNode', 'instructionNode'],\n        }),\n        v =>\n            extendVisitor(v, {\n                visitAccount(node) {\n                    return createRenderMap(\n                        `accounts/${camelCase(node.name)}.ts`,\n                        asPage(\n                            getAccountPageFragment({\n                                ...renderScope,\n                                accountPath: stack.getPath('accountNode'),\n                                size: visit(node, byteSizeVisitor),\n                            }),\n                        ),\n                    );\n                },\n\n                visitDefinedType(node) {\n                    return createRenderMap(\n                        `types/${camelCase(node.name)}.ts`,\n                        asPage(getTypePageFragment({ ...renderScope, node, size: visit(node, byteSizeVisitor) }), {\n                            generatedTypes: '.',\n                        }),\n                    );\n                },\n\n                visitInstruction(node) {\n                    return createRenderMap(\n                        `instructions/${camelCase(node.name)}.ts`,\n                        asPage(\n                            getInstructionPageFragment({\n                                ...renderScope,\n                                instructionPath: stack.getPath('instructionNode'),\n                                resolvedInputs: visit(node, resolvedInstructionInputVisitor),\n                                size: visit(node, byteSizeVisitor),\n                            }),\n                        ),\n                    );\n                },\n\n                visitPda(node) {\n                    return createRenderMap(\n                        `pdas/${camelCase(node.name)}.ts`,\n                        asPage(getPdaPageFragment({ ...renderScope, pdaPath: stack.getPath('pdaNode') })),\n                    );\n                },\n\n                visitProgram(node, { self }) {\n                    const customDataDefinedType = [\n                        ...getDefinedTypeNodesToExtract(node.accounts, customAccountData),\n                        ...getDefinedTypeNodesToExtract(node.instructions, customInstructionData),\n                    ];\n                    const scope = { ...renderScope, programNode: node };\n\n                    return mergeRenderMaps([\n                        createRenderMap({\n                            [`programs/${camelCase(node.name)}.ts`]: asPage(getProgramPageFragment(scope)),\n                            [`errors/${camelCase(node.name)}.ts`]:\n                                node.errors.length > 0 ? asPage(getErrorPageFragment(scope)) : undefined,\n                        }),\n                        ...node.pdas.map(p => visit(p, self)),\n                        ...node.accounts.map(a => visit(a, self)),\n                        ...node.definedTypes.map(t => visit(t, self)),\n                        ...customDataDefinedType.map(t => visit(t, self)),\n                        ...getAllInstructionsWithSubs(node, { leavesOnly: !renderScope.renderParentInstructions }).map(\n                            i => visit(i, self),\n                        ),\n                    ]);\n                },\n\n                visitRoot(node, { self }) {\n                    const isNotInternal = (n: { name: CamelCaseString }) => !internalNodes.includes(n.name);\n                    const programsToExport = getAllPrograms(node).filter(isNotInternal);\n                    const programsWithErrorsToExport = programsToExport.filter(p => p.errors.length > 0);\n                    const pdasToExport = getAllPdas(node);\n                    const accountsToExport = getAllAccounts(node).filter(isNotInternal);\n                    const instructionsToExport = getAllInstructionsWithSubs(node, {\n                        leavesOnly: !renderScope.renderParentInstructions,\n                    }).filter(isNotInternal);\n                    const definedTypesToExport = getAllDefinedTypes(node).filter(isNotInternal);\n                    const hasAnythingToExport =\n                        programsToExport.length > 0 ||\n                        accountsToExport.length > 0 ||\n                        instructionsToExport.length > 0 ||\n                        definedTypesToExport.length > 0;\n\n                    const scope = {\n                        ...renderScope,\n                        accountsToExport,\n                        definedTypesToExport,\n                        instructionsToExport,\n                        pdasToExport,\n                        programsToExport,\n                    };\n\n                    return mergeRenderMaps([\n                        createRenderMap({\n                            ['accounts/index.ts']: asPage(getIndexPageFragment(accountsToExport)),\n                            ['errors/index.ts']: asPage(getIndexPageFragment(programsWithErrorsToExport)),\n                            ['index.ts']: asPage(getRootIndexPageFragment(scope)),\n                            ['instructions/index.ts']: asPage(getIndexPageFragment(instructionsToExport)),\n                            ['pdas/index.ts']: asPage(getIndexPageFragment(pdasToExport)),\n                            ['programs/index.ts']: asPage(getIndexPageFragment(programsToExport)),\n                            ['shared/index.ts']: hasAnythingToExport ? asPage(getSharedPageFragment()) : undefined,\n                            ['types/index.ts']: asPage(getIndexPageFragment(definedTypesToExport)),\n                        }),\n                        ...getAllPrograms(node).map(p => visit(p, self)),\n                    ]);\n                },\n            }),\n        v => recordNodeStackVisitor(v, stack),\n        v => recordLinkablesOnFirstVisitVisitor(v, linkables),\n    );\n}\n","import { AccountNode } from '@codama/nodes';\nimport { getLastNodeFromPath, NodePath, pipe } from '@codama/visitors-core';\n\nimport { addFragmentImports, Fragment, fragment, RenderScope, TypeManifest } from '../utils';\n\nexport function getAccountFetchHelpersFragment(\n    scope: Pick<RenderScope, 'customAccountData' | 'nameApi'> & {\n        accountPath: NodePath<AccountNode>;\n        typeManifest: TypeManifest;\n    },\n): Fragment {\n    const { accountPath, typeManifest, nameApi, customAccountData } = scope;\n    const accountNode = getLastNodeFromPath(accountPath);\n    const decodeFunction = nameApi.accountDecodeFunction(accountNode.name);\n    const fetchAllFunction = nameApi.accountFetchAllFunction(accountNode.name);\n    const fetchAllMaybeFunction = nameApi.accountFetchAllMaybeFunction(accountNode.name);\n    const fetchFunction = nameApi.accountFetchFunction(accountNode.name);\n    const fetchMaybeFunction = nameApi.accountFetchMaybeFunction(accountNode.name);\n\n    const hasCustomData = customAccountData.has(accountNode.name);\n    const accountType = hasCustomData ? typeManifest.strictType : nameApi.dataType(accountNode.name);\n    const decoderFunction = hasCustomData ? typeManifest.decoder : `${nameApi.decoderFunction(accountNode.name)}()`;\n\n    return pipe(\n        fragment`export function ${decodeFunction}<TAddress extends string = string>(encodedAccount: EncodedAccount<TAddress>): Account<${accountType}, TAddress>;\nexport function ${decodeFunction}<TAddress extends string = string>(encodedAccount: MaybeEncodedAccount<TAddress>): MaybeAccount<${accountType}, TAddress>;\nexport function ${decodeFunction}<TAddress extends string = string>(encodedAccount: EncodedAccount<TAddress> | MaybeEncodedAccount<TAddress>): Account<${accountType}, TAddress> | MaybeAccount<${accountType}, TAddress> {\n  return decodeAccount(encodedAccount as MaybeEncodedAccount<TAddress>, ${decoderFunction});\n}\n\nexport async function ${fetchFunction}<TAddress extends string = string>(\n  rpc: Parameters<typeof fetchEncodedAccount>[0],\n  address: Address<TAddress>,\n  config?: FetchAccountConfig,\n): Promise<Account<${accountType}, TAddress>> {\n  const maybeAccount = await ${fetchMaybeFunction}(rpc, address, config);\n  assertAccountExists(maybeAccount);\n  return maybeAccount;\n}\n\nexport async function ${fetchMaybeFunction}<TAddress extends string = string>(\n  rpc: Parameters<typeof fetchEncodedAccount>[0],\n  address: Address<TAddress>,\n  config?: FetchAccountConfig,\n): Promise<MaybeAccount<${accountType}, TAddress>> {\n  const maybeAccount = await fetchEncodedAccount(rpc, address, config);\n  return ${decodeFunction}(maybeAccount);\n}\n\nexport async function ${fetchAllFunction}(\n  rpc: Parameters<typeof fetchEncodedAccounts>[0],\n  addresses: Array<Address>,\n  config?: FetchAccountsConfig,\n): Promise<Account<${accountType}>[]> {\n  const maybeAccounts = await ${fetchAllMaybeFunction}(rpc, addresses, config);\n  assertAccountsExist(maybeAccounts);\n  return maybeAccounts;\n}\n\nexport async function ${fetchAllMaybeFunction}(\n  rpc: Parameters<typeof fetchEncodedAccounts>[0],\n  addresses: Array<Address>,\n  config?: FetchAccountsConfig,\n): Promise<MaybeAccount<${accountType}>[]> {\n  const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config);\n  return maybeAccounts.map((maybeAccount) => ${decodeFunction}(maybeAccount));\n}`,\n        f => addFragmentImports(f, 'solanaAddresses', ['type Address']),\n        f =>\n            addFragmentImports(f, 'solanaAccounts', [\n                'type Account',\n                'assertAccountExists',\n                'assertAccountsExist',\n                'decodeAccount',\n                'type EncodedAccount',\n                'fetchEncodedAccount',\n                'fetchEncodedAccounts',\n                'type FetchAccountConfig',\n                'type FetchAccountsConfig',\n                'type MaybeAccount',\n                'type MaybeEncodedAccount',\n            ]),\n    );\n}\n","import {\n    AccountValueNode,\n    accountValueNode,\n    ArgumentValueNode,\n    argumentValueNode,\n    CamelCaseString,\n    InstructionAccountNode,\n    InstructionArgumentNode,\n    InstructionInputValueNode,\n    InstructionNode,\n    isNode,\n} from '@codama/nodes';\nimport { deduplicateInstructionDependencies, ResolvedInstructionInput } from '@codama/visitors-core';\n\nexport function hasAsyncFunction(\n    instructionNode: InstructionNode,\n    resolvedInputs: ResolvedInstructionInput[],\n    asyncResolvers: string[],\n): boolean {\n    const hasByteDeltasAsync = (instructionNode.byteDeltas ?? []).some(\n        ({ value }) => isNode(value, 'resolverValueNode') && asyncResolvers.includes(value.name),\n    );\n    const hasRemainingAccountsAsync = (instructionNode.remainingAccounts ?? []).some(\n        ({ value }) => isNode(value, 'resolverValueNode') && asyncResolvers.includes(value.name),\n    );\n\n    return hasAsyncDefaultValues(resolvedInputs, asyncResolvers) || hasByteDeltasAsync || hasRemainingAccountsAsync;\n}\n\nexport function hasAsyncDefaultValues(resolvedInputs: ResolvedInstructionInput[], asyncResolvers: string[]): boolean {\n    return resolvedInputs.some(\n        input => !!input.defaultValue && isAsyncDefaultValue(input.defaultValue, asyncResolvers),\n    );\n}\n\nexport function isAsyncDefaultValue(defaultValue: InstructionInputValueNode, asyncResolvers: string[]): boolean {\n    switch (defaultValue.kind) {\n        case 'pdaValueNode':\n            return true;\n        case 'resolverValueNode':\n            return asyncResolvers.includes(defaultValue.name);\n        case 'conditionalValueNode':\n            return (\n                isAsyncDefaultValue(defaultValue.condition, asyncResolvers) ||\n                (defaultValue.ifFalse == null ? false : isAsyncDefaultValue(defaultValue.ifFalse, asyncResolvers)) ||\n                (defaultValue.ifTrue == null ? false : isAsyncDefaultValue(defaultValue.ifTrue, asyncResolvers))\n            );\n        default:\n            return false;\n    }\n}\n\nexport function getInstructionDependencies(\n    input: InstructionAccountNode | InstructionArgumentNode | InstructionNode,\n    asyncResolvers: string[],\n    useAsync: boolean,\n): (AccountValueNode | ArgumentValueNode)[] {\n    if (isNode(input, 'instructionNode')) {\n        return deduplicateInstructionDependencies([\n            ...input.accounts.flatMap(x => getInstructionDependencies(x, asyncResolvers, useAsync)),\n            ...input.arguments.flatMap(x => getInstructionDependencies(x, asyncResolvers, useAsync)),\n            ...(input.extraArguments ?? []).flatMap(x => getInstructionDependencies(x, asyncResolvers, useAsync)),\n        ]);\n    }\n\n    if (!input.defaultValue) return [];\n\n    const getNestedDependencies = (\n        defaultValue: InstructionInputValueNode | undefined,\n    ): (AccountValueNode | ArgumentValueNode)[] => {\n        if (!defaultValue) return [];\n        return getInstructionDependencies({ ...input, defaultValue }, asyncResolvers, useAsync);\n    };\n\n    if (isNode(input.defaultValue, ['accountValueNode', 'accountBumpValueNode'])) {\n        return [accountValueNode(input.defaultValue.name)];\n    }\n\n    if (isNode(input.defaultValue, ['argumentValueNode'])) {\n        return [argumentValueNode(input.defaultValue.name)];\n    }\n\n    if (isNode(input.defaultValue, 'pdaValueNode')) {\n        const dependencies = new Map<CamelCaseString, AccountValueNode | ArgumentValueNode>();\n        input.defaultValue.seeds.forEach(seed => {\n            if (isNode(seed.value, ['accountValueNode', 'argumentValueNode'])) {\n                dependencies.set(seed.value.name, { ...seed.value });\n            }\n        });\n        return [...dependencies.values()];\n    }\n\n    if (isNode(input.defaultValue, 'resolverValueNode')) {\n        const isSynchronousResolver = !asyncResolvers.includes(input.defaultValue.name);\n        if (useAsync || isSynchronousResolver) {\n            return input.defaultValue.dependsOn ?? [];\n        }\n    }\n\n    if (isNode(input.defaultValue, 'conditionalValueNode')) {\n        return deduplicateInstructionDependencies([\n            ...getNestedDependencies(input.defaultValue.condition),\n            ...getNestedDependencies(input.defaultValue.ifTrue),\n            ...getNestedDependencies(input.defaultValue.ifFalse),\n        ]);\n    }\n\n    return [];\n}\n","import { BytesValueNode } from '@codama/nodes';\nimport { getBase16Encoder, getBase58Encoder, getBase64Encoder, getUtf8Encoder } from '@solana/codecs-strings';\n\nexport function getBytesFromBytesValueNode(node: BytesValueNode): Uint8Array {\n    switch (node.encoding) {\n        case 'utf8':\n            return getUtf8Encoder().encode(node.data) as Uint8Array;\n        case 'base16':\n            return getBase16Encoder().encode(node.data) as Uint8Array;\n        case 'base58':\n            return getBase58Encoder().encode(node.data) as Uint8Array;\n        case 'base64':\n        default:\n            return getBase64Encoder().encode(node.data) as Uint8Array;\n    }\n}\n","import {\n    AccountNode,\n    camelCase,\n    CamelCaseString,\n    DefinedTypeLinkNode,\n    definedTypeLinkNode,\n    DefinedTypeNode,\n    definedTypeNode,\n    InstructionNode,\n    isNode,\n    structTypeNodeFromInstructionArgumentNodes,\n} from '@codama/nodes';\n\nexport type CustomDataOptions =\n    | string\n    | {\n          extract?: boolean;\n          extractAs?: string;\n          importAs?: string;\n          importFrom?: string;\n          name: string;\n      };\n\nexport type ParsedCustomDataOptions = Map<\n    CamelCaseString,\n    {\n        extract: boolean;\n        extractAs: CamelCaseString;\n        importAs: CamelCaseString;\n        importFrom: string;\n        linkNode: DefinedTypeLinkNode;\n    }\n>;\n\nexport const parseCustomDataOptions = (\n    customDataOptions: CustomDataOptions[],\n    defaultSuffix: string,\n): ParsedCustomDataOptions =>\n    new Map(\n        customDataOptions.map(o => {\n            const options = typeof o === 'string' ? { name: o } : o;\n            const importAs = camelCase(options.importAs ?? `${options.name}${defaultSuffix}`);\n            const importFrom = options.importFrom ?? 'hooked';\n            return [\n                camelCase(options.name),\n                {\n                    extract: options.extract ?? false,\n                    extractAs: options.extractAs ? camelCase(options.extractAs) : importAs,\n                    importAs,\n                    importFrom,\n                    linkNode: definedTypeLinkNode(importAs),\n                },\n            ];\n        }),\n    );\n\nexport const getDefinedTypeNodesToExtract = (\n    nodes: AccountNode[] | InstructionNode[],\n    parsedCustomDataOptions: ParsedCustomDataOptions,\n): DefinedTypeNode[] =>\n    nodes.flatMap(node => {\n        const options = parsedCustomDataOptions.get(node.name);\n        if (!options || !options.extract) return [];\n\n        if (isNode(node, 'accountNode')) {\n            return [definedTypeNode({ name: options.extractAs, type: { ...node.data } })];\n        }\n\n        return [\n            definedTypeNode({\n                name: options.extractAs,\n                type: structTypeNodeFromInstructionArgumentNodes(node.arguments),\n            }),\n        ];\n    });\n","import { CODAMA_ERROR__UNEXPECTED_NODE_KIND, CodamaError } from '@codama/errors';\nimport {\n    AccountLinkNode,\n    DefinedTypeLinkNode,\n    InstructionLinkNode,\n    PdaLinkNode,\n    ProgramLinkNode,\n    ResolverValueNode,\n} from '@codama/nodes';\n\nimport { ParsedCustomDataOptions } from './customData';\n\nexport type LinkOverrides = {\n    accounts?: Record<string, string>;\n    definedTypes?: Record<string, string>;\n    instructions?: Record<string, string>;\n    pdas?: Record<string, string>;\n    programs?: Record<string, string>;\n    resolvers?: Record<string, string>;\n};\n\ntype OverridableNodes =\n    | AccountLinkNode\n    | DefinedTypeLinkNode\n    | InstructionLinkNode\n    | PdaLinkNode\n    | ProgramLinkNode\n    | ResolverValueNode;\n\nexport type GetImportFromFunction = (node: OverridableNodes, fallback?: string) => string;\n\nexport function getImportFromFactory(\n    overrides: LinkOverrides,\n    customAccountData: ParsedCustomDataOptions,\n    customInstructionData: ParsedCustomDataOptions,\n): GetImportFromFunction {\n    const customDataOverrides = Object.fromEntries(\n        [...customAccountData.values(), ...customInstructionData.values()].map(({ importFrom, importAs }) => [\n            importAs,\n            importFrom,\n        ]),\n    );\n    const linkOverrides = {\n        accounts: overrides.accounts ?? {},\n        definedTypes: { ...customDataOverrides, ...overrides.definedTypes },\n        instructions: overrides.instructions ?? {},\n        pdas: overrides.pdas ?? {},\n        programs: overrides.programs ?? {},\n        resolvers: overrides.resolvers ?? {},\n    };\n\n    return (node: OverridableNodes) => {\n        const kind = node.kind;\n        switch (kind) {\n            case 'accountLinkNode':\n                return linkOverrides.accounts[node.name] ?? 'generatedAccounts';\n            case 'definedTypeLinkNode':\n                return linkOverrides.definedTypes[node.name] ?? 'generatedTypes';\n            case 'instructionLinkNode':\n                return linkOverrides.instructions[node.name] ?? 'generatedInstructions';\n            case 'pdaLinkNode':\n                return linkOverrides.pdas[node.name] ?? 'generatedPdas';\n            case 'programLinkNode':\n                return linkOverrides.programs[node.name] ?? 'generatedPrograms';\n            case 'resolverValueNode':\n                return linkOverrides.resolvers[node.name] ?? 'hooked';\n            default:\n                throw new CodamaError(CODAMA_ERROR__UNEXPECTED_NODE_KIND, {\n                    expectedKinds: [\n                        'AccountLinkNode',\n                        'DefinedTypeLinkNode',\n                        'InstructionLinkNode',\n                        'PdaLinkNode',\n                        'ProgramLinkNode',\n                        'resolverValueNode',\n                    ],\n                    kind: kind satisfies never,\n                    node,\n                });\n        }\n    };\n}\n","import { AccountNode, resolveNestedTypeNode } from '@codama/nodes';\nimport { findProgramNodeFromPath, getLastNodeFromPath, NodePath, visit } from '@codama/visitors-core';\n\nimport { Fragment, mergeFragments, RenderScope } from '../utils';\nimport { getAccountFetchHelpersFragment } from './accountFetchHelpers';\nimport { getAccountPdaHelpersFragment } from './accountPdaHelpers';\nimport { getAccountSizeHelpersFragment } from './accountSizeHelpers';\nimport { getAccountTypeFragment } from './accountType';\nimport { getDiscriminatorConstantsFragment } from './discriminatorConstants';\n\nexport function getAccountPageFragment(\n    scope: Pick<RenderScope, 'customAccountData' | 'linkables' | 'nameApi' | 'typeManifestVisitor'> & {\n        accountPath: NodePath<AccountNode>;\n        size: number | null;\n    },\n): Fragment {\n    const node = getLastNodeFromPath(scope.accountPath);\n    if (!findProgramNodeFromPath(scope.accountPath)) {\n        throw new Error('Account must be visited inside a program.');\n    }\n\n    const typeManifest = visit(node, scope.typeManifestVisitor);\n    const fields = resolveNestedTypeNode(node.data).fields;\n    return mergeFragments(\n        [\n            getDiscriminatorConstantsFragment({\n                ...scope,\n                discriminatorNodes: node.discriminators ?? [],\n                fields,\n                prefix: node.name,\n            }),\n            getAccountTypeFragment({ ...scope, typeManifest }),\n            getAccountFetchHelpersFragment({ ...scope, typeManifest }),\n            getAccountSizeHelpersFragment(scope),\n            getAccountPdaHelpersFragment({ ...scope, typeManifest }),\n        ],\n        cs => cs.join('\\n\\n'),\n    );\n}\n","import { AccountNode, isNodeFilter } from '@codama/nodes';\nimport { getLastNodeFromPath, NodePath, pipe } from '@codama/visitors-core';\n\nimport { addFragmentImports, Fragment, fragment, RenderScope, TypeManifest } from '../utils';\n\nexport function getAccountPdaHelpersFragment(\n    scope: Pick<RenderScope, 'customAccountData' | 'linkables' | 'nameApi'> & {\n        accountPath: NodePath<AccountNode>;\n        typeManifest: TypeManifest;\n    },\n): Fragment | undefined {\n    const { accountPath, nameApi, linkables, customAccountData, typeManifest } = scope;\n    const accountNode = getLastNodeFromPath(accountPath);\n    const pdaNode = accountNode.pda ? linkables.get([...accountPath, accountNode.pda]) : undefined;\n    if (!pdaNode) return;\n\n    const accountType = customAccountData.has(accountNode.name)\n        ? typeManifest.strictType\n        : nameApi.dataType(accountNode.name);\n\n    // Here we cannot use the `getImportFrom` function because\n    // we need to know the seeds of the PDA in order to know\n    // if we need to render a `seeds` argument or not.\n    const importFrom = 'generatedPdas';\n    const pdaSeedsType = nameApi.pdaSeedsType(pdaNode.name);\n    const findPdaFunction = nameApi.pdaFindFunction(pdaNode.name);\n    const hasVariableSeeds = pdaNode.seeds.filter(isNodeFilter('variablePdaSeedNode')).length > 0;\n\n    const fetchFromSeedsFunction = nameApi.accountFetchFromSeedsFunction(accountNode.name);\n    const fetchMaybeFromSeedsFunction = nameApi.accountFetchMaybeFromSeedsFunction(accountNode.name);\n    const fetchMaybeFunction = nameApi.accountFetchMaybeFunction(accountNode.name);\n\n    return pipe(\n        fragment`export async function ${fetchFromSeedsFunction}(\n  rpc: Parameters<typeof fetchEncodedAccount>[0],\n  ${hasVariableSeeds ? `seeds: ${pdaSeedsType},` : ''}\n  config: FetchAccountConfig & { programAddress?: Address } = {},\n): Promise<Account<${accountType}>> {\n  const maybeAccount = await ${fetchMaybeFromSeedsFunction}(rpc, ${hasVariableSeeds ? 'seeds, ' : ''}config);\n  assertAccountExists(maybeAccount);\n  return maybeAccount;\n}\n\nexport async function ${fetchMaybeFromSeedsFunction}(\n  rpc: Parameters<typeof fetchEncodedAccount>[0],\n  ${hasVariableSeeds ? `seeds: ${pdaSeedsType},` : ''}\n  config: FetchAccountConfig & { programAddress?: Address } = {},\n): Promise<MaybeAccount<${accountType}>> {\n  const { programAddress, ...fetchConfig } = config;\n  const [address] = await ${findPdaFunction}(${hasVariableSeeds ? 'seeds, ' : ''}{ programAddress });\n  return await ${fetchMaybeFunction}(rpc, address, fetchConfig);\n}`,\n        f => addFragmentImports(f, importFrom, hasVariableSeeds ? [pdaSeedsType, findPdaFunction] : [findPdaFunction]),\n        f => addFragmentImports(f, 'solanaAddresses', ['type Address']),\n        f =>\n            addFragmentImports(f, 'solanaAccounts', [\n                'type Account',\n                'assertAccountExists',\n                'type FetchAccountConfig',\n                'type MaybeAccount',\n            ]),\n    );\n}\n","import { AccountNode } from '@codama/nodes';\nimport { getLastNodeFromPath, NodePath } from '@codama/visitors-core';\n\nimport { Fragment, fragment, RenderScope } from '../utils';\n\nexport function getAccountSizeHelpersFragment(\n    scope: Pick<RenderScope, 'nameApi'> & { accountPath: NodePath<AccountNode> },\n): Fragment | undefined {\n    const { accountPath, nameApi } = scope;\n    const accountNode = getLastNodeFromPath(accountPath);\n    if (accountNode.size == null) return;\n\n    const getSizeFunction = nameApi.accountGetSizeFunction(accountNode.name);\n    return fragment`export function ${getSizeFunction}(): number {\n  return ${accountNode.size};\n}`;\n}\n","import { AccountNode, resolveNestedTypeNode } from '@codama/nodes';\nimport { getLastNodeFromPath, NodePath } from '@codama/visitors-core';\n\nimport { Fragment, RenderScope, TypeManifest } from '../utils';\nimport { getTypeWithCodecFragment } from './typeWithCodec';\n\nexport function getAccountTypeFragment(\n    scope: Pick<RenderScope, 'customAccountData' | 'nameApi'> & {\n        accountPath: NodePath<AccountNode>;\n        size: number | null;\n        typeManifest: TypeManifest;\n    },\n): Fragment | undefined {\n    const { accountPath, typeManifest, nameApi, customAccountData } = scope;\n    const accountNode = getLastNodeFromPath(accountPath);\n    if (customAccountData.has(accountNode.name)) return;\n\n    return getTypeWithCodecFragment({\n        manifest: typeManifest,\n        name: accountNode.name,\n        nameApi,\n        node: resolveNestedTypeNode(accountNode.data),\n        size: scope.size,\n    });\n}\n","import { Fragment, fragment, getDocblockFragment, RenderScope, TypeManifest } from '../utils';\n\nexport function getTypeFragment(\n    scope: Pick<RenderScope, 'nameApi'> & {\n        docs?: string[];\n        manifest: TypeManifest;\n        name: string;\n    },\n): Fragment {\n    const { name, manifest, nameApi, docs = [] } = scope;\n\n    const docblock = getDocblockFragment(docs, true);\n    const strictName = nameApi.dataType(name);\n    const looseName = nameApi.dataArgsType(name);\n    const aliasedLooseName = `export type ${looseName} = ${strictName};`;\n\n    if (manifest.isEnum) {\n        return fragment`${docblock}export enum ${strictName} ${manifest.strictType};\\n\\n${aliasedLooseName}`;\n    }\n\n    const looseExport =\n        manifest.strictType.content === manifest.looseType.content\n            ? aliasedLooseName\n            : fragment`export type ${looseName} = ${manifest.looseType};`;\n    return fragment`${docblock}export type ${strictName} = ${manifest.strictType};\\n\\n${looseExport}`;\n}\n","import { isDataEnum, isNode, TypeNode } from '@codama/nodes';\n\nimport { Fragment, fragment, getDocblockFragment, RenderScope, TypeManifest, use } from '../utils';\n\nexport function getTypeDecoderFragment(\n    scope: Pick<RenderScope, 'nameApi'> & {\n        docs?: string[];\n        manifest: Pick<TypeManifest, 'decoder'>;\n        name: string;\n        node: TypeNode;\n        size: number | null;\n    },\n): Fragment {\n    const { name, node, manifest, nameApi, docs = [] } = scope;\n    const decoderFunction = nameApi.decoderFunction(name);\n    const strictName = nameApi.dataType(name);\n\n    const docblock = getDocblockFragment(docs, true);\n    const decoderType = use(\n        typeof scope.size === 'number' ? 'type FixedSizeDecoder' : 'type Decoder',\n        'solanaCodecsCore',\n    );\n    const useTypeCast = isNode(node, 'enumTypeNode') && isDataEnum(node) && typeof scope.size === 'number';\n\n    const typeCast = useTypeCast ? fragment` as ${decoderType}<${strictName}>` : '';\n    return fragment`${docblock}export function ${decoderFunction}(): ${decoderType}<${strictName}> {\n    return ${manifest.decoder}${typeCast};\n}`;\n}\n","import { isDataEnum, isNode, TypeNode } from '@codama/nodes';\n\nimport { Fragment, fragment, getDocblockFragment, RenderScope, TypeManifest, use } from '../utils';\n\nexport function getTypeEncoderFragment(\n    scope: Pick<RenderScope, 'nameApi'> & {\n        docs?: string[];\n        manifest: Pick<TypeManifest, 'encoder'>;\n        name: string;\n        node: TypeNode;\n        size: number | null;\n    },\n): Fragment {\n    const { name, node, manifest, nameApi, docs = [] } = scope;\n    const encoderFunction = nameApi.encoderFunction(name);\n    const looseName = nameApi.dataArgsType(name);\n\n    const docblock = getDocblockFragment(docs, true);\n    const encoderType = use(\n        typeof scope.size === 'number' ? 'type FixedSizeEncoder' : 'type Encoder',\n        'solanaCodecsCore',\n    );\n    const useTypeCast = isNode(node, 'enumTypeNode') && isDataEnum(node) && typeof scope.size === 'number';\n\n    const typeCast = useTypeCast ? fragment` as ${encoderType}<${looseName}>` : '';\n    return fragment`${docblock}export function ${encoderFunction}(): ${encoderType}<${looseName}> {\n    return ${manifest.encoder}${typeCast};\n}`;\n}\n","import type { TypeNode } from '@codama/nodes';\n\nimport { Fragment, fragment, getDocblockFragment, mergeFragments, RenderScope, TypeManifest, use } from '../utils';\nimport { getTypeDecoderFragment } from './typeDecoder';\nimport { getTypeEncoderFragment } from './typeEncoder';\n\nexport function getTypeCodecFragment(\n    scope: Pick<RenderScope, 'nameApi'> & {\n        codecDocs?: string[];\n        decoderDocs?: string[];\n        encoderDocs?: string[];\n        manifest: Pick<TypeManifest, 'decoder' | 'encoder'>;\n        name: string;\n        node: TypeNode;\n        size: number | null;\n    },\n): Fragment {\n    const { codecDocs = [], name, nameApi } = scope;\n    const codecFunction = nameApi.codecFunction(name);\n    const decoderFunction = nameApi.decoderFunction(name);\n    const encoderFunction = nameApi.encoderFunction(name);\n    const looseName = nameApi.dataArgsType(name);\n    const strictName = nameApi.dataType(name);\n\n    const docblock = getDocblockFragment(codecDocs, true);\n    const codecType = use(typeof scope.size === 'number' ? 'type FixedSizeCodec' : 'type Codec', 'solanaCodecsCore');\n\n    return mergeFragments(\n        [\n            getTypeEncoderFragment({ ...scope, docs: scope.encoderDocs }),\n            getTypeDecoderFragment({ ...scope, docs: scope.decoderDocs }),\n            fragment`${docblock}export function ${codecFunction}(): ${codecType}<${looseName}, ${strictName}> {\n    return ${use('combineCodec', 'solanaCodecsCore')}(${encoderFunction}(), ${decoderFunction}());\n}`,\n        ],\n        renders => renders.join('\\n\\n'),\n    );\n}\n","import type { TypeNode } from '@codama/nodes';\n\nimport { Fragment, mergeFragments, RenderScope, TypeManifest } from '../utils';\nimport { getTypeFragment } from './type';\nimport { getTypeCodecFragment } from './typeCodec';\n\nexport function getTypeWithCodecFragment(\n    scope: Pick<RenderScope, 'nameApi'> & {\n        codecDocs?: string[];\n        decoderDocs?: string[];\n        encoderDocs?: string[];\n        manifest: TypeManifest;\n        name: string;\n        node: TypeNode;\n        size: number | null;\n        typeDocs?: string[];\n    },\n): Fragment {\n    return mergeFragments([getTypeFragment({ ...scope, docs: scope.typeDocs }), getTypeCodecFragment(scope)], renders =>\n        renders.join('\\n\\n'),\n    );\n}\n","import {\n    camelCase,\n    ConstantDiscriminatorNode,\n    DiscriminatorNode,\n    FieldDiscriminatorNode,\n    InstructionArgumentNode,\n    isNode,\n    isNodeFilter,\n    StructFieldTypeNode,\n    VALUE_NODES,\n} from '@codama/nodes';\nimport { visit } from '@codama/visitors-core';\n\nimport { Fragment, fragment, mergeFragments, RenderScope } from '../utils';\n\nexport function getDiscriminatorConstantsFragment(\n    scope: Pick<RenderScope, 'nameApi' | 'typeManifestVisitor'> & {\n        discriminatorNodes: DiscriminatorNode[];\n        fields: InstructionArgumentNode[] | StructFieldTypeNode[];\n        prefix: string;\n    },\n): Fragment {\n    const fragments = scope.discriminatorNodes\n        .map(node => getDiscriminatorConstantFragment(node, scope))\n        .filter(Boolean) as Fragment[];\n\n    return mergeFragments(fragments, c => c.join('\\n\\n'));\n}\n\nexport function getDiscriminatorConstantFragment(\n    discriminatorNode: DiscriminatorNode,\n    scope: Pick<RenderScope, 'nameApi' | 'typeManifestVisitor'> & {\n        discriminatorNodes: DiscriminatorNode[];\n        fields: InstructionArgumentNode[] | StructFieldTypeNode[];\n        prefix: string;\n    },\n): Fragment | null {\n    switch (discriminatorNode.kind) {\n        case 'constantDiscriminatorNode':\n            return getConstantDiscriminatorConstantFragment(discriminatorNode, scope);\n        case 'fieldDiscriminatorNode':\n            return getFieldDiscriminatorConstantFragment(discriminatorNode, scope);\n        default:\n            return null;\n    }\n}\n\nexport function getConstantDiscriminatorConstantFragment(\n    discriminatorNode: ConstantDiscriminatorNode,\n    scope: Pick<RenderScope, 'nameApi' | 'typeManifestVisitor'> & {\n        discriminatorNodes: DiscriminatorNode[];\n        prefix: string;\n    },\n): Fragment | null {\n    const { discriminatorNodes, typeManifestVisitor, prefix } = scope;\n\n    const index = discriminatorNodes.filter(isNodeFilter('constantDiscriminatorNode')).indexOf(discriminatorNode);\n    const suffix = index <= 0 ? '' : `_${index + 1}`;\n\n    const name = camelCase(`${prefix}_discriminator${suffix}`);\n    const encoder = visit(discriminatorNode.constant.type, typeManifestVisitor).encoder;\n    const value = visit(discriminatorNode.constant.value, typeManifestVisitor).value;\n    return getConstantFragment({ ...scope, encoder, name, value });\n}\n\nexport function getFieldDiscriminatorConstantFragment(\n    discriminatorNode: FieldDiscriminatorNode,\n    scope: Pick<RenderScope, 'nameApi' | 'typeManifestVisitor'> & {\n        fields: InstructionArgumentNode[] | StructFieldTypeNode[];\n        prefix: string;\n    },\n): Fragment | null {\n    const { fields, prefix, typeManifestVisitor } = scope;\n\n    const field = fields.find(f => f.name === discriminatorNode.name);\n    if (!field || !field.defaultValue || !isNode(field.defaultValue, VALUE_NODES)) {\n        return null;\n    }\n\n    const name = camelCase(`${prefix}_${discriminatorNode.name}`);\n    const encoder = visit(field.type, typeManifestVisitor).encoder;\n    const value = visit(field.defaultValue, typeManifestVisitor).value;\n    return getConstantFragment({ ...scope, encoder, name, value });\n}\n\nfunction getConstantFragment(\n    scope: Pick<RenderScope, 'nameApi'> & {\n        encoder: Fragment;\n        name: string;\n        value: Fragment;\n    },\n): Fragment {\n    const { encoder, name, nameApi, value } = scope;\n    const constantName = nameApi.constant(name);\n    const constantFunction = nameApi.constantFunction(name);\n\n    return fragment`export const ${constantName} = ${value};\\n\\nexport function ${constantFunction}() { return ${encoder}.encode(${constantName}); }`;\n}\n","import {\n    type ConstantDiscriminatorNode,\n    constantDiscriminatorNode,\n    constantValueNode,\n    constantValueNodeFromBytes,\n    type DiscriminatorNode,\n    type FieldDiscriminatorNode,\n    isNode,\n    isNodeFilter,\n    type ProgramNode,\n    type SizeDiscriminatorNode,\n    type StructTypeNode,\n} from '@codama/nodes';\nimport { mapFragmentContent } from '@codama/renderers-core';\nimport { pipe, visit } from '@codama/visitors-core';\nimport { getBase64Decoder } from '@solana/codecs-strings';\n\nimport { Fragment, fragment, mergeFragments, RenderScope, use } from '../utils';\n\n/**\n * ```\n * if (data.length === 72) {\n *   return splTokenAccounts.TOKEN;\n * }\n *\n * if (containsBytes(data, getU32Encoder().encode(42), offset)) {\n *   return splTokenAccounts.TOKEN;\n * }\n *\n * if (containsBytes(data, new Uint8Array([1, 2, 3]), offset)) {\n *   return splTokenAccounts.TOKEN;\n * }\n * ```\n */\nexport function getDiscriminatorConditionFragment(\n    scope: Pick<RenderScope, 'nameApi' | 'typeManifestVisitor'> & {\n        dataName: string;\n        discriminators: DiscriminatorNode[];\n        ifTrue: string;\n        programNode: ProgramNode;\n        struct: StructTypeNode;\n    },\n): Fragment {\n    return pipe(\n        mergeFragments(\n            scope.discriminators.flatMap(discriminator => {\n                if (isNode(discriminator, 'sizeDiscriminatorNode')) {\n                    return [getSizeConditionFragment(discriminator, scope)];\n                }\n                if (isNode(discriminator, 'constantDiscriminatorNode')) {\n                    return [getByteConditionFragment(discriminator, scope)];\n                }\n                if (isNode(discriminator, 'fieldDiscriminatorNode')) {\n                    return [getFieldConditionFragment(discriminator, scope)];\n                }\n                return [];\n            }),\n            c => c.join(' && '),\n        ),\n        f => mapFragmentContent(f, c => `if (${c}) { ${scope.ifTrue} }`),\n    );\n}\n\nfunction getSizeConditionFragment(\n    discriminator: SizeDiscriminatorNode,\n    scope: Pick<RenderScope, 'typeManifestVisitor'> & {\n        dataName: string;\n    },\n): Fragment {\n    const { dataName } = scope;\n    return fragment`${dataName}.length === ${discriminator.size}`;\n}\n\nfunction getByteConditionFragment(\n    discriminator: ConstantDiscriminatorNode,\n    scope: Pick<RenderScope, 'typeManifestVisitor'> & {\n        dataName: string;\n    },\n): Fragment {\n    const { dataName, typeManifestVisitor } = scope;\n    const constant = visit(discriminator.constant, typeManifestVisitor).value;\n    return fragment`${use('containsBytes', 'solanaCodecsCore')}(${dataName}, ${constant}, ${discriminator.offset})`;\n}\n\nfunction getFieldConditionFragment(\n    discriminator: FieldDiscriminatorNode,\n    scope: Pick<RenderScope, 'typeManifestVisitor'> & {\n        dataName: string;\n        struct: StructTypeNode;\n    },\n): Fragment {\n    const field = scope.struct.fields.find(f => f.name === discriminator.name);\n    if (!field || !field.defaultValue) {\n        // TODO: Coded error.\n        throw new Error(\n            `Field discriminator \"${discriminator.name}\" does not have a matching argument with default value.`,\n        );\n    }\n\n    // This handles the case where a field uses an u8 array to represent its discriminator.\n    // In this case, we can simplify the generated code by delegating to a constantDiscriminatorNode.\n    if (\n        isNode(field.type, 'arrayTypeNode') &&\n        isNode(field.type.item, 'numberTypeNode') &&\n        field.type.item.format === 'u8' &&\n        isNode(field.type.count, 'fixedCountNode') &&\n        isNode(field.defaultValue, 'arrayValueNode') &&\n        field.defaultValue.items.every(isNodeFilter('numberValueNode'))\n    ) {\n        const base64Bytes = getBase64Decoder().decode(\n            new Uint8Array(field.defaultValue.items.map(node => node.number)),\n        );\n        return getByteConditionFragment(\n            constantDiscriminatorNode(constantValueNodeFromBytes('base64', base64Bytes), discriminator.offset),\n            scope,\n        );\n    }\n\n    return getByteConditionFragment(\n        constantDiscriminatorNode(constantValueNode(field.type, field.defaultValue), discriminator.offset),\n        scope,\n    );\n}\n","import { ProgramNode } from '@codama/nodes';\n\nimport { Fragment, fragment, getDocblockFragment, mergeFragments, RenderScope, use } from '../utils';\n\nexport function getErrorPageFragment(scope: Pick<RenderScope, 'nameApi'> & { programNode: ProgramNode }): Fragment {\n    return mergeFragments(\n        [\n            getConstantsFragment(scope),\n            getConstantUnionTypeFragment(scope),\n            getErrorMessagesFragment(scope),\n            getErrorMessageFunctionFragment(scope),\n            getIsErrorFunctionFragment(scope),\n        ],\n        cs => cs.join('\\n\\n'),\n    );\n}\n\nfunction getConstantsFragment(scope: Pick<RenderScope, 'nameApi'> & { programNode: ProgramNode }): Fragment {\n    const constantPrefix = scope.nameApi.programErrorConstantPrefix(scope.programNode.name);\n    return mergeFragments(\n        [...scope.programNode.errors]\n            .sort((a, b) => a.code - b.code)\n            .map(error => {\n                const docs = getDocblockFragment(error.docs ?? [], true);\n                const name = constantPrefix + scope.nameApi.programErrorConstant(error.name);\n                return fragment`${docs}export const ${name} = 0x${error.code.toString(16)}; // ${error.code}`;\n            }),\n        cs => cs.join('\\n'),\n    );\n}\n\nfunction getConstantUnionTypeFragment(scope: Pick<RenderScope, 'nameApi'> & { programNode: ProgramNode }): Fragment {\n    const constantPrefix = scope.nameApi.programErrorConstantPrefix(scope.programNode.name);\n    const typeName = scope.nameApi.programErrorUnion(scope.programNode.name);\n    const errorTypes = mergeFragments(\n        [...scope.programNode.errors]\n            .sort((a, b) => a.name.localeCompare(b.name))\n            .map(error => fragment`typeof ${constantPrefix + scope.nameApi.programErrorConstant(error.name)}`),\n        cs => cs.join(' | '),\n    );\n\n    return fragment`export type ${typeName} = ${errorTypes};`;\n}\n\nfunction getErrorMessagesFragment(scope: Pick<RenderScope, 'nameApi'> & { programNode: ProgramNode }): Fragment {\n    const mapName = scope.nameApi.programErrorMessagesMap(scope.programNode.name);\n    const errorUnionType = scope.nameApi.programErrorUnion(scope.programNode.name);\n    const constantPrefix = scope.nameApi.programErrorConstantPrefix(scope.programNode.name);\n    const messageEntries = mergeFragments(\n        [...scope.programNode.errors]\n            .sort((a, b) => a.name.localeCompare(b.name))\n            .map(error => {\n                const constantName = constantPrefix + scope.nameApi.programErrorConstant(error.name);\n                const escapedMessage = error.message.replace(/`/g, '\\\\`');\n                return fragment`[${constantName}]: \\`${escapedMessage}\\``;\n            }),\n        cs => cs.join(', '),\n    );\n\n    return fragment`let ${mapName}: Record<${errorUnionType}, string> | undefined;\nif (process.env.NODE_ENV !== 'production') {\n  ${mapName} = { ${messageEntries} };\n}`;\n}\n\nfunction getErrorMessageFunctionFragment(scope: Pick<RenderScope, 'nameApi'> & { programNode: ProgramNode }): Fragment {\n    const functionName = scope.nameApi.programGetErrorMessageFunction(scope.programNode.name);\n    const errorUnionType = scope.nameApi.programErrorUnion(scope.programNode.name);\n    const messageMapName = scope.nameApi.programErrorMessagesMap(scope.programNode.name);\n\n    return fragment`export function ${functionName}(code: ${errorUnionType}): string {\n  if (process.env.NODE_ENV !== 'production') {\n    return (${messageMapName} as Record<${errorUnionType}, string>)[code];\n  }\n\n  return 'Error message not available in production bundles.';\n}`;\n}\n\nfunction getIsErrorFunctionFragment(scope: Pick<RenderScope, 'nameApi'> & { programNode: ProgramNode }): Fragment {\n    const { programNode, nameApi } = scope;\n    const programAddressConstant = use(nameApi.programAddressConstant(programNode.name), 'generatedPrograms');\n    const functionName = nameApi.programIsErrorFunction(programNode.name);\n    const programErrorUnion = nameApi.programErrorUnion(programNode.name);\n\n    return fragment`export function ${functionName}<TProgramErrorCode extends ${programErrorUnion}>(\n    error: unknown,\n    transactionMessage: { instructions: Record<number, { programAddress: ${use('type Address', 'solanaAddresses')} }> },\n    code?: TProgramErrorCode,\n): error is ${use('type SolanaError', 'solanaErrors')}<typeof ${use('type SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM', 'solanaErrors')}> & Readonly<{ context: Readonly<{ code: TProgramErrorCode }> }> {\n  return ${use('isProgramError', 'solanaPrograms')}<TProgramErrorCode>(error, transactionMessage, ${programAddressConstant}, code);\n}`;\n}\n","import { CamelCaseString } from '@codama/nodes';\n\nimport { Fragment, getExportAllFragment, mergeFragments } from '../utils';\n\nexport function getIndexPageFragment(items: { name: CamelCaseString }[]): Fragment | undefined {\n    if (items.length === 0) return;\n\n    const names = items\n        .map(item => item.name)\n        .sort((a, b) => a.localeCompare(b))\n        .map(name => getExportAllFragment(`./${name}`));\n\n    return mergeFragments(names, cs => cs.join('\\n'));\n}\n","import { InstructionAccountNode, pascalCase } from '@codama/nodes';\n\nimport { Fragment, fragment, use } from '../utils';\n\nexport function getInstructionAccountMetaFragment(instructionAccountNode: InstructionAccountNode): Fragment {\n    const typeParam = `TAccount${pascalCase(instructionAccountNode.name)}`;\n\n    // Writable, signer.\n    if (instructionAccountNode.isSigner === true && instructionAccountNode.isWritable) {\n        return fragment`${use('type WritableSignerAccount', 'solanaInstructions')}<${typeParam}> & ${use('type AccountSignerMeta', 'solanaSigners')}<${typeParam}>`;\n    }\n\n    // Readonly, signer.\n    if (instructionAccountNode.isSigner === true) {\n        return fragment`${use('type ReadonlySignerAccount', 'solanaInstructions')}<${typeParam}> & ${use('type AccountSignerMeta', 'solanaSigners')}<${typeParam}>`;\n    }\n\n    // Writable, non-signer or optional signer.\n    if (instructionAccountNode.isWritable) {\n        return fragment`${use('type WritableAccount', 'solanaInstructions')}<${typeParam}>`;\n    }\n\n    // Readonly, non-signer or optional signer.\n    return fragment`${use('type ReadonlyAccount', 'solanaInstructions')}<${typeParam}>`;\n}\n","import { InstructionAccountNode, InstructionInputValueNode, pascalCase } from '@codama/nodes';\nimport {\n    findInstructionNodeFromPath,\n    findProgramNodeFromPath,\n    getLastNodeFromPath,\n    LinkableDictionary,\n    NodePath,\n} from '@codama/visitors-core';\n\nimport { Fragment, fragment, RenderScope, use } from '../utils';\n\nexport function getInstructionAccountTypeParamFragment(\n    scope: Pick<RenderScope, 'linkables'> & {\n        allowAccountMeta: boolean;\n        instructionAccountPath: NodePath<InstructionAccountNode>;\n    },\n): Fragment {\n    const { instructionAccountPath, allowAccountMeta, linkables } = scope;\n    const instructionAccountNode = getLastNodeFromPath(instructionAccountPath);\n    const instructionNode = findInstructionNodeFromPath(instructionAccountPath)!;\n    const programNode = findProgramNodeFromPath(instructionAccountPath)!;\n    const typeParam = `TAccount${pascalCase(instructionAccountNode.name)}`;\n    const accountMeta = allowAccountMeta\n        ? fragment` | ${use('type AccountMeta', 'solanaInstructions')}<string>`\n        : undefined;\n\n    if (instructionNode.optionalAccountStrategy === 'omitted' && instructionAccountNode.isOptional) {\n        return fragment`${typeParam} extends string${accountMeta} | undefined = undefined`;\n    }\n\n    const defaultAddress = getDefaultAddress(instructionAccountNode.defaultValue, programNode.publicKey, linkables);\n    return fragment`${typeParam} extends string${accountMeta} = ${defaultAddress}`;\n}\n\nfunction getDefaultAddress(\n    defaultValue: InstructionInputValueNode | undefined,\n    programId: string,\n    linkables: LinkableDictionary,\n): string {\n    switch (defaultValue?.kind) {\n        case 'publicKeyValueNode':\n            return `\"${defaultValue.publicKey}\"`;\n        case 'programLinkNode':\n            // eslint-disable-next-line no-case-declarations\n            const programNode = linkables.get([defaultValue]);\n            return programNode ? `\"${programNode.publicKey}\"` : 'string';\n        case 'programIdValueNode':\n            return `\"${programId}\"`;\n        default:\n            return 'string';\n    }\n}\n","import { assertIsNode, camelCase, InstructionByteDeltaNode, InstructionNode, isNode } from '@codama/nodes';\nimport { mapFragmentContent } from '@codama/renderers-core';\nimport { getLastNodeFromPath, NodePath, pipe } from '@codama/visitors-core';\n\nimport { addFragmentFeatures, Fragment, fragment, mergeFragments, RenderScope, use } from '../utils';\n\nexport function getInstructionByteDeltaFragment(\n    scope: Pick<RenderScope, 'asyncResolvers' | 'getImportFrom' | 'nameApi'> & {\n        instructionPath: NodePath<InstructionNode>;\n        useAsync: boolean;\n    },\n): Fragment | undefined {\n    const { byteDeltas } = getLastNodeFromPath(scope.instructionPath);\n    const fragments = (byteDeltas ?? []).flatMap(c => getByteDeltaFragment(c, scope));\n    if (fragments.length === 0) return;\n    return mergeFragments(\n        fragments,\n        c =>\n            `// Bytes created or reallocated by the instruction.\\n` +\n            `const byteDelta: number = [${c.join(',')}].reduce((a, b) => a + b, 0);`,\n    );\n}\n\nfunction getByteDeltaFragment(\n    byteDelta: InstructionByteDeltaNode,\n    scope: Pick<RenderScope, 'asyncResolvers' | 'getImportFrom' | 'nameApi'> & {\n        useAsync: boolean;\n    },\n): Fragment[] {\n    let bytesFragment = ((): Fragment | null => {\n        if (isNode(byteDelta.value, 'numberValueNode')) {\n            return getNumberValueNodeFragment(byteDelta);\n        }\n        if (isNode(byteDelta.value, 'argumentValueNode')) {\n            return getArgumentValueNodeFragment(byteDelta);\n        }\n        if (isNode(byteDelta.value, 'accountLinkNode')) {\n            return getAccountLinkNodeFragment(byteDelta, scope);\n        }\n        if (isNode(byteDelta.value, 'resolverValueNode')) {\n            return getResolverValueNodeFragment(byteDelta, scope);\n        }\n        return null;\n    })();\n\n    if (bytesFragment === null) return [];\n\n    if (byteDelta.withHeader) {\n        bytesFragment = fragment`${bytesFragment} + ${use('BASE_ACCOUNT_SIZE', 'solanaAccounts')}`;\n    }\n\n    if (byteDelta.subtract) {\n        bytesFragment = pipe(bytesFragment, f => mapFragmentContent(f, c => `- (${c})`));\n    }\n\n    return [bytesFragment];\n}\n\nfunction getNumberValueNodeFragment(byteDelta: InstructionByteDeltaNode): Fragment {\n    assertIsNode(byteDelta.value, 'numberValueNode');\n    return fragment`${byteDelta.value.number}`;\n}\n\nfunction getArgumentValueNodeFragment(byteDelta: InstructionByteDeltaNode): Fragment {\n    assertIsNode(byteDelta.value, 'argumentValueNode');\n    const argumentName = camelCase(byteDelta.value.name);\n    return fragment`Number(args.${argumentName})`;\n}\n\nfunction getAccountLinkNodeFragment(\n    byteDelta: InstructionByteDeltaNode,\n    scope: Pick<RenderScope, 'getImportFrom' | 'nameApi'>,\n): Fragment {\n    assertIsNode(byteDelta.value, 'accountLinkNode');\n    const functionName = use(\n        scope.nameApi.accountGetSizeFunction(byteDelta.value.name),\n        scope.getImportFrom(byteDelta.value),\n    );\n    return fragment`${functionName}()`;\n}\n\nfunction getResolverValueNodeFragment(\n    byteDelta: InstructionByteDeltaNode,\n    scope: Pick<RenderScope, 'asyncResolvers' | 'getImportFrom' | 'nameApi'> & {\n        useAsync: boolean;\n    },\n): Fragment | null {\n    assertIsNode(byteDelta.value, 'resolverValueNode');\n    const isAsync = scope.asyncResolvers.includes(byteDelta.value.name);\n    if (!scope.useAsync && isAsync) return null;\n\n    const awaitKeyword = scope.useAsync && isAsync ? 'await ' : '';\n    const functionName = use(\n        scope.nameApi.resolverFunction(byteDelta.value.name),\n        scope.getImportFrom(byteDelta.value),\n    );\n    return pipe(fragment`${awaitKeyword}${functionName}(resolverScope)`, f =>\n        addFragmentFeatures(f, ['instruction:resolverScopeVariable']),\n    );\n}\n","import { InstructionNode, structTypeNodeFromInstructionArgumentNodes } from '@codama/nodes';\nimport { getLastNodeFromPath, NodePath } from '@codama/visitors-core';\n\nimport { Fragment, RenderScope, TypeManifest } from '../utils';\nimport { getTypeWithCodecFragment } from './typeWithCodec';\n\nexport function getInstructionDataFragment(\n    scope: Pick<RenderScope, 'customInstructionData' | 'nameApi'> & {\n        dataArgsManifest: TypeManifest;\n        instructionPath: NodePath<InstructionNode>;\n        size: number | null;\n    },\n): Fragment | undefined {\n    const { instructionPath, dataArgsManifest, nameApi, customInstructionData } = scope;\n    const instructionNode = getLastNodeFromPath(instructionPath);\n    if (instructionNode.arguments.length === 0 || customInstructionData.has(instructionNode.name)) return;\n\n    const instructionDataName = nameApi.instructionDataType(instructionNode.name);\n    return getTypeWithCodecFragment({\n        manifest: dataArgsManifest,\n        name: instructionDataName,\n        nameApi,\n        node: structTypeNodeFromInstructionArgumentNodes(instructionNode.arguments),\n        size: scope.size,\n    });\n}\n","import { InstructionNode } from '@codama/nodes';\nimport { mapFragmentContent } from '@codama/renderers-core';\nimport { getLastNodeFromPath, NodePath } from '@codama/visitors-core';\n\nimport { Fragment, RenderScope, TypeManifest } from '../utils';\n\nexport function getInstructionExtraArgsFragment(\n    scope: Pick<RenderScope, 'nameApi'> & {\n        extraArgsManifest: TypeManifest;\n        instructionPath: NodePath<InstructionNode>;\n    },\n): Fragment | undefined {\n    const { instructionPath, extraArgsManifest, nameApi } = scope;\n    const instructionNode = getLastNodeFromPath(instructionPath);\n    if ((instructionNode.extraArguments ?? []).length === 0) return;\n\n    const instructionExtraName = nameApi.instructionExtraType(instructionNode.name);\n    const looseName = nameApi.dataArgsType(instructionExtraName);\n    return mapFragmentContent(extraArgsManifest.looseType, c => `export type ${looseName} = ${c};`);\n}\n","import { camelCase, InstructionArgumentNode, InstructionNode, isNode, isNodeFilter, pascalCase } from '@codama/nodes';\nimport { mapFragmentContent } from '@codama/renderers-core';\nimport {\n    findProgramNodeFromPath,\n    getLastNodeFromPath,\n    NodePath,\n    pipe,\n    ResolvedInstructionInput,\n} from '@codama/visitors-core';\n\nimport {\n    addFragmentImports,\n    Fragment,\n    fragment,\n    getInstructionDependencies,\n    hasAsyncFunction,\n    isAsyncDefaultValue,\n    mergeFragments,\n    RenderScope,\n    TypeManifest,\n    use,\n} from '../utils';\nimport { NameApi } from '../utils/nameTransformers';\nimport { getInstructionByteDeltaFragment } from './instructionByteDelta';\nimport { getInstructionInputResolvedFragment } from './instructionInputResolved';\nimport { getInstructionInputTypeFragment } from './instructionInputType';\nimport { getInstructionRemainingAccountsFragment } from './instructionRemainingAccounts';\n\nexport function getInstructionFunctionFragment(\n    scope: Pick<\n        RenderScope,\n        'asyncResolvers' | 'customInstructionData' | 'getImportFrom' | 'nameApi' | 'typeManifestVisitor'\n    > & {\n        dataArgsManifest: TypeManifest;\n        extraArgsManifest: TypeManifest;\n        instructionPath: NodePath<InstructionNode>;\n        renamedArgs: Map<string, string>;\n        resolvedInputs: ResolvedInstructionInput[];\n        useAsync: boolean;\n    },\n): Fragment | undefined {\n    const { useAsync, instructionPath, resolvedInputs, renamedArgs, asyncResolvers, nameApi, customInstructionData } =\n        scope;\n    const instructionNode = getLastNodeFromPath(instructionPath);\n    const programNode = findProgramNodeFromPath(instructionPath)!;\n    if (useAsync && !hasAsyncFunction(instructionNode, resolvedInputs, asyncResolvers)) return;\n\n    const customData = customInstructionData.get(instructionNode.name);\n    const hasAccounts = instructionNode.accounts.length > 0;\n    const instructionDependencies = getInstructionDependencies(instructionNode, asyncResolvers, useAsync);\n    const argDependencies = instructionDependencies.filter(isNodeFilter('argumentValueNode')).map(node => node.name);\n    const hasData = !!customData || instructionNode.arguments.length > 0;\n    const argIsNotOmitted = (arg: InstructionArgumentNode) =>\n        !(arg.defaultValue && arg.defaultValueStrategy === 'omitted');\n    const argIsDependent = (arg: InstructionArgumentNode) => argDependencies.includes(arg.name);\n    const argHasDefaultValue = (arg: InstructionArgumentNode) => {\n        if (!arg.defaultValue) return false;\n        if (useAsync) return true;\n        return !isAsyncDefaultValue(arg.defaultValue, asyncResolvers);\n    };\n    const hasDataArgs = !!customData || instructionNode.arguments.filter(argIsNotOmitted).length > 0;\n    const hasExtraArgs =\n        (instructionNode.extraArguments ?? []).filter(\n            field => argIsNotOmitted(field) && (argIsDependent(field) || argHasDefaultValue(field)),\n        ).length > 0;\n    const hasRemainingAccountArgs =\n        (instructionNode.remainingAccounts ?? []).filter(({ value }) => isNode(value, 'argumentValueNode')).length > 0;\n    const hasAnyArgs = hasDataArgs || hasExtraArgs || hasRemainingAccountArgs;\n    const hasInput = hasAccounts || hasAnyArgs;\n    const programAddressConstant = use(nameApi.programAddressConstant(programNode.name), 'generatedPrograms');\n\n    const functionName = useAsync\n        ? nameApi.instructionAsyncFunction(instructionNode.name)\n        : nameApi.instructionSyncFunction(instructionNode.name);\n\n    // Input.\n    const resolvedInputsFragment = getInstructionInputResolvedFragment(scope);\n    const remainingAccountsFragment = getInstructionRemainingAccountsFragment(scope);\n    const byteDeltaFragment = getInstructionByteDeltaFragment(scope);\n    const resolvedInputFragment = mergeFragments(\n        [resolvedInputsFragment, remainingAccountsFragment, byteDeltaFragment],\n        content => content.join('\\n\\n'),\n    );\n    const hasRemainingAccounts = !!remainingAccountsFragment;\n    const hasByteDeltas = !!byteDeltaFragment;\n    const hasResolver = resolvedInputFragment.features.has('instruction:resolverScopeVariable');\n    const instructionTypeFragment = getInstructionTypeFragment(scope);\n\n    const typeParams = getTypeParamsFragment(instructionNode, programAddressConstant);\n    const returnType = getReturnTypeFragment(instructionTypeFragment, hasByteDeltas, useAsync);\n    const inputType = getInstructionInputTypeFragment(scope);\n    const inputArg = mapFragmentContent(getInputTypeCallFragment(scope), c => (hasInput ? `input: ${c}, ` : ''));\n    const functionBody = mergeFragments(\n        [\n            getProgramAddressInitializationFragment(programAddressConstant),\n            getAccountsInitializationFragment(instructionNode),\n            getArgumentsInitializationFragment(hasAnyArgs, renamedArgs),\n            getResolverScopeInitializationFragment(hasResolver, hasAccounts, hasAnyArgs),\n            resolvedInputFragment,\n            getReturnStatementFragment({\n                ...scope,\n                hasByteDeltas,\n                hasData,\n                hasDataArgs,\n                hasRemainingAccounts,\n                instructionNode,\n                syncReturnTypeFragment: getReturnTypeFragment(instructionTypeFragment, hasByteDeltas, false),\n            }),\n        ],\n        cs => cs.join('\\n\\n'),\n    );\n\n    return fragment`${inputType}\\n\\nexport ${useAsync ? 'async ' : ''}function ${functionName}${typeParams}(${inputArg}config?: { programAddress?: TProgramAddress } ): ${returnType} {\n  ${functionBody}\n}`;\n}\n\nfunction getProgramAddressInitializationFragment(programAddressConstant: Fragment): Fragment {\n    return fragment`// Program address.\nconst programAddress = config?.programAddress ?? ${programAddressConstant};`;\n}\n\nfunction getAccountsInitializationFragment(instructionNode: InstructionNode): Fragment | undefined {\n    if (instructionNode.accounts.length === 0) return;\n\n    const accounts = mergeFragments(\n        instructionNode.accounts.map(account => {\n            const name = camelCase(account.name);\n            const isWritable = account.isWritable ? 'true' : 'false';\n            return fragment`${name}: { value: input.${name} ?? null, isWritable: ${isWritable} }`;\n        }),\n        cs => cs.join(', '),\n    );\n\n    return fragment` // Original accounts.\nconst originalAccounts = { ${accounts} }\nconst accounts = originalAccounts as Record<keyof typeof originalAccounts, ${use('type ResolvedAccount', 'shared')}>;\n`;\n}\n\nfunction getArgumentsInitializationFragment(\n    hasAnyArgs: boolean,\n    renamedArgs: Map<string, string>,\n): Fragment | undefined {\n    if (!hasAnyArgs) return;\n    const renamedArgsText = [...renamedArgs.entries()].map(([k, v]) => `${k}: input.${v}`).join(', ');\n\n    return fragment`// Original args.\nconst args = { ...input, ${renamedArgsText} };\n`;\n}\n\nfunction getResolverScopeInitializationFragment(\n    hasResolver: boolean,\n    hasAccounts: boolean,\n    hasAnyArgs: boolean,\n): Fragment | undefined {\n    if (!hasResolver) return;\n\n    const resolverAttributes = [\n        'programAddress',\n        ...(hasAccounts ? ['accounts'] : []),\n        ...(hasAnyArgs ? ['args'] : []),\n    ].join(', ');\n\n    return fragment`// Resolver scope.\nconst resolverScope = { ${resolverAttributes} };`;\n}\n\nfunction getReturnStatementFragment(\n    scope: Pick<RenderScope, 'customInstructionData' | 'nameApi'> & {\n        dataArgsManifest: TypeManifest;\n        hasByteDeltas: boolean;\n        hasData: boolean;\n        hasDataArgs: boolean;\n        hasRemainingAccounts: boolean;\n        instructionNode: InstructionNode;\n        syncReturnTypeFragment: Fragment;\n    },\n): Fragment {\n    const { instructionNode, hasByteDeltas, hasData, hasDataArgs, hasRemainingAccounts, nameApi } = scope;\n    const optionalAccountStrategy = instructionNode.optionalAccountStrategy ?? 'programId';\n    const hasAccounts = instructionNode.accounts.length > 0;\n    const hasLegacyOptionalAccounts =\n        instructionNode.optionalAccountStrategy === 'omitted' &&\n        instructionNode.accounts.some(account => account.isOptional);\n\n    // Account meta helper.\n    const getAccountMeta = hasAccounts\n        ? fragment`const getAccountMeta = ${use('getAccountMetaFactory', 'shared')}(programAddress, '${optionalAccountStrategy}');`\n        : '';\n\n    // Accounts.\n    const accountItems = [\n        ...instructionNode.accounts.map(account => `getAccountMeta(accounts.${camelCase(account.name)})`),\n        ...(hasRemainingAccounts ? ['...remainingAccounts'] : []),\n    ].join(', ');\n    let accounts: Fragment | undefined;\n    if (hasAccounts && hasLegacyOptionalAccounts) {\n        accounts = fragment`accounts: [${accountItems}].filter(<T>(x: T | undefined): x is T => x !== undefined)`;\n    } else if (hasAccounts) {\n        accounts = fragment`accounts: [${accountItems}]`;\n    } else if (hasRemainingAccounts) {\n        accounts = fragment`accounts: remainingAccounts`;\n    }\n\n    // Data.\n    const customData = scope.customInstructionData.get(instructionNode.name);\n    const instructionDataName = nameApi.instructionDataType(instructionNode.name);\n    const encoderFunctionFragment = customData\n        ? scope.dataArgsManifest.encoder\n        : `${nameApi.encoderFunction(instructionDataName)}()`;\n    const argsTypeFragment = customData ? scope.dataArgsManifest.looseType : nameApi.dataArgsType(instructionDataName);\n    let data: Fragment | undefined;\n    if (hasDataArgs) {\n        data = fragment`data: ${encoderFunctionFragment}.encode(args as ${argsTypeFragment})`;\n    } else if (hasData) {\n        data = fragment`data: ${encoderFunctionFragment}.encode({})`;\n    }\n\n    // Instruction.\n    const instructionAttributes = pipe(\n        [accounts, hasByteDeltas ? fragment`byteDelta` : undefined, data, fragment`programAddress`],\n        fs => mergeFragments(fs, cs => cs.join(', ')),\n    );\n\n    return fragment`${getAccountMeta}\\nreturn Object.freeze({ ${instructionAttributes} } as ${scope.syncReturnTypeFragment});`;\n}\n\nfunction getReturnTypeFragment(instructionTypeFragment: Fragment, hasByteDeltas: boolean, useAsync: boolean): Fragment {\n    return pipe(\n        instructionTypeFragment,\n        f => (hasByteDeltas ? fragment`${f} & ${use('type InstructionWithByteDelta', 'shared')}` : f),\n        f => (useAsync ? fragment`Promise<${f}>` : f),\n    );\n}\n\nfunction getTypeParamsFragment(instructionNode: InstructionNode, programAddressConstant: Fragment): Fragment {\n    return mergeFragments(\n        [\n            ...instructionNode.accounts.map(account => fragment`TAccount${pascalCase(account.name)} extends string`),\n            fragment`TProgramAddress extends ${use('type Address', 'solanaAddresses')} = typeof ${programAddressConstant}`,\n        ],\n        cs => `<${cs.join(', ')}>`,\n    );\n}\n\nfunction getInstructionTypeFragment(scope: { instructionPath: NodePath<InstructionNode>; nameApi: NameApi }): Fragment {\n    const { instructionPath, nameApi } = scope;\n    const instructionNode = getLastNodeFromPath(instructionPath);\n    const instructionTypeName = nameApi.instructionType(instructionNode.name);\n    const accountTypeParamsFragments = instructionNode.accounts.map(account => {\n        const typeParam = fragment`TAccount${pascalCase(account.name)}`;\n        const camelName = camelCase(account.name);\n\n        if (account.isSigner === 'either') {\n            const signerRole = use(\n                account.isWritable ? 'type WritableSignerAccount' : 'type ReadonlySignerAccount',\n                'solanaInstructions',\n            );\n            return pipe(\n                fragment`typeof input[\"${camelName}\"] extends TransactionSigner<${typeParam}> ? ${signerRole}<${typeParam}> & AccountSignerMeta<${typeParam}> : ${typeParam}`,\n                f => addFragmentImports(f, 'solanaSigners', ['type AccountSignerMeta', 'type TransactionSigner']),\n            );\n        }\n\n        return typeParam;\n    });\n\n    return pipe(\n        mergeFragments([fragment`TProgramAddress`, ...accountTypeParamsFragments], c => c.join(', ')),\n        f => mapFragmentContent(f, c => `${instructionTypeName}<${c}>`),\n    );\n}\n\nfunction getInputTypeCallFragment(scope: {\n    instructionPath: NodePath<InstructionNode>;\n    nameApi: NameApi;\n    useAsync: boolean;\n}): Fragment {\n    const { instructionPath, useAsync, nameApi } = scope;\n    const instructionNode = getLastNodeFromPath(instructionPath);\n    const inputTypeName = useAsync\n        ? nameApi.instructionAsyncInputType(instructionNode.name)\n        : nameApi.instructionSyncInputType(instructionNode.name);\n    if (instructionNode.accounts.length === 0) return fragment`${inputTypeName}`;\n    const accountTypeParams = instructionNode.accounts.map(account => `TAccount${pascalCase(account.name)}`).join(', ');\n\n    return fragment`${inputTypeName}<${accountTypeParams}>`;\n}\n","import { camelCase, InstructionNode, isNode, parseOptionalAccountStrategy } from '@codama/nodes';\nimport { mapFragmentContent } from '@codama/renderers-core';\nimport { getLastNodeFromPath, NodePath, ResolvedInstructionInput } from '@codama/visitors-core';\n\nimport { Fragment, fragment, mergeFragments, RenderScope } from '../utils';\nimport { getInstructionInputDefaultFragment } from './instructionInputDefault';\n\nexport function getInstructionInputResolvedFragment(\n    scope: Pick<RenderScope, 'asyncResolvers' | 'getImportFrom' | 'nameApi' | 'typeManifestVisitor'> & {\n        instructionPath: NodePath<InstructionNode>;\n        resolvedInputs: ResolvedInstructionInput[];\n        useAsync: boolean;\n    },\n): Fragment {\n    const instructionNode = getLastNodeFromPath(scope.instructionPath);\n    const resolvedInputFragments = scope.resolvedInputs.flatMap((input: ResolvedInstructionInput): Fragment[] => {\n        const inputFragment = getInstructionInputDefaultFragment({\n            ...scope,\n            input,\n            optionalAccountStrategy: parseOptionalAccountStrategy(instructionNode.optionalAccountStrategy),\n        });\n        if (!inputFragment.content) return [];\n        const camelName = camelCase(input.name);\n        return [\n            mapFragmentContent(inputFragment, c =>\n                isNode(input, 'instructionArgumentNode')\n                    ? `if (!args.${camelName}) {\\n${c}\\n}`\n                    : `if (!accounts.${camelName}.value) {\\n${c}\\n}`,\n            ),\n        ];\n    });\n\n    if (resolvedInputFragments.length === 0) {\n        return fragment``;\n    }\n\n    return mergeFragments([fragment`// Resolve default values.`, ...resolvedInputFragments], c => c.join('\\n'));\n}\n","/* eslint-disable no-case-declarations */\nimport { camelCase, InstructionInputValueNode, isNode, OptionalAccountStrategy } from '@codama/nodes';\nimport { mapFragmentContent, setFragmentContent } from '@codama/renderers-core';\nimport { pipe, ResolvedInstructionInput, visit } from '@codama/visitors-core';\n\nimport {\n    addFragmentFeatures,\n    addFragmentImports,\n    Fragment,\n    fragment,\n    isAsyncDefaultValue,\n    mergeFragmentImports,\n    mergeFragments,\n    RenderScope,\n} from '../utils';\n\nexport function getInstructionInputDefaultFragment(\n    scope: Pick<RenderScope, 'asyncResolvers' | 'getImportFrom' | 'nameApi' | 'typeManifestVisitor'> & {\n        input: ResolvedInstructionInput;\n        optionalAccountStrategy: OptionalAccountStrategy;\n        useAsync: boolean;\n    },\n): Fragment {\n    const { input, optionalAccountStrategy, asyncResolvers, useAsync, nameApi, typeManifestVisitor, getImportFrom } =\n        scope;\n    if (!input.defaultValue) {\n        return fragment``;\n    }\n\n    if (!useAsync && isAsyncDefaultValue(input.defaultValue, asyncResolvers)) {\n        return fragment``;\n    }\n\n    const { defaultValue } = input;\n    const defaultFragment = (renderedValue: string, isWritable?: boolean): Fragment => {\n        const inputName = camelCase(input.name);\n        if (input.kind === 'instructionAccountNode' && isNode(defaultValue, 'resolverValueNode')) {\n            return fragment`accounts.${inputName} = { ...accounts.${inputName}, ...${renderedValue} };`;\n        }\n        if (input.kind === 'instructionAccountNode' && isWritable === undefined) {\n            return fragment`accounts.${inputName}.value = ${renderedValue};`;\n        }\n        if (input.kind === 'instructionAccountNode') {\n            return fragment`accounts.${inputName}.value = ${renderedValue};\\naccounts.${inputName}.isWritable = ${isWritable ? 'true' : 'false'}`;\n        }\n        return fragment`args.${inputName} = ${renderedValue};`;\n    };\n\n    switch (defaultValue.kind) {\n        case 'accountValueNode':\n            const name = camelCase(defaultValue.name);\n            if (input.kind === 'instructionAccountNode' && input.resolvedIsSigner && !input.isSigner) {\n                return pipe(defaultFragment(`expectTransactionSigner(accounts.${name}.value).address`), f =>\n                    addFragmentImports(f, 'shared', ['expectTransactionSigner']),\n                );\n            }\n            if (input.kind === 'instructionAccountNode') {\n                return pipe(defaultFragment(`expectSome(accounts.${name}.value)`), f =>\n                    addFragmentImports(f, 'shared', ['expectSome']),\n                );\n            }\n            return pipe(defaultFragment(`expectAddress(accounts.${name}.value)`), f =>\n                addFragmentImports(f, 'shared', ['expectAddress']),\n            );\n\n        case 'pdaValueNode':\n            // Inlined PDA value.\n            if (isNode(defaultValue.pda, 'pdaNode')) {\n                const pdaProgram = defaultValue.pda.programId\n                    ? pipe(fragment`'${defaultValue.pda.programId}' as Address<'${defaultValue.pda.programId}'>`, f =>\n                          addFragmentImports(f, 'solanaAddresses', ['type Address']),\n                      )\n                    : fragment`programAddress`;\n                const pdaSeeds = defaultValue.pda.seeds.flatMap((seed): Fragment[] => {\n                    if (isNode(seed, 'constantPdaSeedNode') && isNode(seed.value, 'programIdValueNode')) {\n                        return [\n                            pipe(fragment`getAddressEncoder().encode(${pdaProgram})`, f =>\n                                addFragmentImports(f, 'solanaAddresses', ['getAddressEncoder']),\n                            ),\n                        ];\n                    }\n                    if (isNode(seed, 'constantPdaSeedNode') && !isNode(seed.value, 'programIdValueNode')) {\n                        const typeManifest = visit(seed.type, typeManifestVisitor);\n                        const valueManifest = visit(seed.value, typeManifestVisitor);\n                        return [fragment`${typeManifest.encoder}.encode(${valueManifest.value})`];\n                    }\n                    if (isNode(seed, 'variablePdaSeedNode')) {\n                        const typeManifest = visit(seed.type, typeManifestVisitor);\n                        const valueSeed = defaultValue.seeds.find(s => s.name === seed.name)?.value;\n                        if (!valueSeed) return [];\n                        if (isNode(valueSeed, 'accountValueNode')) {\n                            return [\n                                pipe(\n                                    fragment`${typeManifest.encoder}.encode(expectAddress(accounts.${camelCase(valueSeed.name)}.value))`,\n                                    f => addFragmentImports(f, 'shared', ['expectAddress']),\n                                ),\n                            ];\n                        }\n                        if (isNode(valueSeed, 'argumentValueNode')) {\n                            return [\n                                pipe(\n                                    fragment`${typeManifest.encoder}.encode(expectSome(args.${camelCase(valueSeed.name)}))`,\n                                    f => addFragmentImports(f, 'shared', ['expectSome']),\n                                ),\n                            ];\n                        }\n                        const valueManifest = visit(valueSeed, typeManifestVisitor);\n                        return [fragment`${typeManifest.encoder}.encode(${valueManifest.value})`];\n                    }\n                    return [];\n                });\n                return pipe(\n                    mergeFragments([pdaProgram, ...pdaSeeds], ([p, ...s]) => {\n                        const programAddress = p === 'programAddress' ? p : `programAddress: ${p}`;\n                        return `await getProgramDerivedAddress({ ${programAddress}, seeds: [${s.join(', ')}] })`;\n                    }),\n                    f => addFragmentImports(f, 'solanaAddresses', ['getProgramDerivedAddress']),\n                    f => mapFragmentContent(f, c => defaultFragment(c).content),\n                );\n            }\n\n            // Linked PDA value.\n            const pdaFunction = nameApi.pdaFindFunction(defaultValue.pda.name);\n            const pdaArgs = [];\n            const pdaSeeds = defaultValue.seeds.map((seed): Fragment => {\n                if (isNode(seed.value, 'accountValueNode')) {\n                    return pipe(\n                        fragment`${seed.name}: expectAddress(accounts.${camelCase(seed.value.name)}.value)`,\n                        f => addFragmentImports(f, 'shared', ['expectAddress']),\n                    );\n                }\n                if (isNode(seed.value, 'argumentValueNode')) {\n                    return pipe(fragment`${seed.name}: expectSome(args.${camelCase(seed.value.name)})`, f =>\n                        addFragmentImports(f, 'shared', ['expectSome']),\n                    );\n                }\n                return pipe(visit(seed.value, typeManifestVisitor).value, f =>\n                    mapFragmentContent(f, c => `${seed.name}: ${c}`),\n                );\n            });\n            const pdaSeedsFragment = pipe(\n                mergeFragments(pdaSeeds, renders => renders.join(', ')),\n                f => mapFragmentContent(f, c => `{ ${c} }`),\n            );\n            if (pdaSeeds.length > 0) {\n                pdaArgs.push(pdaSeedsFragment.content);\n            }\n            const module = getImportFrom(defaultValue.pda);\n            return pipe(\n                defaultFragment(`await ${pdaFunction}(${pdaArgs.join(', ')})`),\n                f => mergeFragmentImports(f, [pdaSeedsFragment.imports]),\n                f => addFragmentImports(f, module, [pdaFunction]),\n            );\n\n        case 'publicKeyValueNode':\n            return pipe(defaultFragment(`'${defaultValue.publicKey}' as Address<'${defaultValue.publicKey}'>`), f =>\n                addFragmentImports(f, 'solanaAddresses', ['type Address']),\n            );\n\n        case 'programLinkNode':\n            const programAddress = nameApi.programAddressConstant(defaultValue.name);\n            return pipe(defaultFragment(programAddress, false), f =>\n                addFragmentImports(f, getImportFrom(defaultValue), [programAddress]),\n            );\n\n        case 'programIdValueNode':\n            if (\n                optionalAccountStrategy === 'programId' &&\n                input.kind === 'instructionAccountNode' &&\n                input.isOptional\n            ) {\n                return fragment``;\n            }\n            return defaultFragment('programAddress', false);\n\n        case 'identityValueNode':\n        case 'payerValueNode':\n            return fragment``;\n\n        case 'accountBumpValueNode':\n            return pipe(\n                defaultFragment(`expectProgramDerivedAddress(accounts.${camelCase(defaultValue.name)}.value)[1]`),\n                f => addFragmentImports(f, 'shared', ['expectProgramDerivedAddress']),\n            );\n\n        case 'argumentValueNode':\n            return pipe(defaultFragment(`expectSome(args.${camelCase(defaultValue.name)})`), f =>\n                addFragmentImports(f, 'shared', ['expectSome']),\n            );\n\n        case 'resolverValueNode':\n            const resolverFunction = nameApi.resolverFunction(defaultValue.name);\n            const resolverAwait = useAsync && asyncResolvers.includes(defaultValue.name) ? 'await ' : '';\n            return pipe(\n                defaultFragment(`${resolverAwait}${resolverFunction}(resolverScope)`),\n                f => addFragmentImports(f, getImportFrom(defaultValue), [resolverFunction]),\n                f => addFragmentFeatures(f, ['instruction:resolverScopeVariable']),\n            );\n\n        case 'conditionalValueNode':\n            const ifTrueRenderer = renderNestedInstructionDefault({\n                ...scope,\n                defaultValue: defaultValue.ifTrue,\n            });\n            const ifFalseRenderer = renderNestedInstructionDefault({\n                ...scope,\n                defaultValue: defaultValue.ifFalse,\n            });\n            if (!ifTrueRenderer && !ifFalseRenderer) {\n                return fragment``;\n            }\n            let conditionalFragment = fragment``;\n            if (ifTrueRenderer) {\n                conditionalFragment = mergeFragments([conditionalFragment, ifTrueRenderer], c => c[0]);\n            }\n            if (ifFalseRenderer) {\n                conditionalFragment = mergeFragments([conditionalFragment, ifFalseRenderer], c => c[0]);\n            }\n            const negatedCondition = !ifTrueRenderer;\n            let condition = 'true';\n\n            if (isNode(defaultValue.condition, 'resolverValueNode')) {\n                const conditionalResolverFunction = nameApi.resolverFunction(defaultValue.condition.name);\n                const module = getImportFrom(defaultValue.condition);\n                conditionalFragment = pipe(\n                    conditionalFragment,\n                    f => addFragmentImports(f, module, [conditionalResolverFunction]),\n                    f => addFragmentFeatures(f, ['instruction:resolverScopeVariable']),\n                );\n                const conditionalResolverAwait =\n                    useAsync && asyncResolvers.includes(defaultValue.condition.name) ? 'await ' : '';\n                condition = `${conditionalResolverAwait}${conditionalResolverFunction}(resolverScope)`;\n                condition = negatedCondition ? `!${condition}` : condition;\n            } else {\n                const comparedInputName = isNode(defaultValue.condition, 'accountValueNode')\n                    ? `accounts.${camelCase(defaultValue.condition.name)}.value`\n                    : `args.${camelCase(defaultValue.condition.name)}`;\n                if (defaultValue.value) {\n                    const comparedValue = visit(defaultValue.value, typeManifestVisitor).value;\n                    conditionalFragment = mergeFragments([conditionalFragment, comparedValue], c => c[0]);\n                    const operator = negatedCondition ? '!==' : '===';\n                    condition = `${comparedInputName} ${operator} ${comparedValue.content}`;\n                } else {\n                    condition = negatedCondition ? `!${comparedInputName}` : comparedInputName;\n                }\n            }\n\n            if (ifTrueRenderer && ifFalseRenderer) {\n                return setFragmentContent(\n                    conditionalFragment,\n                    `if (${condition}) {\\n${ifTrueRenderer.content}\\n} else {\\n${ifFalseRenderer.content}\\n}`,\n                );\n            }\n\n            return setFragmentContent(\n                conditionalFragment,\n                `if (${condition}) {\\n${ifTrueRenderer ? ifTrueRenderer.content : ifFalseRenderer?.content}\\n}`,\n            );\n\n        default:\n            const valueManifest = visit(defaultValue, typeManifestVisitor).value;\n            return pipe(valueManifest, f => mapFragmentContent(f, c => defaultFragment(c).content));\n    }\n}\n\nfunction renderNestedInstructionDefault(\n    scope: Parameters<typeof getInstructionInputDefaultFragment>[0] & {\n        defaultValue: InstructionInputValueNode | undefined;\n    },\n): Fragment | undefined {\n    const { input, defaultValue } = scope;\n    if (!defaultValue) return undefined;\n    return getInstructionInputDefaultFragment({\n        ...scope,\n        input: { ...input, defaultValue },\n    });\n}\n","import {\n    camelCase,\n    getAllInstructionArguments,\n    InstructionArgumentNode,\n    InstructionNode,\n    isNode,\n    pascalCase,\n} from '@codama/nodes';\nimport { mapFragmentContent } from '@codama/renderers-core';\nimport {\n    getLastNodeFromPath,\n    NodePath,\n    pipe,\n    ResolvedInstructionAccount,\n    ResolvedInstructionArgument,\n    ResolvedInstructionInput,\n} from '@codama/visitors-core';\n\nimport {\n    Fragment,\n    fragment,\n    getDocblockFragment,\n    isAsyncDefaultValue,\n    mergeFragmentImports,\n    mergeFragments,\n    RenderScope,\n    TypeManifest,\n    use,\n} from '../utils';\n\nexport function getInstructionInputTypeFragment(\n    scope: Pick<RenderScope, 'asyncResolvers' | 'customInstructionData' | 'nameApi'> & {\n        dataArgsManifest: TypeManifest;\n        instructionPath: NodePath<InstructionNode>;\n        renamedArgs: Map<string, string>;\n        resolvedInputs: ResolvedInstructionInput[];\n        useAsync: boolean;\n    },\n): Fragment {\n    const { instructionPath, useAsync, nameApi } = scope;\n    const instructionNode = getLastNodeFromPath(instructionPath);\n    const instructionInputType = useAsync\n        ? nameApi.instructionAsyncInputType(instructionNode.name)\n        : nameApi.instructionSyncInputType(instructionNode.name);\n    const [dataArgumentsFragment, customDataArgumentsFragment] = getDataArgumentsFragments(scope);\n\n    let accountTypeParams = '';\n    if (instructionNode.accounts.length > 0) {\n        accountTypeParams = instructionNode.accounts\n            .map(account => `TAccount${pascalCase(account.name)} extends string = string`)\n            .join(', ');\n        accountTypeParams = `<${accountTypeParams}>`;\n    }\n\n    const typeBodyFragment = mergeFragments(\n        [\n            getAccountsFragment(scope),\n            dataArgumentsFragment,\n            getExtraArgumentsFragment(scope),\n            getRemainingAccountsFragment(instructionNode),\n        ],\n        c => c.join('\\n'),\n    );\n\n    return fragment`export type ${instructionInputType}${accountTypeParams} = ${customDataArgumentsFragment} {\n  ${typeBodyFragment}\n}`;\n}\n\nfunction getAccountsFragment(\n    scope: Pick<RenderScope, 'asyncResolvers' | 'customInstructionData' | 'nameApi'> & {\n        instructionPath: NodePath<InstructionNode>;\n        resolvedInputs: ResolvedInstructionInput[];\n        useAsync: boolean;\n    },\n): Fragment {\n    const { instructionPath, resolvedInputs, useAsync, asyncResolvers } = scope;\n    const instructionNode = getLastNodeFromPath(instructionPath);\n\n    const fragments = instructionNode.accounts.map(account => {\n        const resolvedAccount = resolvedInputs.find(\n            input => input.kind === 'instructionAccountNode' && input.name === account.name,\n        ) as ResolvedInstructionAccount;\n        const hasDefaultValue =\n            !!resolvedAccount.defaultValue &&\n            !isNode(resolvedAccount.defaultValue, ['identityValueNode', 'payerValueNode']) &&\n            (useAsync || !isAsyncDefaultValue(resolvedAccount.defaultValue, asyncResolvers));\n        const docs = getDocblockFragment(account.docs ?? [], true);\n        const optionalSign = hasDefaultValue || resolvedAccount.isOptional ? '?' : '';\n        return fragment`${docs}${camelCase(account.name)}${optionalSign}: ${getAccountTypeFragment(resolvedAccount)};`;\n    });\n\n    return mergeFragments(fragments, c => c.join('\\n'));\n}\n\nfunction getAccountTypeFragment(account: Pick<ResolvedInstructionAccount, 'isPda' | 'isSigner' | 'name'>): Fragment {\n    const typeParam = `TAccount${pascalCase(account.name)}`;\n    const address = use('type Address', 'solanaAddresses');\n    const signer = use('type TransactionSigner', 'solanaSigners');\n    const pda = use('type ProgramDerivedAddress', 'solanaAddresses');\n\n    if (account.isPda && account.isSigner === false) return fragment`${pda}<${typeParam}>`;\n    if (account.isPda && account.isSigner === 'either') return fragment`${pda}<${typeParam}> | ${signer}<${typeParam}>`;\n    if (account.isSigner === 'either') return fragment`${address}<${typeParam}> | ${signer}<${typeParam}>`;\n    if (account.isSigner) return fragment`${signer}<${typeParam}>`;\n    return fragment`${address}<${typeParam}>`;\n}\n\nfunction getDataArgumentsFragments(\n    scope: Pick<RenderScope, 'customInstructionData' | 'nameApi'> & {\n        dataArgsManifest: TypeManifest;\n        instructionPath: NodePath<InstructionNode>;\n        renamedArgs: Map<string, string>;\n        resolvedInputs: ResolvedInstructionInput[];\n    },\n): [Fragment | undefined, Fragment] {\n    const { instructionPath, nameApi } = scope;\n    const instructionNode = getLastNodeFromPath(instructionPath);\n\n    const customData = scope.customInstructionData.get(instructionNode.name);\n    if (customData) {\n        return [\n            undefined,\n            pipe(\n                fragment`${nameApi.dataArgsType(customData.importAs)}`,\n                f => mergeFragmentImports(f, [scope.dataArgsManifest.looseType.imports]),\n                f => mapFragmentContent(f, c => `${c} & `),\n            ),\n        ];\n    }\n\n    const instructionDataName = nameApi.instructionDataType(instructionNode.name);\n    const dataArgsType = nameApi.dataArgsType(instructionDataName);\n\n    const fragments = instructionNode.arguments.flatMap(arg => {\n        const argFragment = getArgumentFragment(arg, dataArgsType, scope.resolvedInputs, scope.renamedArgs);\n        return argFragment ? [argFragment] : [];\n    });\n\n    return [fragments.length === 0 ? undefined : mergeFragments(fragments, c => c.join('\\n')), fragment``];\n}\n\nfunction getExtraArgumentsFragment(\n    scope: Pick<RenderScope, 'nameApi'> & {\n        instructionPath: NodePath<InstructionNode>;\n        renamedArgs: Map<string, string>;\n        resolvedInputs: ResolvedInstructionInput[];\n    },\n): Fragment | undefined {\n    const { instructionPath, nameApi } = scope;\n    const instructionNode = getLastNodeFromPath(instructionPath);\n    const instructionExtraName = nameApi.instructionExtraType(instructionNode.name);\n    const extraArgsType = nameApi.dataArgsType(instructionExtraName);\n\n    const fragments = (instructionNode.extraArguments ?? []).flatMap(arg => {\n        const argFragment = getArgumentFragment(arg, extraArgsType, scope.resolvedInputs, scope.renamedArgs);\n        return argFragment ? [argFragment] : [];\n    });\n    if (fragments.length === 0) return;\n\n    return mergeFragments(fragments, c => c.join('\\n'));\n}\n\nfunction getArgumentFragment(\n    arg: InstructionArgumentNode,\n    argsType: string,\n    resolvedInputs: ResolvedInstructionInput[],\n    renamedArgs: Map<string, string>,\n): Fragment | null {\n    const resolvedArg = resolvedInputs.find(\n        input => isNode(input, 'instructionArgumentNode') && input.name === arg.name,\n    ) as ResolvedInstructionArgument | undefined;\n    if (arg.defaultValue && arg.defaultValueStrategy === 'omitted') return null;\n    const renamedName = renamedArgs.get(arg.name) ?? arg.name;\n    const optionalSign = arg.defaultValue || resolvedArg?.defaultValue ? '?' : '';\n    return fragment`${camelCase(renamedName)}${optionalSign}: ${argsType}[\"${camelCase(arg.name)}\"];`;\n}\n\nfunction getRemainingAccountsFragment(instructionNode: InstructionNode): Fragment | undefined {\n    const fragments = (instructionNode.remainingAccounts ?? []).flatMap(remainingAccountsNode => {\n        if (isNode(remainingAccountsNode.value, 'resolverValueNode')) return [];\n\n        const { name } = remainingAccountsNode.value;\n        const allArguments = getAllInstructionArguments(instructionNode);\n        const argumentExists = allArguments.some(arg => arg.name === name);\n        if (argumentExists) return [];\n\n        const isSigner = remainingAccountsNode.isSigner ?? false;\n        const optionalSign = (remainingAccountsNode.isOptional ?? false) ? '?' : '';\n        const signerFragment = use('type TransactionSigner', 'solanaSigners');\n        const addressFragment = use('type Address', 'solanaAddresses');\n        const typeFragment = (() => {\n            if (isSigner === 'either') return fragment`${signerFragment} | ${addressFragment}`;\n            return isSigner ? signerFragment : addressFragment;\n        })();\n\n        return fragment`${camelCase(name)}${optionalSign}: Array<${typeFragment}>;`;\n    });\n    if (fragments.length === 0) return;\n\n    return mergeFragments(fragments, c => c.join('\\n'));\n}\n","import {\n    assertIsNode,\n    camelCase,\n    getAllInstructionArguments,\n    InstructionNode,\n    InstructionRemainingAccountsNode,\n    isNode,\n} from '@codama/nodes';\nimport { getLastNodeFromPath, NodePath, pipe } from '@codama/visitors-core';\n\nimport {\n    addFragmentFeatures,\n    addFragmentImports,\n    Fragment,\n    fragment,\n    mergeFragments,\n    RenderScope,\n    use,\n} from '../utils';\n\nexport function getInstructionRemainingAccountsFragment(\n    scope: Pick<RenderScope, 'asyncResolvers' | 'getImportFrom' | 'nameApi'> & {\n        instructionPath: NodePath<InstructionNode>;\n        useAsync: boolean;\n    },\n): Fragment | undefined {\n    const { remainingAccounts } = getLastNodeFromPath(scope.instructionPath);\n    const fragments = (remainingAccounts ?? []).flatMap(a => getRemainingAccountsFragment(a, scope));\n    if (fragments.length === 0) return;\n    return pipe(\n        mergeFragments(\n            fragments,\n            c =>\n                `// Remaining accounts.\\n` +\n                `const remainingAccounts: AccountMeta[] = ${c.length === 1 ? c[0] : `[...${c.join(', ...')}]`}`,\n        ),\n        f => addFragmentImports(f, 'solanaInstructions', ['type AccountMeta']),\n    );\n}\n\nfunction getRemainingAccountsFragment(\n    remainingAccounts: InstructionRemainingAccountsNode,\n    scope: Pick<RenderScope, 'asyncResolvers' | 'getImportFrom' | 'nameApi'> & {\n        instructionPath: NodePath<InstructionNode>;\n        useAsync: boolean;\n    },\n): Fragment[] {\n    const remainingAccountsFragment = ((): Fragment | null => {\n        if (isNode(remainingAccounts.value, 'argumentValueNode')) {\n            return getArgumentValueNodeFragment(remainingAccounts, scope);\n        }\n        if (isNode(remainingAccounts.value, 'resolverValueNode')) {\n            return getResolverValueNodeFragment(remainingAccounts, scope);\n        }\n        return null;\n    })();\n\n    if (remainingAccountsFragment === null) return [];\n    return [remainingAccountsFragment];\n}\n\nfunction getArgumentValueNodeFragment(\n    remainingAccounts: InstructionRemainingAccountsNode,\n    scope: { instructionPath: NodePath<InstructionNode> },\n): Fragment {\n    const instructionNode = getLastNodeFromPath(scope.instructionPath);\n    assertIsNode(remainingAccounts.value, 'argumentValueNode');\n    const argumentName = camelCase(remainingAccounts.value.name);\n    const isOptional = remainingAccounts.isOptional ?? false;\n    const isSigner = remainingAccounts.isSigner ?? false;\n    const isWritable = remainingAccounts.isWritable ?? false;\n    const accountRole = use('AccountRole', 'solanaInstructions');\n    const nonSignerRole = isWritable ? fragment`${accountRole}.WRITABLE` : fragment`${accountRole}.READONLY`;\n    const signerRole = isWritable ? fragment`${accountRole}.WRITABLE_SIGNER` : fragment`${accountRole}.READONLY_SIGNER`;\n    const role = isSigner === true ? signerRole : nonSignerRole;\n    const argumentArray = isOptional ? `(args.${argumentName} ?? [])` : `args.${argumentName}`;\n\n    // The argument already exists or was added as `Array<Address>`.\n    const allArguments = getAllInstructionArguments(instructionNode);\n    const argumentExists = allArguments.some(arg => arg.name === remainingAccounts.value.name);\n    if (argumentExists || isSigner === false) {\n        return fragment`${argumentArray}.map((address) => ({ address, role: ${role} }))`;\n    }\n\n    // The argument was added as `Array<TransactionSigner | Address>`.\n    if (isSigner === 'either') {\n        return fragment`${argumentArray}.map((addressOrSigner) => (${use('isTransactionSigner', 'shared')}(addressOrSigner) ? { address: addressOrSigner.address, role: ${role}, signer: addressOrSigner } : { address: addressOrSigner, role: ${role} }))`;\n    }\n\n    // The argument was added as `Array<TransactionSigner>`.\n    return fragment`${argumentArray}.map((signer) => ({ address: signer.address, role: ${signerRole}, signer }))`;\n}\n\nfunction getResolverValueNodeFragment(\n    remainingAccounts: InstructionRemainingAccountsNode,\n    scope: Pick<RenderScope, 'asyncResolvers' | 'getImportFrom' | 'nameApi'> & {\n        useAsync: boolean;\n    },\n): Fragment | null {\n    assertIsNode(remainingAccounts.value, 'resolverValueNode');\n    const isAsync = scope.asyncResolvers.includes(remainingAccounts.value.name);\n    if (!scope.useAsync && isAsync) return null;\n\n    const awaitKeyword = scope.useAsync && isAsync ? 'await ' : '';\n    const functionName = use(\n        scope.nameApi.resolverFunction(remainingAccounts.value.name),\n        scope.getImportFrom(remainingAccounts.value),\n    );\n    return pipe(fragment`${awaitKeyword}${functionName}(resolverScope)`, f =>\n        addFragmentFeatures(f, ['instruction:resolverScopeVariable']),\n    );\n}\n","import { logWarn } from '@codama/errors';\nimport { camelCase, definedTypeNode, InstructionNode, structTypeNodeFromInstructionArgumentNodes } from '@codama/nodes';\nimport {\n    findProgramNodeFromPath,\n    getLastNodeFromPath,\n    NodePath,\n    ResolvedInstructionInput,\n    visit,\n} from '@codama/visitors-core';\n\nimport { Fragment, mergeFragments, RenderScope } from '../utils';\nimport { getDiscriminatorConstantsFragment } from './discriminatorConstants';\nimport { getInstructionDataFragment } from './instructionData';\nimport { getInstructionExtraArgsFragment } from './instructionExtraArgs';\nimport { getInstructionFunctionFragment } from './instructionFunction';\nimport { getInstructionParseFunctionFragment } from './instructionParseFunction';\nimport { getInstructionTypeFragment } from './instructionType';\n\nexport function getInstructionPageFragment(\n    scope: Pick<\n        RenderScope,\n        'asyncResolvers' | 'customInstructionData' | 'getImportFrom' | 'linkables' | 'nameApi' | 'typeManifestVisitor'\n    > & {\n        instructionPath: NodePath<InstructionNode>;\n        resolvedInputs: ResolvedInstructionInput[];\n        size: number | null;\n    },\n): Fragment {\n    const node = getLastNodeFromPath(scope.instructionPath);\n    if (!findProgramNodeFromPath(scope.instructionPath)) {\n        throw new Error('Instruction must be visited inside a program.');\n    }\n\n    const childScope = {\n        ...scope,\n        dataArgsManifest: visit(node, scope.typeManifestVisitor),\n        extraArgsManifest: visit(\n            definedTypeNode({\n                name: scope.nameApi.instructionExtraType(node.name),\n                type: structTypeNodeFromInstructionArgumentNodes(node.extraArguments ?? []),\n            }),\n            scope.typeManifestVisitor,\n        ),\n        renamedArgs: getRenamedArgsMap(node),\n    };\n\n    return mergeFragments(\n        [\n            getDiscriminatorConstantsFragment({\n                ...childScope,\n                discriminatorNodes: node.discriminators ?? [],\n                fields: node.arguments,\n                prefix: node.name,\n            }),\n            getInstructionTypeFragment(childScope),\n            getInstructionDataFragment(childScope),\n            getInstructionExtraArgsFragment(childScope),\n            getInstructionFunctionFragment({ ...childScope, useAsync: true }),\n            getInstructionFunctionFragment({ ...childScope, useAsync: false }),\n            getInstructionParseFunctionFragment(childScope),\n        ],\n        cs => cs.join('\\n\\n'),\n    );\n}\n\nfunction getRenamedArgsMap(instruction: InstructionNode): Map<string, string> {\n    const argNames = [\n        ...instruction.arguments.map(a => a.name),\n        ...(instruction.extraArguments ?? []).map(a => a.name),\n    ];\n    const duplicateArgs = argNames.filter((e, i, a) => a.indexOf(e) !== i);\n    if (duplicateArgs.length > 0) {\n        throw new Error(`Duplicate args found: [${duplicateArgs.join(', ')}] in instruction [${instruction.name}].`);\n    }\n\n    const allNames = [...instruction.accounts.map(account => account.name), ...argNames];\n    const duplicates = allNames.filter((e, i, a) => a.indexOf(e) !== i);\n    if (duplicates.length === 0) return new Map();\n\n    logWarn(\n        `[JavaScript] Accounts and args of instruction [${instruction.name}] have the following ` +\n            `conflicting attributes [${duplicates.join(', ')}]. ` +\n            `Thus, the arguments have been renamed to avoid conflicts in the input type.`,\n    );\n\n    return new Map(duplicates.map(name => [camelCase(name), camelCase(`${name}Arg`)]));\n}\n","import { camelCase, InstructionNode } from '@codama/nodes';\nimport { findProgramNodeFromPath, getLastNodeFromPath, NodePath, pipe } from '@codama/visitors-core';\n\nimport {\n    addFragmentImports,\n    Fragment,\n    fragment,\n    getDocblockFragment,\n    mergeFragments,\n    RenderScope,\n    TypeManifest,\n    use,\n} from '../utils';\n\nexport function getInstructionParseFunctionFragment(\n    scope: Pick<RenderScope, 'customInstructionData' | 'nameApi'> & {\n        dataArgsManifest: TypeManifest;\n        instructionPath: NodePath<InstructionNode>;\n    },\n): Fragment {\n    const instructionNode = getLastNodeFromPath(scope.instructionPath);\n    const programNode = findProgramNodeFromPath(scope.instructionPath)!;\n    const programAddressConstant = use(scope.nameApi.programAddressConstant(programNode.name), 'generatedPrograms');\n    const childScope = { ...scope, instructionNode, programAddressConstant };\n\n    return mergeFragments([getTypeFragment(childScope), getFunctionFragment(childScope)], cs => cs.join('\\n\\n'));\n}\n\nfunction getTypeFragment(\n    scope: Pick<RenderScope, 'customInstructionData' | 'nameApi'> & {\n        dataArgsManifest: TypeManifest;\n        instructionNode: InstructionNode;\n        programAddressConstant: Fragment;\n    },\n): Fragment {\n    const customData = scope.customInstructionData.get(scope.instructionNode.name);\n    const instructionParsedType = scope.nameApi.instructionParsedType(scope.instructionNode.name);\n    const instructionDataName = scope.nameApi.instructionDataType(scope.instructionNode.name);\n\n    const hasData = !!customData || scope.instructionNode.arguments.length > 0;\n    const hasAccounts = scope.instructionNode.accounts.length > 0;\n\n    const typeParamDeclarations = mergeFragments(\n        [\n            fragment`TProgram extends string = typeof ${scope.programAddressConstant}`,\n            hasAccounts\n                ? fragment`TAccountMetas extends readonly ${use('type AccountMeta', 'solanaInstructions')}[] = readonly AccountMeta[]`\n                : undefined,\n        ],\n        cs => cs.join(', '),\n    );\n\n    const accounts = mergeFragments(\n        scope.instructionNode.accounts.map((account, i) => {\n            const docs = getDocblockFragment(account.docs ?? [], true);\n            const name = camelCase(account.name);\n            return fragment`${docs}${name}${account.isOptional ? '?' : ''}: TAccountMetas[${i}]${account.isOptional ? ' | undefined' : ''};`;\n        }),\n        cs => (hasAccounts ? `\\naccounts: {\\n${cs.join('\\n')}\\n};` : ''),\n    );\n\n    const dataTypeFragment = customData\n        ? scope.dataArgsManifest.strictType\n        : fragment`${scope.nameApi.dataType(instructionDataName)}`;\n    const data = hasData ? fragment`\\ndata: ${dataTypeFragment};` : fragment``;\n\n    return fragment`export type ${instructionParsedType}<${typeParamDeclarations}> = { programAddress: ${use('type Address', 'solanaAddresses')}<TProgram>;${accounts}${data} };`;\n}\n\nfunction getFunctionFragment(\n    scope: Pick<RenderScope, 'customInstructionData' | 'nameApi'> & {\n        dataArgsManifest: TypeManifest;\n        instructionNode: InstructionNode;\n        programAddressConstant: Fragment;\n    },\n): Fragment {\n    const customData = scope.customInstructionData.get(scope.instructionNode.name);\n    const instructionParsedType = scope.nameApi.instructionParsedType(scope.instructionNode.name);\n    const instructionParseFunction = scope.nameApi.instructionParseFunction(scope.instructionNode.name);\n    const instructionDataName = scope.nameApi.instructionDataType(scope.instructionNode.name);\n    const decoderFunction = customData\n        ? scope.dataArgsManifest.decoder\n        : fragment`${scope.nameApi.decoderFunction(instructionDataName)}()`;\n\n    const hasData = !!customData || scope.instructionNode.arguments.length > 0;\n    const hasAccounts = scope.instructionNode.accounts.length > 0;\n    const hasOptionalAccounts = scope.instructionNode.accounts.some(account => account.isOptional);\n    const minimumNumberOfAccounts =\n        scope.instructionNode.optionalAccountStrategy === 'omitted'\n            ? scope.instructionNode.accounts.filter(account => !account.isOptional).length\n            : scope.instructionNode.accounts.length;\n\n    const typeParams = ['TProgram', hasAccounts ? 'TAccountMetas' : undefined].filter(Boolean).join(', ');\n    const typeParamDeclarations = mergeFragments(\n        [\n            fragment`TProgram extends string`,\n            hasAccounts\n                ? fragment`TAccountMetas extends readonly ${use('type AccountMeta', 'solanaInstructions')}[]`\n                : undefined,\n        ],\n        cs => cs.join(', '),\n    );\n\n    const instructionType = mergeFragments(\n        [\n            fragment`${use('type Instruction', 'solanaInstructions')}<TProgram>`,\n            hasAccounts\n                ? fragment`${use('type InstructionWithAccounts', 'solanaInstructions')}<TAccountMetas>`\n                : undefined,\n            hasData\n                ? pipe(\n                      fragment`InstructionWithData<ReadonlyUint8Array>`,\n                      f => addFragmentImports(f, 'solanaInstructions', ['type InstructionWithData']),\n                      f => addFragmentImports(f, 'solanaCodecsCore', ['type ReadonlyUint8Array']),\n                  )\n                : undefined,\n        ],\n        cs => cs.join(' & '),\n    );\n\n    let accountHelpers: Fragment | undefined;\n    if (hasAccounts) {\n        accountHelpers = fragment`if (instruction.accounts.length < ${minimumNumberOfAccounts}) {\n  // TODO: Coded error.\n  throw new Error('Not enough accounts');\n}\nlet accountIndex = 0;\nconst getNextAccount = () => {\n  const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n  accountIndex += 1;\n  return accountMeta;\n}`;\n    }\n    if (hasOptionalAccounts && scope.instructionNode.optionalAccountStrategy === 'omitted') {\n        accountHelpers = fragment`${accountHelpers}\nlet optionalAccountsRemaining = instruction.accounts.length - ${minimumNumberOfAccounts};\nconst getNextOptionalAccount = () => {\n  if (optionalAccountsRemaining === 0) return undefined;\n  optionalAccountsRemaining -= 1;\n  return getNextAccount();\n};`;\n    } else if (hasOptionalAccounts) {\n        accountHelpers = fragment`${accountHelpers}\nconst getNextOptionalAccount = () => {\n  const accountMeta = getNextAccount();\n  return accountMeta.address === ${scope.programAddressConstant} ? undefined : accountMeta;\n};`;\n    }\n\n    const accounts = mergeFragments(\n        scope.instructionNode.accounts.map(account =>\n            account.isOptional\n                ? fragment`${camelCase(account.name)}: getNextOptionalAccount()`\n                : fragment`${camelCase(account.name)}: getNextAccount()`,\n        ),\n        cs => (hasAccounts ? `, accounts: { ${cs.join(', ')} }` : ''),\n    );\n\n    const data = hasData ? fragment`, data: ${decoderFunction}.decode(instruction.data)` : fragment``;\n\n    return fragment`export function ${instructionParseFunction}<${typeParamDeclarations}>(instruction: ${instructionType}): ${instructionParsedType}<${typeParams}> {\n  ${accountHelpers}\n  return { programAddress: instruction.programAddress${accounts}${data} };\n}`;\n}\n","import { InstructionNode, pascalCase } from '@codama/nodes';\nimport { mapFragmentContent } from '@codama/renderers-core';\nimport { findProgramNodeFromPath, getLastNodeFromPath, NodePath } from '@codama/visitors-core';\n\nimport { Fragment, fragment, mergeFragments, RenderScope, use } from '../utils';\nimport { getInstructionAccountMetaFragment } from './instructionAccountMeta';\nimport { getInstructionAccountTypeParamFragment } from './instructionAccountTypeParam';\n\nexport function getInstructionTypeFragment(\n    scope: Pick<RenderScope, 'customInstructionData' | 'linkables' | 'nameApi'> & {\n        instructionPath: NodePath<InstructionNode>;\n    },\n): Fragment {\n    const { instructionPath, nameApi, customInstructionData } = scope;\n    const instructionNode = getLastNodeFromPath(instructionPath);\n    const programNode = findProgramNodeFromPath(instructionPath)!;\n    const hasAccounts = instructionNode.accounts.length > 0;\n    const customData = customInstructionData.get(instructionNode.name);\n    const hasData = !!customData || instructionNode.arguments.length > 0;\n\n    const instructionType = nameApi.instructionType(instructionNode.name);\n    const programAddressConstant = use(nameApi.programAddressConstant(programNode.name), 'generatedPrograms');\n\n    const accountTypeParams = mergeFragments(\n        instructionNode.accounts.map(account =>\n            getInstructionAccountTypeParamFragment({\n                ...scope,\n                allowAccountMeta: true,\n                instructionAccountPath: [...instructionPath, account],\n            }),\n        ),\n        cs => (cs.length > 0 ? `${cs.join(', ')}, ` : ''),\n    );\n\n    const data = hasData\n        ? fragment` & ${use('type InstructionWithData', 'solanaInstructions')}<${use('type ReadonlyUint8Array', 'solanaCodecsCore')}>`\n        : undefined;\n\n    const usesLegacyOptionalAccounts = instructionNode.optionalAccountStrategy === 'omitted';\n    const accountMetasFragment = mergeFragments(\n        instructionNode.accounts.map(account =>\n            mapFragmentContent(getInstructionAccountMetaFragment(account), c => {\n                const typeParam = `TAccount${pascalCase(account.name)}`;\n                const isLegacyOptional = account.isOptional && usesLegacyOptionalAccounts;\n                const type = `${typeParam} extends string ? ${c} : ${typeParam}`;\n                if (!isLegacyOptional) return type;\n                return `...(${typeParam} extends undefined ? [] : [${type}])`;\n            }),\n        ),\n        c => c.join(', '),\n    );\n\n    const instructionWithAccounts = use('type InstructionWithAccounts', 'solanaInstructions');\n    const accounts = hasAccounts\n        ? fragment` & ${instructionWithAccounts}<[${accountMetasFragment}, ...TRemainingAccounts]>`\n        : fragment` & ${instructionWithAccounts}<TRemainingAccounts>`;\n\n    return fragment`export type ${instructionType}<TProgram extends string = typeof ${programAddressConstant}, ${accountTypeParams}TRemainingAccounts extends readonly ${use('type AccountMeta', 'solanaInstructions')}<string>[] = []> =\n${use('type Instruction', 'solanaInstructions')}<TProgram>${data}${accounts};`;\n}\n","import { camelCase, isNode, isNodeFilter, PdaNode, PdaSeedNode } from '@codama/nodes';\nimport { findProgramNodeFromPath, getLastNodeFromPath, NodePath, visit } from '@codama/visitors-core';\n\nimport { Fragment, fragment, getDocblockFragment, mergeFragments, RenderScope, use } from '../utils';\n\nexport function getPdaFunctionFragment(\n    scope: Pick<RenderScope, 'nameApi' | 'typeManifestVisitor'> & {\n        pdaPath: NodePath<PdaNode>;\n    },\n): Fragment {\n    const pdaNode = getLastNodeFromPath(scope.pdaPath);\n    const seeds = parsePdaSeedNodes(pdaNode.seeds, scope);\n\n    return mergeFragments([getSeedInputTypeFragment(seeds, scope), getFunctionFragment(seeds, scope)], cs =>\n        cs.join('\\n\\n'),\n    );\n}\n\nfunction getSeedInputTypeFragment(\n    seeds: ParsedPdaSeedNode[],\n    scope: Pick<RenderScope, 'nameApi' | 'typeManifestVisitor'> & {\n        pdaPath: NodePath<PdaNode>;\n    },\n): Fragment | undefined {\n    const variableSeeds = seeds.filter(isNodeFilter('variablePdaSeedNode'));\n    if (variableSeeds.length === 0) return;\n\n    const pdaNode = getLastNodeFromPath(scope.pdaPath);\n    const seedTypeName = scope.nameApi.pdaSeedsType(pdaNode.name);\n    const seedAttributes = mergeFragments(\n        variableSeeds.map(seed => seed.inputAttribute),\n        cs => cs.join('\\n'),\n    );\n\n    return fragment`export type ${seedTypeName} = {\\n${seedAttributes}\\n};`;\n}\n\nfunction getFunctionFragment(\n    seeds: ParsedPdaSeedNode[],\n    scope: Pick<RenderScope, 'nameApi' | 'typeManifestVisitor'> & {\n        pdaPath: NodePath<PdaNode>;\n    },\n): Fragment {\n    const pdaNode = getLastNodeFromPath(scope.pdaPath);\n    const programNode = findProgramNodeFromPath(scope.pdaPath)!;\n\n    const addressType = use('type Address', 'solanaAddresses');\n    const pdaType = use('type ProgramDerivedAddress', 'solanaAddresses');\n    const getPdaFunction = use('getProgramDerivedAddress', 'solanaAddresses');\n\n    const seedTypeName = scope.nameApi.pdaSeedsType(pdaNode.name);\n    const findPdaFunction = scope.nameApi.pdaFindFunction(pdaNode.name);\n\n    const docs = getDocblockFragment(pdaNode.docs ?? [], true);\n    const hasVariableSeeds = seeds.filter(isNodeFilter('variablePdaSeedNode')).length > 0;\n    const seedArgument = hasVariableSeeds ? `seeds: ${seedTypeName}, ` : '';\n    const programAddress = pdaNode.programId ?? programNode.publicKey;\n    const encodedSeeds = mergeFragments(\n        seeds.map(s => s.encodedValue),\n        cs => cs.join(', '),\n    );\n\n    return fragment`${docs}export async function ${findPdaFunction}(${seedArgument}config: { programAddress?: ${addressType} | undefined } = {}): Promise<${pdaType}> {\n  const { programAddress = '${programAddress}' as ${addressType}<'${programAddress}'> } = config;\n  return await ${getPdaFunction}({ programAddress, seeds: [${encodedSeeds}]});\n}`;\n}\n\ntype ParsedPdaSeedNode = PdaSeedNode & {\n    encodedValue: Fragment;\n    inputAttribute?: Fragment;\n};\n\nfunction parsePdaSeedNodes(seeds: PdaSeedNode[], scope: Pick<RenderScope, 'typeManifestVisitor'>): ParsedPdaSeedNode[] {\n    return seeds.map(seed => {\n        if (isNode(seed, 'variablePdaSeedNode')) {\n            const name = camelCase(seed.name);\n            const docs = getDocblockFragment(seed.docs ?? [], true);\n            const { encoder, looseType } = visit(seed.type, scope.typeManifestVisitor);\n            return {\n                ...seed,\n                encodedValue: fragment`${encoder}.encode(seeds.${name})`,\n                inputAttribute: fragment`${docs}${name}: ${looseType};`,\n            };\n        }\n\n        if (isNode(seed.value, 'programIdValueNode')) {\n            const addressEncoder = use('getAddressEncoder', 'solanaAddresses');\n            return { ...seed, encodedValue: fragment`${addressEncoder}().encode(programAddress)` };\n        }\n\n        const { encoder } = visit(seed.type, scope.typeManifestVisitor);\n        const { value } = visit(seed.value, scope.typeManifestVisitor);\n        return { ...seed, encodedValue: fragment`${encoder}.encode(${value})` };\n    });\n}\n","import { PdaNode } from '@codama/nodes';\nimport { findProgramNodeFromPath, NodePath } from '@codama/visitors-core';\n\nimport { Fragment, RenderScope } from '../utils';\nimport { getPdaFunctionFragment } from './pdaFunction';\n\nexport function getPdaPageFragment(\n    scope: Pick<RenderScope, 'nameApi' | 'typeManifestVisitor'> & {\n        pdaPath: NodePath<PdaNode>;\n    },\n): Fragment {\n    if (!findProgramNodeFromPath(scope.pdaPath)) {\n        throw new Error('PDA must be visited inside a program.');\n    }\n\n    return getPdaFunctionFragment(scope);\n}\n","import { ProgramNode, resolveNestedTypeNode } from '@codama/nodes';\nimport { mapFragmentContent } from '@codama/renderers-core';\nimport { pipe } from '@codama/visitors-core';\n\nimport { addFragmentImports, Fragment, fragment, mergeFragments, RenderScope } from '../utils';\nimport { getDiscriminatorConditionFragment } from './discriminatorCondition';\n\nexport function getProgramAccountsFragment(\n    scope: Pick<RenderScope, 'nameApi' | 'typeManifestVisitor'> & {\n        programNode: ProgramNode;\n    },\n): Fragment | undefined {\n    if (scope.programNode.accounts.length === 0) return;\n    return mergeFragments(\n        [getProgramAccountsEnumFragment(scope), getProgramAccountsIdentifierFunctionFragment(scope)],\n        c => c.join('\\n\\n'),\n    );\n}\n\nfunction getProgramAccountsEnumFragment(\n    scope: Pick<RenderScope, 'nameApi'> & {\n        programNode: ProgramNode;\n    },\n): Fragment {\n    const { programNode, nameApi } = scope;\n    const programAccountsEnum = nameApi.programAccountsEnum(programNode.name);\n    const programAccountsEnumVariants = programNode.accounts.map(account =>\n        nameApi.programAccountsEnumVariant(account.name),\n    );\n    return fragment`export enum ${programAccountsEnum} { ${programAccountsEnumVariants.join(', ')} }`;\n}\n\nfunction getProgramAccountsIdentifierFunctionFragment(\n    scope: Pick<RenderScope, 'nameApi' | 'typeManifestVisitor'> & {\n        programNode: ProgramNode;\n    },\n): Fragment | undefined {\n    const { programNode, nameApi } = scope;\n    const accountsWithDiscriminators = programNode.accounts.filter(\n        account => (account.discriminators ?? []).length > 0,\n    );\n    const hasAccountDiscriminators = accountsWithDiscriminators.length > 0;\n    if (!hasAccountDiscriminators) return;\n\n    const programAccountsEnum = nameApi.programAccountsEnum(programNode.name);\n    const programAccountsIdentifierFunction = nameApi.programAccountsIdentifierFunction(programNode.name);\n\n    return pipe(\n        mergeFragments(\n            accountsWithDiscriminators.map((account): Fragment => {\n                const variant = nameApi.programAccountsEnumVariant(account.name);\n                return getDiscriminatorConditionFragment({\n                    ...scope,\n                    dataName: 'data',\n                    discriminators: account.discriminators ?? [],\n                    ifTrue: `return ${programAccountsEnum}.${variant};`,\n                    struct: resolveNestedTypeNode(account.data),\n                });\n            }),\n            c => c.join('\\n'),\n        ),\n        f =>\n            mapFragmentContent(\n                f,\n                discriminators =>\n                    `export function ${programAccountsIdentifierFunction}(` +\n                    `account: { data: ReadonlyUint8Array } | ReadonlyUint8Array` +\n                    `): ${programAccountsEnum} {\\n` +\n                    `const data = 'data' in account ? account.data : account;\\n` +\n                    `${discriminators}\\n` +\n                    `throw new Error(\"The provided account could not be identified as a ${programNode.name} account.\")\\n` +\n                    `}`,\n            ),\n        f => addFragmentImports(f, 'solanaCodecsCore', ['type ReadonlyUint8Array']),\n    );\n}\n","import { ProgramNode } from '@codama/nodes';\nimport { pipe } from '@codama/visitors-core';\n\nimport { addFragmentImports, Fragment, fragment, RenderScope } from '../utils';\n\nexport function getProgramConstantFragment(\n    scope: Pick<RenderScope, 'nameApi'> & { programNode: ProgramNode },\n): Fragment {\n    const { programNode, nameApi } = scope;\n    const programAddressConstant = nameApi.programAddressConstant(programNode.name);\n\n    return pipe(\n        fragment`export const ${programAddressConstant} = '${programNode.publicKey}' as Address<'${programNode.publicKey}'>;`,\n        f => addFragmentImports(f, 'solanaAddresses', ['type Address']),\n    );\n}\n","import {\n    getAllInstructionsWithSubs,\n    InstructionNode,\n    ProgramNode,\n    structTypeNodeFromInstructionArgumentNodes,\n} from '@codama/nodes';\nimport { mapFragmentContent } from '@codama/renderers-core';\nimport { pipe } from '@codama/visitors-core';\n\nimport { addFragmentImports, Fragment, fragment, mergeFragments, RenderScope, use } from '../utils';\nimport { getDiscriminatorConditionFragment } from './discriminatorCondition';\n\nexport function getProgramInstructionsFragment(\n    scope: Pick<RenderScope, 'nameApi' | 'renderParentInstructions' | 'typeManifestVisitor'> & {\n        programNode: ProgramNode;\n    },\n): Fragment | undefined {\n    if (scope.programNode.instructions.length === 0) return;\n\n    const allInstructions = getAllInstructionsWithSubs(scope.programNode, {\n        leavesOnly: !scope.renderParentInstructions,\n        subInstructionsFirst: true,\n    });\n    const scopeWithInstructions = { ...scope, allInstructions };\n    return mergeFragments(\n        [\n            getProgramInstructionsEnumFragment(scopeWithInstructions),\n            getProgramInstructionsIdentifierFunctionFragment(scopeWithInstructions),\n            getProgramInstructionsParsedUnionTypeFragment(scopeWithInstructions),\n        ],\n        c => c.join('\\n\\n'),\n    );\n}\n\nfunction getProgramInstructionsEnumFragment(\n    scope: Pick<RenderScope, 'nameApi'> & {\n        allInstructions: InstructionNode[];\n        programNode: ProgramNode;\n    },\n): Fragment {\n    const { programNode, allInstructions, nameApi } = scope;\n    const programInstructionsEnum = nameApi.programInstructionsEnum(programNode.name);\n    const programInstructionsEnumVariants = allInstructions.map(instruction =>\n        nameApi.programInstructionsEnumVariant(instruction.name),\n    );\n    return fragment`export enum ${programInstructionsEnum} { ${programInstructionsEnumVariants.join(', ')} }`;\n}\n\nfunction getProgramInstructionsIdentifierFunctionFragment(\n    scope: Pick<RenderScope, 'nameApi' | 'typeManifestVisitor'> & {\n        allInstructions: InstructionNode[];\n        programNode: ProgramNode;\n    },\n): Fragment | undefined {\n    const { programNode, nameApi, allInstructions } = scope;\n    const instructionsWithDiscriminators = allInstructions.filter(\n        instruction => (instruction.discriminators ?? []).length > 0,\n    );\n    const hasInstructionDiscriminators = instructionsWithDiscriminators.length > 0;\n    if (!hasInstructionDiscriminators) return;\n\n    const programInstructionsEnum = nameApi.programInstructionsEnum(programNode.name);\n    const programInstructionsIdentifierFunction = nameApi.programInstructionsIdentifierFunction(programNode.name);\n    const discriminatorsFragment = mergeFragments(\n        instructionsWithDiscriminators.map((instruction): Fragment => {\n            const variant = nameApi.programInstructionsEnumVariant(instruction.name);\n            return getDiscriminatorConditionFragment({\n                ...scope,\n                dataName: 'data',\n                discriminators: instruction.discriminators ?? [],\n                ifTrue: `return ${programInstructionsEnum}.${variant};`,\n                struct: structTypeNodeFromInstructionArgumentNodes(instruction.arguments),\n            });\n        }),\n        c => c.join('\\n'),\n    );\n\n    return pipe(\n        discriminatorsFragment,\n        f =>\n            mapFragmentContent(\n                f,\n                discriminators =>\n                    `export function ${programInstructionsIdentifierFunction}(` +\n                    `instruction: { data: ReadonlyUint8Array } | ReadonlyUint8Array` +\n                    `): ${programInstructionsEnum} {\\n` +\n                    `const data = 'data' in instruction ? instruction.data : instruction;\\n` +\n                    `${discriminators}\\n` +\n                    `throw new Error(\"The provided instruction could not be identified as a ${programNode.name} instruction.\")\\n` +\n                    `}`,\n            ),\n        f => addFragmentImports(f, 'solanaCodecsCore', ['type ReadonlyUint8Array']),\n    );\n}\n\nfunction getProgramInstructionsParsedUnionTypeFragment(\n    scope: Pick<RenderScope, 'nameApi'> & {\n        allInstructions: InstructionNode[];\n        programNode: ProgramNode;\n    },\n): Fragment {\n    const { programNode, allInstructions, nameApi } = scope;\n\n    const programAddress = programNode.publicKey;\n    const programInstructionsType = nameApi.programInstructionsParsedUnionType(programNode.name);\n    const programInstructionsEnum = nameApi.programInstructionsEnum(programNode.name);\n\n    const typeVariants = allInstructions.map((instruction): Fragment => {\n        const instructionEnumVariant = nameApi.programInstructionsEnumVariant(instruction.name);\n        const parsedInstructionType = use(\n            `type ${nameApi.instructionParsedType(instruction.name)}`,\n            'generatedInstructions',\n        );\n\n        return fragment`| { instructionType: ${programInstructionsEnum}.${instructionEnumVariant} } & ${parsedInstructionType}<TProgram>`;\n    });\n\n    return mergeFragments(\n        [\n            fragment`export type ${programInstructionsType}<TProgram extends string = '${programAddress}'> =`,\n            ...typeVariants,\n        ],\n        c => c.join('\\n'),\n    );\n}\n","import { ProgramNode } from '@codama/nodes';\n\nimport { Fragment, mergeFragments, RenderScope } from '../utils';\nimport { getProgramAccountsFragment } from './programAccounts';\nimport { getProgramConstantFragment } from './programConstant';\nimport { getProgramInstructionsFragment } from './programInstructions';\n\nexport function getProgramPageFragment(\n    scope: Pick<RenderScope, 'nameApi' | 'renderParentInstructions' | 'typeManifestVisitor'> & {\n        programNode: ProgramNode;\n    },\n): Fragment {\n    return mergeFragments(\n        [getProgramConstantFragment(scope), getProgramAccountsFragment(scope), getProgramInstructionsFragment(scope)],\n        cs => cs.join('\\n\\n'),\n    );\n}\n","import { AccountNode, DefinedTypeNode, InstructionNode, PdaNode, ProgramNode } from '@codama/nodes';\n\nimport { Fragment, fragment, getExportAllFragment, mergeFragments } from '../utils';\n\nexport function getRootIndexPageFragment(scope: {\n    accountsToExport: AccountNode[];\n    definedTypesToExport: DefinedTypeNode[];\n    instructionsToExport: InstructionNode[];\n    pdasToExport: PdaNode[];\n    programsToExport: ProgramNode[];\n}): Fragment {\n    const hasAnythingToExport =\n        scope.programsToExport.length > 0 ||\n        scope.accountsToExport.length > 0 ||\n        scope.instructionsToExport.length > 0 ||\n        scope.definedTypesToExport.length > 0;\n\n    if (!hasAnythingToExport) {\n        return fragment`export default {};`;\n    }\n\n    const programsWithErrorsToExport = scope.programsToExport.filter(p => p.errors.length > 0);\n\n    return mergeFragments(\n        [\n            scope.accountsToExport.length > 0 ? getExportAllFragment('./accounts') : undefined,\n            programsWithErrorsToExport.length > 0 ? getExportAllFragment('./errors') : undefined,\n            scope.instructionsToExport.length > 0 ? getExportAllFragment('./instructions') : undefined,\n            scope.pdasToExport.length > 0 ? getExportAllFragment('./pdas') : undefined,\n            scope.programsToExport.length > 0 ? getExportAllFragment('./programs') : undefined,\n            scope.definedTypesToExport.length > 0 ? getExportAllFragment('./types') : undefined,\n        ],\n        cs => cs.join('\\n'),\n    );\n}\n","import { pipe } from '@codama/visitors-core';\n\nimport { addFragmentImports, Fragment, fragment } from '../utils';\n\nexport function getSharedPageFragment(): Fragment {\n    const sharedPage = fragment`/**\n * Asserts that the given value is not null or undefined.\n * @internal\n */\nexport function expectSome<T>(value: T | null | undefined): T {\n  if (value === null || value === undefined) {\n    throw new Error('Expected a value but received null or undefined.');\n  }\n  return value;\n}\n\n/**\n * Asserts that the given value is a PublicKey.\n * @internal\n */\nexport function expectAddress<T extends string = string>(\n  value: Address<T> | ProgramDerivedAddress<T> | TransactionSigner<T> | null | undefined\n): Address<T> {\n  if (!value) {\n    throw new Error('Expected a Address.');\n  }\n  if (typeof value === 'object' && \"address\" in value) {\n    return value.address;\n  }\n  if (Array.isArray(value)) {\n    return value[0] as Address<T>;\n  }\n  return value as Address<T>;\n}\n\n/**\n * Asserts that the given value is a PDA.\n * @internal\n */\nexport function expectProgramDerivedAddress<T extends string = string>(\n  value: Address<T> | ProgramDerivedAddress<T> | TransactionSigner<T> | null | undefined\n): ProgramDerivedAddress<T> {\n  if (!value || !Array.isArray(value) || !isProgramDerivedAddress(value)) {\n    throw new Error('Expected a ProgramDerivedAddress.');\n  }\n  return value;\n}\n\n/**\n * Asserts that the given value is a TransactionSigner.\n * @internal\n */\nexport function expectTransactionSigner<T extends string = string>(\n  value: Address<T> | ProgramDerivedAddress<T> | TransactionSigner<T> | null | undefined\n): TransactionSigner<T> {\n  if (!value || !isTransactionSigner(value)) {\n    throw new Error('Expected a TransactionSigner.');\n  }\n  return value;\n}\n\n/**\n * Defines an instruction account to resolve.\n * @internal\n */\nexport type ResolvedAccount<T extends string = string, U extends Address<T> | ProgramDerivedAddress<T> | TransactionSigner<T> | null = Address<T> | ProgramDerivedAddress<T> | TransactionSigner<T> | null> = {\n  isWritable: boolean;\n  value: U;\n};\n\n /**\n * Defines an instruction that stores additional bytes on-chain.\n * @internal\n */\nexport type InstructionWithByteDelta = {\n  byteDelta: number;\n};\n\n/**\n* Get account metas and signers from resolved accounts.\n* @internal\n*/\nexport function getAccountMetaFactory(\n  programAddress: Address,\n  optionalAccountStrategy: 'omitted' | 'programId',\n) {\n  return (account: ResolvedAccount): AccountMeta | AccountSignerMeta | undefined => {\n    if (!account.value) {\n      if (optionalAccountStrategy === 'omitted') return;\n      return Object.freeze({ address: programAddress, role: AccountRole.READONLY });\n    }\n\n    const writableRole = account.isWritable ? AccountRole.WRITABLE : AccountRole.READONLY;\n    return Object.freeze({\n      address: expectAddress(account.value),\n      role: isTransactionSigner(account.value) ? upgradeRoleToSigner(writableRole) : writableRole,\n      ...(isTransactionSigner(account.value) ? { signer: account.value } : {})\n    });\n  };\n}\n\nexport function isTransactionSigner<TAddress extends string = string>(value: Address<TAddress> | ProgramDerivedAddress<TAddress> | TransactionSigner<TAddress>): value is TransactionSigner<TAddress> {\n  return !!value && typeof value === 'object' && 'address' in value && kitIsTransactionSigner(value);\n}`;\n\n    return pipe(\n        sharedPage,\n        f =>\n            addFragmentImports(f, 'solanaAddresses', [\n                'type Address',\n                'isProgramDerivedAddress',\n                'type ProgramDerivedAddress',\n            ]),\n        f => addFragmentImports(f, 'solanaInstructions', ['AccountRole', 'type AccountMeta', 'upgradeRoleToSigner']),\n        f =>\n            addFragmentImports(f, 'solanaSigners', [\n                'type AccountSignerMeta',\n                'isTransactionSigner as kitIsTransactionSigner',\n                'type TransactionSigner',\n            ]),\n    );\n}\n","import { isDataEnum, isNode, TypeNode } from '@codama/nodes';\n\nimport { Fragment, fragment, mergeFragments, RenderScope, use } from '../utils';\n\nexport function getTypeDiscriminatedUnionHelpersFragment(\n    scope: Pick<RenderScope, 'nameApi'> & { name: string; typeNode: TypeNode },\n): Fragment | undefined {\n    const { name, typeNode, nameApi } = scope;\n    const isDiscriminatedUnion = isNode(typeNode, 'enumTypeNode') && isDataEnum(typeNode);\n    if (!isDiscriminatedUnion) return;\n\n    const functionName = nameApi.discriminatedUnionFunction(name);\n    const isDiscriminatedUnionFunctionName = nameApi.isDiscriminatedUnionFunction(name);\n    const discriminatorName = nameApi.discriminatedUnionDiscriminator(name);\n    const strictName = nameApi.dataType(name);\n    const looseName = nameApi.dataArgsType(name);\n\n    const getVariantContentType = use('type GetDiscriminatedUnionVariantContent', 'solanaCodecsDataStructures');\n    const getVariantType = use('type GetDiscriminatedUnionVariant', 'solanaCodecsDataStructures');\n    const variantSignatures = mergeFragments(\n        typeNode.variants.map(variant => {\n            const variantName = nameApi.discriminatedUnionVariant(variant.name);\n            if (isNode(variant, 'enumStructVariantTypeNode')) {\n                return fragment`export function ${functionName}(kind: '${variantName}', data: ${getVariantContentType}<${looseName}, '${discriminatorName}', '${variantName}'>): ${getVariantType}<${looseName}, '${discriminatorName}', '${variantName}'>;`;\n            }\n            if (isNode(variant, 'enumTupleVariantTypeNode')) {\n                return fragment`export function ${functionName}(kind: '${variantName}', data: ${getVariantContentType}<${looseName}, '${discriminatorName}', '${variantName}'>['fields']): ${getVariantType}<${looseName}, '${discriminatorName}', '${variantName}'>;`;\n            }\n            return fragment`export function ${functionName}(kind: '${variantName}'): ${getVariantType}<${looseName}, '${discriminatorName}', '${variantName}'>;`;\n        }),\n        cs => (cs.length > 0 ? `${cs.join('\\n')}\\n` : ''),\n    );\n\n    return fragment`// Data Enum Helpers.\n${variantSignatures}export function ${functionName}<K extends ${looseName}['${discriminatorName}'], Data>(kind: K, data?: Data) {\n  return Array.isArray(data) ? { ${discriminatorName}: kind, fields: data } : { ${discriminatorName}: kind, ...(data ?? {}) };\n}\n\nexport function ${isDiscriminatedUnionFunctionName}<K extends ${strictName}['${discriminatorName}']>(kind: K, value: ${strictName}): value is ${strictName} & { ${discriminatorName}: K } {\n  return value.${discriminatorName} === kind;\n};\n`;\n}\n","import { DefinedTypeNode } from '@codama/nodes';\nimport { pipe, visit } from '@codama/visitors-core';\n\nimport { Fragment, mergeFragments, removeFragmentImports, RenderScope } from '../utils';\nimport { getTypeDiscriminatedUnionHelpersFragment } from './typeDiscriminatedUnionHelpers';\nimport { getTypeWithCodecFragment } from './typeWithCodec';\n\nexport function getTypePageFragment(\n    scope: Pick<RenderScope, 'nameApi' | 'typeManifestVisitor'> & { node: DefinedTypeNode; size: number | null },\n): Fragment {\n    const node = scope.node;\n    const manifest = visit(node, scope.typeManifestVisitor);\n    return pipe(\n        mergeFragments(\n            [\n                getTypeWithCodecFragment({ ...scope, manifest, name: node.name, node: node.type, typeDocs: node.docs }),\n                getTypeDiscriminatedUnionHelpersFragment({ ...scope, name: node.name, typeNode: node.type }),\n            ],\n            cs => cs.join('\\n\\n'),\n        ),\n        f =>\n            removeFragmentImports(f, 'generatedTypes', [\n                scope.nameApi.dataType(node.name),\n                scope.nameApi.dataArgsType(node.name),\n                scope.nameApi.encoderFunction(node.name),\n                scope.nameApi.decoderFunction(node.name),\n                scope.nameApi.codecFunction(node.name),\n            ]),\n    );\n}\n","import {\n    camelCase,\n    CamelCaseString,\n    CountNode,\n    isNode,\n    isNodeFilter,\n    isScalarEnum,\n    REGISTERED_TYPE_NODE_KINDS,\n    REGISTERED_VALUE_NODE_KINDS,\n    resolveNestedTypeNode,\n    structFieldTypeNode,\n    structTypeNode,\n    structTypeNodeFromInstructionArgumentNodes,\n    TypeNode,\n} from '@codama/nodes';\nimport { mapFragmentContent, setFragmentContent } from '@codama/renderers-core';\nimport {\n    extendVisitor,\n    findLastNodeFromPath,\n    LinkableDictionary,\n    NodeStack,\n    pipe,\n    recordNodeStackVisitor,\n    staticVisitor,\n    visit,\n    Visitor,\n} from '@codama/visitors-core';\n\nimport {\n    addFragmentImports,\n    Fragment,\n    fragment,\n    getBytesFromBytesValueNode,\n    getDocblockFragment,\n    GetImportFromFunction,\n    mergeFragments,\n    mergeTypeManifests,\n    NameApi,\n    ParsedCustomDataOptions,\n    TypeManifest,\n    typeManifest,\n    use,\n} from '../utils';\n\nexport type TypeManifestVisitor = ReturnType<typeof getTypeManifestVisitor>;\n\nexport function getTypeManifestVisitor(input: {\n    customAccountData: ParsedCustomDataOptions;\n    customInstructionData: ParsedCustomDataOptions;\n    getImportFrom: GetImportFromFunction;\n    linkables: LinkableDictionary;\n    nameApi: NameApi;\n    nonScalarEnums: CamelCaseString[];\n    stack?: NodeStack;\n}) {\n    const { nameApi, linkables, nonScalarEnums, customAccountData, customInstructionData, getImportFrom } = input;\n    const stack = input.stack ?? new NodeStack();\n    let parentName: { loose: string; strict: string } | null = null;\n\n    return pipe(\n        staticVisitor(() => typeManifest(), {\n            keys: [\n                ...REGISTERED_TYPE_NODE_KINDS,\n                ...REGISTERED_VALUE_NODE_KINDS,\n                'definedTypeLinkNode',\n                'definedTypeNode',\n                'accountNode',\n                'instructionNode',\n            ],\n        }),\n        visitor =>\n            extendVisitor(visitor, {\n                visitAccount(account, { self }) {\n                    parentName = {\n                        loose: nameApi.dataArgsType(account.name),\n                        strict: nameApi.dataType(account.name),\n                    };\n                    const link = customAccountData.get(account.name)?.linkNode;\n                    const manifest = link ? visit(link, self) : visit(account.data, self);\n                    parentName = null;\n                    return manifest;\n                },\n\n                visitAmountType(amountType, { self }) {\n                    return visit(amountType.number, self);\n                },\n\n                visitArrayType(arrayType, { self }) {\n                    const childManifest = visit(arrayType.item, self);\n                    const sizeManifest = getArrayLikeSizeOption(arrayType.count, self);\n                    const encoderOptions = sizeManifest.encoder ? fragment`, { ${sizeManifest.encoder} }` : '';\n                    const decoderOptions = sizeManifest.decoder ? fragment`, { ${sizeManifest.decoder} }` : '';\n\n                    return typeManifest({\n                        ...childManifest,\n                        decoder: fragment`${use('getArrayDecoder', 'solanaCodecsDataStructures')}(${childManifest.decoder}${decoderOptions})`,\n                        encoder: fragment`${use('getArrayEncoder', 'solanaCodecsDataStructures')}(${childManifest.encoder}${encoderOptions})`,\n                        looseType: fragment`Array<${childManifest.looseType}>`,\n                        strictType: fragment`Array<${childManifest.strictType}>`,\n                    });\n                },\n\n                visitArrayValue(node, { self }) {\n                    return mergeTypeManifests(\n                        node.items.map(v => visit(v, self)),\n                        { mergeValues: renders => `[${renders.join(', ')}]` },\n                    );\n                },\n\n                visitBooleanType(booleanType, { self }) {\n                    let sizeEncoder = fragment``;\n                    let sizeDecoder = fragment``;\n                    const resolvedSize = resolveNestedTypeNode(booleanType.size);\n                    if (resolvedSize.format !== 'u8' || resolvedSize.endian !== 'le') {\n                        const size = visit(booleanType.size, self);\n                        sizeEncoder = fragment`{ size: ${size.encoder} }`;\n                        sizeDecoder = fragment`{ size: ${size.decoder} }`;\n                    }\n\n                    return typeManifest({\n                        decoder: fragment`${use('getBooleanDecoder', 'solanaCodecsDataStructures')}(${sizeDecoder})`,\n                        encoder: fragment`${use('getBooleanEncoder', 'solanaCodecsDataStructures')}(${sizeEncoder})`,\n                        looseType: fragment`boolean`,\n                        strictType: fragment`boolean`,\n                    });\n                },\n\n                visitBooleanValue(node) {\n                    return typeManifest({ value: fragment`${JSON.stringify(node.boolean)}` });\n                },\n\n                visitBytesType() {\n                    const readonlyUint8Array = use('type ReadonlyUint8Array', 'solanaCodecsCore');\n                    return typeManifest({\n                        decoder: fragment`${use('getBytesDecoder', 'solanaCodecsDataStructures')}()`,\n                        encoder: fragment`${use('getBytesEncoder', 'solanaCodecsDataStructures')}()`,\n                        looseType: readonlyUint8Array,\n                        strictType: readonlyUint8Array,\n                    });\n                },\n\n                visitBytesValue(node) {\n                    const bytes = getBytesFromBytesValueNode(node);\n                    return typeManifest({ value: fragment`new Uint8Array([${Array.from(bytes).join(', ')}])` });\n                },\n\n                visitConstantValue(node, { self }) {\n                    if (isNode(node.type, 'bytesTypeNode') && isNode(node.value, 'bytesValueNode')) {\n                        return visit(node.value, self);\n                    }\n                    return typeManifest({\n                        value: fragment`${visit(node.type, self).encoder}.encode(${visit(node.value, self).value})`,\n                    });\n                },\n\n                visitDateTimeType(dateTimeType, { self }) {\n                    return visit(dateTimeType.number, self);\n                },\n\n                visitDefinedType(definedType, { self }) {\n                    parentName = {\n                        loose: nameApi.dataArgsType(definedType.name),\n                        strict: nameApi.dataType(definedType.name),\n                    };\n                    const manifest = visit(definedType.type, self);\n                    parentName = null;\n                    return manifest;\n                },\n\n                visitDefinedTypeLink(node) {\n                    const strictName = nameApi.dataType(node.name);\n                    const looseName = nameApi.dataArgsType(node.name);\n                    const encoderFunction = nameApi.encoderFunction(node.name);\n                    const decoderFunction = nameApi.decoderFunction(node.name);\n                    const importFrom = getImportFrom(node);\n\n                    return typeManifest({\n                        decoder: fragment`${use(decoderFunction, importFrom)}()`,\n                        encoder: fragment`${use(encoderFunction, importFrom)}()`,\n                        looseType: use(`type ${looseName}`, importFrom),\n                        strictType: use(`type ${strictName}`, importFrom),\n                    });\n                },\n\n                visitEnumEmptyVariantType(enumEmptyVariantType) {\n                    const discriminator = nameApi.discriminatedUnionDiscriminator(camelCase(parentName?.strict ?? ''));\n                    const name = nameApi.discriminatedUnionVariant(enumEmptyVariantType.name);\n                    const kindAttribute = `${discriminator}: \"${name}\"`;\n                    return typeManifest({\n                        decoder: fragment`['${name}', ${use('getUnitDecoder', 'solanaCodecsDataStructures')}()]`,\n                        encoder: fragment`['${name}', ${use('getUnitEncoder', 'solanaCodecsDataStructures')}()]`,\n                        looseType: fragment`{ ${kindAttribute} }`,\n                        strictType: fragment`{ ${kindAttribute} }`,\n                    });\n                },\n\n                visitEnumStructVariantType(enumStructVariantType, { self }) {\n                    const currentParentName = parentName;\n                    const discriminator = nameApi.discriminatedUnionDiscriminator(\n                        camelCase(currentParentName?.strict ?? ''),\n                    );\n                    const name = nameApi.discriminatedUnionVariant(enumStructVariantType.name);\n                    const kindAttribute = `${discriminator}: \"${name}\"`;\n\n                    parentName = null;\n                    const structManifest = visit(enumStructVariantType.struct, self);\n                    parentName = currentParentName;\n\n                    return typeManifest({\n                        ...structManifest,\n                        decoder: fragment`['${name}', ${structManifest.decoder}]`,\n                        encoder: fragment`['${name}', ${structManifest.encoder}]`,\n                        looseType: pipe(structManifest.looseType, f =>\n                            mapFragmentContent(f, c => `{ ${kindAttribute},${c.slice(1, -1)}}`),\n                        ),\n                        strictType: pipe(structManifest.strictType, f =>\n                            mapFragmentContent(f, c => `{ ${kindAttribute},${c.slice(1, -1)}}`),\n                        ),\n                    });\n                },\n\n                visitEnumTupleVariantType(enumTupleVariantType, { self }) {\n                    const currentParentName = parentName;\n                    const discriminator = nameApi.discriminatedUnionDiscriminator(\n                        camelCase(currentParentName?.strict ?? ''),\n                    );\n                    const name = nameApi.discriminatedUnionVariant(enumTupleVariantType.name);\n                    const kindAttribute = `${discriminator}: \"${name}\"`;\n                    const struct = structTypeNode([\n                        structFieldTypeNode({\n                            name: 'fields',\n                            type: enumTupleVariantType.tuple,\n                        }),\n                    ]);\n\n                    parentName = null;\n                    const structManifest = visit(struct, self);\n                    parentName = currentParentName;\n\n                    return typeManifest({\n                        ...structManifest,\n                        decoder: fragment`['${name}', ${structManifest.decoder}]`,\n                        encoder: fragment`['${name}', ${structManifest.encoder}]`,\n                        looseType: pipe(structManifest.looseType, f =>\n                            mapFragmentContent(f, c => `{ ${kindAttribute},${c.slice(1, -1)}}`),\n                        ),\n                        strictType: pipe(structManifest.strictType, f =>\n                            mapFragmentContent(f, c => `{ ${kindAttribute},${c.slice(1, -1)}}`),\n                        ),\n                    });\n                },\n\n                visitEnumType(enumType, { self }) {\n                    const currentParentName = parentName;\n                    const encoderOptions: Fragment[] = [];\n                    const decoderOptions: Fragment[] = [];\n\n                    const enumSize = resolveNestedTypeNode(enumType.size);\n                    if (enumSize.format !== 'u8' || enumSize.endian !== 'le') {\n                        const sizeManifest = visit(enumType.size, self);\n                        encoderOptions.push(fragment`size: ${sizeManifest.encoder}`);\n                        decoderOptions.push(fragment`size: ${sizeManifest.decoder}`);\n                    }\n\n                    const discriminator = nameApi.discriminatedUnionDiscriminator(\n                        camelCase(currentParentName?.strict ?? ''),\n                    );\n                    if (!isScalarEnum(enumType) && discriminator !== '__kind') {\n                        encoderOptions.push(fragment`discriminator: '${discriminator}'`);\n                        decoderOptions.push(fragment`discriminator: '${discriminator}'`);\n                    }\n\n                    const encoderOptionsFragment = mergeFragments(encoderOptions, cs =>\n                        cs.length > 0 ? `, { ${cs.join(', ')} }` : '',\n                    );\n                    const decoderOptionsFragment = mergeFragments(decoderOptions, cs =>\n                        cs.length > 0 ? `, { ${cs.join(', ')} }` : '',\n                    );\n\n                    if (isScalarEnum(enumType)) {\n                        if (currentParentName === null) {\n                            throw new Error(\n                                'Scalar enums cannot be inlined and must be introduced ' +\n                                    'via a defined type. Ensure you are not inlining a ' +\n                                    'defined type that is a scalar enum through a visitor.',\n                            );\n                        }\n                        const variantNames = enumType.variants.map(({ name }) => nameApi.enumVariant(name));\n                        return typeManifest({\n                            decoder: fragment`${use('getEnumDecoder', 'solanaCodecsDataStructures')}(${currentParentName.strict}${decoderOptionsFragment})`,\n                            encoder: fragment`${use('getEnumEncoder', 'solanaCodecsDataStructures')}(${currentParentName.strict}${encoderOptionsFragment})`,\n                            isEnum: true,\n                            looseType: fragment`{ ${variantNames.join(', ')} }`,\n                            strictType: fragment`{ ${variantNames.join(', ')} }`,\n                        });\n                    }\n\n                    const mergedManifest = mergeTypeManifests(\n                        enumType.variants.map(variant => visit(variant, self)),\n                        {\n                            mergeCodecs: renders => renders.join(', '),\n                            mergeTypes: renders => renders.join(' | '),\n                        },\n                    );\n\n                    return typeManifest({\n                        ...mergedManifest,\n                        decoder: fragment`${use('getDiscriminatedUnionDecoder', 'solanaCodecsDataStructures')}([${mergedManifest.decoder}]${decoderOptionsFragment})`,\n                        encoder: fragment`${use('getDiscriminatedUnionEncoder', 'solanaCodecsDataStructures')}([${mergedManifest.encoder}]${encoderOptionsFragment})`,\n                    });\n                },\n\n                visitEnumValue(node, { self }) {\n                    const manifest = typeManifest();\n                    const enumName = nameApi.dataType(node.enum.name);\n                    const enumFunction = nameApi.discriminatedUnionFunction(node.enum.name);\n                    const importFrom = getImportFrom(node.enum);\n\n                    const enumNode = linkables.get([...stack.getPath(), node.enum])?.type;\n                    const isScalar =\n                        enumNode && isNode(enumNode, 'enumTypeNode')\n                            ? isScalarEnum(enumNode)\n                            : !nonScalarEnums.includes(node.enum.name);\n\n                    if (!node.value && isScalar) {\n                        const variantName = nameApi.enumVariant(node.variant);\n                        return typeManifest({\n                            ...manifest,\n                            value: pipe(\n                                manifest.value,\n                                f => setFragmentContent(f, `${enumName}.${variantName}`),\n                                f => addFragmentImports(f, importFrom, [enumName]),\n                            ),\n                        });\n                    }\n\n                    const variantName = nameApi.discriminatedUnionVariant(node.variant);\n                    if (!node.value) {\n                        return typeManifest({\n                            ...manifest,\n                            value: pipe(\n                                manifest.value,\n                                f => setFragmentContent(f, `${enumFunction}('${variantName}')`),\n                                f => addFragmentImports(f, importFrom, [enumFunction]),\n                            ),\n                        });\n                    }\n\n                    return typeManifest({\n                        ...manifest,\n                        value: pipe(\n                            visit(node.value, self).value,\n                            f => mapFragmentContent(f, c => `${enumFunction}('${variantName}', ${c})`),\n                            f => addFragmentImports(f, importFrom, [enumFunction]),\n                        ),\n                    });\n                },\n\n                visitFixedSizeType(node, { self }) {\n                    const manifest = visit(node.type, self);\n                    return typeManifest({\n                        ...manifest,\n                        decoder: fragment`${use('fixDecoderSize', 'solanaCodecsCore')}(${manifest.decoder}, ${node.size})`,\n                        encoder: fragment`${use('fixEncoderSize', 'solanaCodecsCore')}(${manifest.encoder}, ${node.size})`,\n                    });\n                },\n\n                visitHiddenPrefixType(node, { self }) {\n                    const manifest = visit(node.type, self);\n                    const prefixes = node.prefix.map(c => visit(c, self).value);\n                    const prefixEncoders = pipe(\n                        mergeFragments(prefixes, cs => cs.map(c => `getConstantEncoder(${c})`).join(', ')),\n                        f => addFragmentImports(f, 'solanaCodecsCore', ['getConstantEncoder']),\n                    );\n                    const prefixDecoders = pipe(\n                        mergeFragments(prefixes, cs => cs.map(c => `getConstantDecoder(${c})`).join(', ')),\n                        f => addFragmentImports(f, 'solanaCodecsCore', ['getConstantDecoder']),\n                    );\n\n                    return typeManifest({\n                        ...manifest,\n                        decoder: fragment`${use('getHiddenPrefixDecoder', 'solanaCodecsDataStructures')}(${manifest.decoder}, [${prefixDecoders}])`,\n                        encoder: fragment`${use('getHiddenPrefixEncoder', 'solanaCodecsDataStructures')}(${manifest.encoder}, [${prefixEncoders}])`,\n                    });\n                },\n\n                visitHiddenSuffixType(node, { self }) {\n                    const manifest = visit(node.type, self);\n                    const suffixes = node.suffix.map(c => visit(c, self).value);\n                    const suffixEncoders = pipe(\n                        mergeFragments(suffixes, cs => cs.map(c => `getConstantEncoder(${c})`).join(', ')),\n                        f => addFragmentImports(f, 'solanaCodecsCore', ['getConstantEncoder']),\n                    );\n                    const suffixDecoders = pipe(\n                        mergeFragments(suffixes, cs => cs.map(c => `getConstantDecoder(${c})`).join(', ')),\n                        f => addFragmentImports(f, 'solanaCodecsCore', ['getConstantDecoder']),\n                    );\n\n                    return typeManifest({\n                        ...manifest,\n                        decoder: fragment`${use('getHiddenSuffixDecoder', 'solanaCodecsDataStructures')}(${manifest.decoder}, [${suffixDecoders}])`,\n                        encoder: fragment`${use('getHiddenSuffixEncoder', 'solanaCodecsDataStructures')}(${manifest.encoder}, [${suffixEncoders}])`,\n                    });\n                },\n\n                visitInstruction(instruction, { self }) {\n                    const instructionDataName = nameApi.instructionDataType(instruction.name);\n                    parentName = {\n                        loose: nameApi.dataArgsType(instructionDataName),\n                        strict: nameApi.dataType(instructionDataName),\n                    };\n                    const link = customInstructionData.get(instruction.name)?.linkNode;\n                    const struct = structTypeNodeFromInstructionArgumentNodes(instruction.arguments);\n                    const manifest = link ? visit(link, self) : visit(struct, self);\n                    parentName = null;\n                    return manifest;\n                },\n\n                visitMapEntryValue(node, { self }) {\n                    return mergeTypeManifests([visit(node.key, self), visit(node.value, self)], {\n                        mergeValues: renders => `[${renders.join(', ')}]`,\n                    });\n                },\n\n                visitMapType(mapType, { self }) {\n                    const key = visit(mapType.key, self);\n                    const value = visit(mapType.value, self);\n                    const mergedManifest = mergeTypeManifests([key, value], {\n                        mergeCodecs: ([k, v]) => `${k}, ${v}`,\n                        mergeTypes: ([k, v]) => `Map<${k}, ${v}>`,\n                    });\n                    const sizeManifest = getArrayLikeSizeOption(mapType.count, self);\n                    const encoderOptions = sizeManifest.encoder ? fragment`, { ${sizeManifest.encoder} }` : '';\n                    const decoderOptions = sizeManifest.decoder ? fragment`, { ${sizeManifest.decoder} }` : '';\n\n                    return typeManifest({\n                        ...mergedManifest,\n                        decoder: fragment`${use('getMapDecoder', 'solanaCodecsDataStructures')}(${mergedManifest.decoder}${decoderOptions})`,\n                        encoder: fragment`${use('getMapEncoder', 'solanaCodecsDataStructures')}(${mergedManifest.encoder}${encoderOptions})`,\n                    });\n                },\n\n                visitMapValue(node, { self }) {\n                    const entryFragments = node.entries.map(entry => visit(entry, self));\n                    return mergeTypeManifests(entryFragments, {\n                        mergeValues: renders => `new Map([${renders.join(', ')}])`,\n                    });\n                },\n\n                visitNoneValue() {\n                    return typeManifest({\n                        value: fragment`${use('none', 'solanaOptions')}()`,\n                    });\n                },\n\n                visitNumberType(numberType) {\n                    const encoderFunction = use(nameApi.encoderFunction(numberType.format), 'solanaCodecsNumbers');\n                    const decoderFunction = use(nameApi.decoderFunction(numberType.format), 'solanaCodecsNumbers');\n                    const isBigNumber = ['u64', 'u128', 'i64', 'i128'].includes(numberType.format);\n                    const endianness =\n                        numberType.endian === 'be'\n                            ? fragment`{ endian: ${use('Endian', 'solanaCodecsNumbers')}.Big }`\n                            : '';\n                    return typeManifest({\n                        decoder: fragment`${decoderFunction}(${endianness})`,\n                        encoder: fragment`${encoderFunction}(${endianness})`,\n                        looseType: fragment`${isBigNumber ? 'number | bigint' : 'number'}`,\n                        strictType: fragment`${isBigNumber ? 'bigint' : 'number'}`,\n                    });\n                },\n\n                visitNumberValue(node) {\n                    return typeManifest({ value: fragment`${JSON.stringify(node.number)}` });\n                },\n\n                visitOptionType(optionType, { self }) {\n                    const childManifest = visit(optionType.item, self);\n                    const encoderOptions: Fragment[] = [];\n                    const decoderOptions: Fragment[] = [];\n\n                    // Prefix option.\n                    const optionPrefix = resolveNestedTypeNode(optionType.prefix);\n                    if (optionPrefix.format !== 'u8' || optionPrefix.endian !== 'le') {\n                        const prefixManifest = visit(optionType.prefix, self);\n                        encoderOptions.push(fragment`prefix: ${prefixManifest.encoder}`);\n                        decoderOptions.push(fragment`prefix: ${prefixManifest.decoder}`);\n                    }\n\n                    // Fixed option.\n                    if (optionType.fixed) {\n                        encoderOptions.push(fragment`noneValue: \"zeroes\"`);\n                        decoderOptions.push(fragment`noneValue: \"zeroes\"`);\n                    }\n\n                    const encoderOptionsFragment = mergeFragments(encoderOptions, cs =>\n                        cs.length > 0 ? `, { ${cs.join(', ')} }` : '',\n                    );\n                    const decoderOptionsFragment = mergeFragments(decoderOptions, cs =>\n                        cs.length > 0 ? `, { ${cs.join(', ')} }` : '',\n                    );\n\n                    return typeManifest({\n                        ...childManifest,\n                        decoder: fragment`${use('getOptionDecoder', 'solanaOptions')}(${childManifest.decoder}${decoderOptionsFragment})`,\n                        encoder: fragment`${use('getOptionEncoder', 'solanaOptions')}(${childManifest.encoder}${encoderOptionsFragment})`,\n                        looseType: fragment`${use('type OptionOrNullable', 'solanaOptions')}<${childManifest.looseType}>`,\n                        strictType: fragment`${use('type Option', 'solanaOptions')}<${childManifest.strictType}>`,\n                    });\n                },\n\n                visitPostOffsetType(node, { self }) {\n                    const manifest = visit(node.type, self);\n                    if (node.strategy === 'padded') {\n                        return typeManifest({\n                            ...manifest,\n                            decoder: fragment`${use('padRightDecoder', 'solanaCodecsCore')}(${manifest.decoder}, ${node.offset})`,\n                            encoder: fragment`${use('padRightEncoder', 'solanaCodecsCore')}(${manifest.encoder}, ${node.offset})`,\n                        });\n                    }\n\n                    const fn = (() => {\n                        switch (node.strategy) {\n                            case 'absolute':\n                                return node.offset < 0\n                                    ? `({ wrapBytes }) => wrapBytes(${node.offset})`\n                                    : `() => ${node.offset}`;\n                            case 'preOffset':\n                                return node.offset < 0\n                                    ? `({ preOffset }) => preOffset ${node.offset}`\n                                    : `({ preOffset }) => preOffset + ${node.offset}`;\n                            case 'relative':\n                            default:\n                                return node.offset < 0\n                                    ? `({ postOffset }) => postOffset ${node.offset}`\n                                    : `({ postOffset }) => postOffset + ${node.offset}`;\n                        }\n                    })();\n\n                    return typeManifest({\n                        ...manifest,\n                        decoder: fragment`${use('offsetDecoder', 'solanaCodecsCore')}(${manifest.decoder}, { postOffset: ${fn} })`,\n                        encoder: fragment`${use('offsetEncoder', 'solanaCodecsCore')}(${manifest.encoder}, { postOffset: ${fn} })`,\n                    });\n                },\n\n                visitPreOffsetType(node, { self }) {\n                    const manifest = visit(node.type, self);\n                    if (node.strategy === 'padded') {\n                        return typeManifest({\n                            ...manifest,\n                            decoder: fragment`${use('padLeftDecoder', 'solanaCodecsCore')}(${manifest.decoder}, ${node.offset})`,\n                            encoder: fragment`${use('padLeftEncoder', 'solanaCodecsCore')}(${manifest.encoder}, ${node.offset})`,\n                        });\n                    }\n\n                    const fn = (() => {\n                        switch (node.strategy) {\n                            case 'absolute':\n                                return node.offset < 0\n                                    ? `({ wrapBytes }) => wrapBytes(${node.offset})`\n                                    : `() => ${node.offset}`;\n                            case 'relative':\n                            default:\n                                return node.offset < 0\n                                    ? `({ preOffset }) => preOffset ${node.offset}`\n                                    : `({ preOffset }) => preOffset + ${node.offset}`;\n                        }\n                    })();\n\n                    return typeManifest({\n                        ...manifest,\n                        decoder: fragment`${use('offsetDecoder', 'solanaCodecsCore')}(${manifest.decoder}, { preOffset: ${fn} })`,\n                        encoder: fragment`${use('offsetEncoder', 'solanaCodecsCore')}(${manifest.encoder}, { preOffset: ${fn} })`,\n                    });\n                },\n\n                visitPublicKeyType() {\n                    return typeManifest({\n                        decoder: fragment`${use('getAddressDecoder', 'solanaAddresses')}()`,\n                        encoder: fragment`${use('getAddressEncoder', 'solanaAddresses')}()`,\n                        looseType: use('type Address', 'solanaAddresses'),\n                        strictType: use('type Address', 'solanaAddresses'),\n                    });\n                },\n\n                visitPublicKeyValue(node) {\n                    return typeManifest({\n                        value: fragment`${use('address', 'solanaAddresses')}(\"${node.publicKey}\")`,\n                    });\n                },\n\n                visitRemainderOptionType(node, { self }) {\n                    const childManifest = visit(node.item, self);\n                    const encoderOptions: string[] = ['prefix: null'];\n                    const decoderOptions: string[] = ['prefix: null'];\n\n                    const encoderOptionsAsString =\n                        encoderOptions.length > 0 ? `, { ${encoderOptions.join(', ')} }` : '';\n                    const decoderOptionsAsString =\n                        decoderOptions.length > 0 ? `, { ${decoderOptions.join(', ')} }` : '';\n\n                    return typeManifest({\n                        ...childManifest,\n                        decoder: fragment`${use('getOptionDecoder', 'solanaOptions')}(${childManifest.decoder}${decoderOptionsAsString})`,\n                        encoder: fragment`${use('getOptionEncoder', 'solanaOptions')}(${childManifest.encoder}${encoderOptionsAsString})`,\n                        looseType: fragment`${use('type OptionOrNullable', 'solanaOptions')}<${childManifest.looseType}>`,\n                        strictType: fragment`${use('type Option', 'solanaOptions')}<${childManifest.strictType}>`,\n                    });\n                },\n\n                visitSentinelType(node, { self }) {\n                    const manifest = visit(node.type, self);\n                    const sentinel = visit(node.sentinel, self).value;\n                    return typeManifest({\n                        ...manifest,\n                        decoder: fragment`${use('addDecoderSentinel', 'solanaCodecsCore')}(${manifest.decoder}, ${sentinel})`,\n                        encoder: fragment`${use('addEncoderSentinel', 'solanaCodecsCore')}(${manifest.encoder}, ${sentinel})`,\n                    });\n                },\n\n                visitSetType(setType, { self }) {\n                    const childManifest = visit(setType.item, self);\n                    const sizeManifest = getArrayLikeSizeOption(setType.count, self);\n                    const encoderOptions = sizeManifest.encoder ? fragment`, { ${sizeManifest.encoder} }` : '';\n                    const decoderOptions = sizeManifest.decoder ? fragment`, { ${sizeManifest.decoder} }` : '';\n\n                    return typeManifest({\n                        ...childManifest,\n                        decoder: fragment`${use('getSetDecoder', 'solanaCodecsDataStructures')}(${childManifest.decoder}${decoderOptions})`,\n                        encoder: fragment`${use('getSetEncoder', 'solanaCodecsDataStructures')}(${childManifest.encoder}${encoderOptions})`,\n                        looseType: fragment`Set<${childManifest.looseType}>`,\n                        strictType: fragment`Set<${childManifest.strictType}>`,\n                    });\n                },\n\n                visitSetValue(node, { self }) {\n                    return mergeTypeManifests(\n                        node.items.map(v => visit(v, self)),\n                        { mergeValues: renders => `new Set([${renders.join(', ')}])` },\n                    );\n                },\n\n                visitSizePrefixType(node, { self }) {\n                    const manifest = visit(node.type, self);\n                    const prefix = visit(node.prefix, self);\n\n                    return typeManifest({\n                        ...manifest,\n                        decoder: fragment`${use('addDecoderSizePrefix', 'solanaCodecsCore')}(${manifest.decoder}, ${prefix.decoder})`,\n                        encoder: fragment`${use('addEncoderSizePrefix', 'solanaCodecsCore')}(${manifest.encoder}, ${prefix.encoder})`,\n                    });\n                },\n\n                visitSolAmountType({ number }, { self }) {\n                    const numberManifest = visit(number, self);\n\n                    return typeManifest({\n                        ...numberManifest,\n                        decoder: fragment`${use('getLamportsDecoder', 'solanaRpcTypes')}(${numberManifest.decoder})`,\n                        encoder: fragment`${use('getLamportsEncoder', 'solanaRpcTypes')}(${numberManifest.encoder})`,\n                        looseType: use('type Lamports', 'solanaRpcTypes'),\n                        strictType: use('type Lamports', 'solanaRpcTypes'),\n                    });\n                },\n\n                visitSomeValue(node, { self }) {\n                    const innerValue = visit(node.value, self).value;\n                    return typeManifest({\n                        value: fragment`${use('some', 'solanaOptions')}(${innerValue})`,\n                    });\n                },\n\n                visitStringType(stringType) {\n                    const [encoder, decoder] = (() => {\n                        switch (stringType.encoding) {\n                            case 'base16':\n                                return ['getBase16Encoder', 'getBase16Decoder'];\n                            case 'base58':\n                                return ['getBase58Encoder', 'getBase58Decoder'];\n                            case 'base64':\n                                return ['getBase64Encoder', 'getBase64Decoder'];\n                            case 'utf8':\n                                return ['getUtf8Encoder', 'getUtf8Decoder'];\n                            default:\n                                throw new Error(`Unsupported string encoding: ${stringType.encoding as string}`);\n                        }\n                    })();\n\n                    return typeManifest({\n                        decoder: fragment`${use(decoder, 'solanaCodecsStrings')}()`,\n                        encoder: fragment`${use(encoder, 'solanaCodecsStrings')}()`,\n                        looseType: fragment`string`,\n                        strictType: fragment`string`,\n                    });\n                },\n\n                visitStringValue(node) {\n                    return typeManifest({\n                        value: fragment`${JSON.stringify(node.string)}`,\n                    });\n                },\n\n                visitStructFieldType(structFieldType, { self }) {\n                    const name = camelCase(structFieldType.name);\n                    const originalChildManifest = visit(structFieldType.type, self);\n                    let docs = getDocblockFragment(structFieldType.docs ?? [], true);\n                    docs = docs ? fragment`\\n${docs}` : docs;\n                    const childManifest = typeManifest({\n                        ...originalChildManifest,\n                        decoder: fragment`['${name}', ${originalChildManifest.decoder}]`,\n                        encoder: fragment`['${name}', ${originalChildManifest.encoder}]`,\n                        looseType: fragment`${docs}${name}: ${originalChildManifest.looseType}; `,\n                        strictType: fragment`${docs}${name}: ${originalChildManifest.strictType}; `,\n                    });\n\n                    // No default value.\n                    if (!structFieldType.defaultValue) {\n                        return childManifest;\n                    }\n\n                    // Optional default value.\n                    if (structFieldType.defaultValueStrategy !== 'omitted') {\n                        return typeManifest({\n                            ...childManifest,\n                            looseType: fragment`${docs}${name}?: ${originalChildManifest.looseType}; `,\n                        });\n                    }\n\n                    // Omitted default value.\n                    return typeManifest({ ...childManifest, looseType: fragment`` });\n                },\n\n                visitStructFieldValue(node, { self }) {\n                    const innerValue = visit(node.value, self).value;\n                    return typeManifest({\n                        value: fragment`${node.name}: ${innerValue}`,\n                    });\n                },\n\n                visitStructType(structType, { self }) {\n                    const optionalFields = structType.fields.filter(f => !!f.defaultValue);\n\n                    const mergedManifest = pipe(\n                        mergeTypeManifests(\n                            structType.fields.map(field => visit(field, self)),\n                            {\n                                mergeCodecs: renders => `([${renders.join(', ')}])`,\n                                mergeTypes: renders => `{ ${renders.join('')} }`,\n                            },\n                        ),\n                        manifest =>\n                            typeManifest({\n                                ...manifest,\n                                decoder: fragment`${use('getStructDecoder', 'solanaCodecsDataStructures')}${manifest.decoder}`,\n                                encoder: fragment`${use('getStructEncoder', 'solanaCodecsDataStructures')}${manifest.encoder}`,\n                            }),\n                    );\n\n                    if (optionalFields.length === 0) {\n                        return mergedManifest;\n                    }\n\n                    // Check if we are inside an instruction or account to use discriminator constants when available.\n                    const parentPath = stack.getPath();\n                    const instructionNode = findLastNodeFromPath(parentPath, 'instructionNode');\n                    const accountNode = findLastNodeFromPath(parentPath, 'accountNode');\n                    const discriminatorPrefix = instructionNode ? instructionNode.name : accountNode?.name;\n                    const discriminators =\n                        (instructionNode ? instructionNode.discriminators : accountNode?.discriminators) ?? [];\n                    const fieldDiscriminators = discriminators.filter(isNodeFilter('fieldDiscriminatorNode'));\n\n                    const defaultValues = mergeFragments(\n                        optionalFields.map((f): Fragment => {\n                            const key = camelCase(f.name);\n\n                            // If the field has an associated discriminator node, use the constant value instead.\n                            if (fieldDiscriminators.some(d => d.name === f.name)) {\n                                const constantName = nameApi.constant(camelCase(`${discriminatorPrefix}_${f.name}`));\n                                return f.defaultValueStrategy === 'omitted'\n                                    ? fragment`${key}: ${constantName}`\n                                    : fragment`${key}: value.${key} ?? ${constantName}`;\n                            }\n\n                            const defaultValue = f.defaultValue as NonNullable<typeof f.defaultValue>;\n                            const value = visit(defaultValue, self).value;\n                            return f.defaultValueStrategy === 'omitted'\n                                ? fragment`${key}: ${value}`\n                                : fragment`${key}: value.${key} ?? ${value}`;\n                        }),\n                        cs => cs.join(', '),\n                    );\n\n                    return typeManifest({\n                        ...mergedManifest,\n                        encoder: fragment`${use('transformEncoder', 'solanaCodecsCore')}(${mergedManifest.encoder}, (value) => ({ ...value, ${defaultValues} }))`,\n                    });\n                },\n\n                visitStructValue(node, { self }) {\n                    return mergeTypeManifests(\n                        node.fields.map(field => visit(field, self)),\n                        { mergeValues: renders => `{ ${renders.join(', ')} }` },\n                    );\n                },\n\n                visitTupleType(tupleType, { self }) {\n                    const items = tupleType.items.map(item => visit(item, self));\n                    const mergedManifest = mergeTypeManifests(items, {\n                        mergeCodecs: codecs => `[${codecs.join(', ')}]`,\n                        mergeTypes: types => `readonly [${types.join(', ')}]`,\n                    });\n\n                    return typeManifest({\n                        ...mergedManifest,\n                        decoder: fragment`${use('getTupleDecoder', 'solanaCodecsDataStructures')}(${mergedManifest.decoder})`,\n                        encoder: fragment`${use('getTupleEncoder', 'solanaCodecsDataStructures')}(${mergedManifest.encoder})`,\n                    });\n                },\n\n                visitTupleValue(node, { self }) {\n                    return mergeTypeManifests(\n                        node.items.map(v => visit(v, self)),\n                        { mergeValues: renders => `[${renders.join(', ')}]` },\n                    );\n                },\n\n                visitZeroableOptionType(node, { self }) {\n                    const childManifest = visit(node.item, self);\n                    const encoderOptions: Fragment[] = [fragment`prefix: null`];\n                    const decoderOptions: Fragment[] = [fragment`prefix: null`];\n\n                    // Zero-value option.\n                    if (node.zeroValue) {\n                        const zeroValueManifest = visit(node.zeroValue, self);\n                        encoderOptions.push(fragment`noneValue: ${zeroValueManifest.value}`);\n                        decoderOptions.push(fragment`noneValue: ${zeroValueManifest.value}`);\n                    } else {\n                        encoderOptions.push(fragment`noneValue: \"zeroes\"`);\n                        decoderOptions.push(fragment`noneValue: \"zeroes\"`);\n                    }\n\n                    const encoderOptionsFragment = mergeFragments(encoderOptions, cs =>\n                        cs.length > 0 ? `, { ${cs.join(', ')} }` : '',\n                    );\n                    const decoderOptionsFragment = mergeFragments(decoderOptions, cs =>\n                        cs.length > 0 ? `, { ${cs.join(', ')} }` : '',\n                    );\n\n                    return typeManifest({\n                        ...childManifest,\n                        decoder: fragment`${use('getOptionDecoder', 'solanaOptions')}(${childManifest.decoder}${decoderOptionsFragment})`,\n                        encoder: fragment`${use('getOptionEncoder', 'solanaOptions')}(${childManifest.encoder}${encoderOptionsFragment})`,\n                        looseType: fragment`${use('type OptionOrNullable', 'solanaOptions')}<${childManifest.looseType}>`,\n                        strictType: fragment`${use('type Option', 'solanaOptions')}<${childManifest.strictType}>`,\n                    });\n                },\n            }),\n        visitor => recordNodeStackVisitor(visitor, stack),\n    );\n}\n\nfunction getArrayLikeSizeOption(\n    count: CountNode,\n    visitor: Visitor<TypeManifest, TypeNode['kind']>,\n): {\n    decoder: Fragment | undefined;\n    encoder: Fragment | undefined;\n} {\n    if (isNode(count, 'fixedCountNode')) {\n        return {\n            decoder: fragment`size: ${count.value}`,\n            encoder: fragment`size: ${count.value}`,\n        };\n    }\n    if (isNode(count, 'remainderCountNode')) {\n        return {\n            decoder: fragment`size: 'remainder'`,\n            encoder: fragment`size: 'remainder'`,\n        };\n    }\n    const prefix = resolveNestedTypeNode(count.prefix);\n    if (prefix.format === 'u32' && prefix.endian === 'le') {\n        return { decoder: undefined, encoder: undefined };\n    }\n    const prefixManifest = visit(count.prefix, visitor);\n    return {\n        decoder: pipe(prefixManifest.decoder, f => mapFragmentContent(f, c => `size: ${c}`)),\n        encoder: pipe(prefixManifest.encoder, f => mapFragmentContent(f, c => `size: ${c}`)),\n    };\n}\n","import { deleteDirectory, mapRenderMapContentAsync, writeRenderMap } from '@codama/renderers-core';\nimport { rootNodeVisitor, visit } from '@codama/visitors-core';\nimport { Plugin } from 'prettier';\nimport * as estreePlugin from 'prettier/plugins/estree';\nimport * as typeScriptPlugin from 'prettier/plugins/typescript';\nimport { format } from 'prettier/standalone';\n\nimport { RenderOptions } from '../utils';\nimport { getRenderMapVisitor } from './getRenderMapVisitor';\n\ntype PrettierOptions = Parameters<typeof format>[1];\n\nconst DEFAULT_PRETTIER_OPTIONS: PrettierOptions = {\n    arrowParens: 'always',\n    parser: 'typescript',\n    plugins: [estreePlugin as Plugin<unknown>, typeScriptPlugin],\n    printWidth: 80,\n    semi: true,\n    singleQuote: true,\n    tabWidth: 2,\n    trailingComma: 'es5',\n    useTabs: false,\n};\n\nexport function renderVisitor(path: string, options: RenderOptions = {}) {\n    return rootNodeVisitor(async root => {\n        // Delete existing generated folder.\n        if (options.deleteFolderBeforeRendering ?? true) {\n            deleteDirectory(path);\n        }\n\n        // Render the new files.\n        let renderMap = visit(root, getRenderMapVisitor(options));\n\n        // Format the code.\n        if (options.formatCode ?? true) {\n            const prettierOptions = { ...DEFAULT_PRETTIER_OPTIONS, ...options.prettierOptions };\n            renderMap = await mapRenderMapContentAsync(renderMap, code => format(code, prettierOptions));\n        }\n\n        writeRenderMap(renderMap, path);\n    });\n}\n"],"mappings":"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","names":["module","fragment","module","import_nodes","import_renderers_core","import_visitors_core","import_visitors_core","import_nodes","import_nodes","typeManifest","import_nodes","import_visitors_core","import_nodes","import_visitors_core","typeManifest","import_visitors_core","import_nodes","import_visitors_core","import_nodes","import_nodes","typeManifest","import_nodes","import_visitors_core","typeManifest","import_nodes","import_renderers_core","import_visitors_core","import_codecs_strings","import_nodes","import_nodes","import_visitors_core","import_nodes","import_renderers_core","import_visitors_core","import_nodes","import_visitors_core","import_renderers_core","import_visitors_core","import_nodes","import_renderers_core","import_visitors_core","import_nodes","import_renderers_core","import_visitors_core","import_nodes","import_renderers_core","import_visitors_core","pdaSeeds","typeManifest","valueManifest","programAddress","module","import_nodes","import_renderers_core","import_visitors_core","getAccountTypeFragment","import_nodes","import_visitors_core","getRemainingAccountsFragment","getArgumentValueNodeFragment","getResolverValueNodeFragment","import_errors","import_nodes","import_visitors_core","import_nodes","import_visitors_core","getTypeFragment","import_nodes","import_renderers_core","import_visitors_core","getInstructionTypeFragment","getInstructionTypeFragment","import_nodes","import_visitors_core","getFunctionFragment","encoder","import_visitors_core","import_nodes","import_renderers_core","import_visitors_core","import_visitors_core","import_nodes","import_renderers_core","import_visitors_core","import_visitors_core","import_nodes","import_visitors_core","import_nodes","import_renderers_core","import_visitors_core","variantName","fragment","import_renderers_core","import_visitors_core"]}