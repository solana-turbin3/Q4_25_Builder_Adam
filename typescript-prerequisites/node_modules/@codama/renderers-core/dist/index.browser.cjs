"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var index_exports = {};
__export(index_exports, {
  addToRenderMap: () => addToRenderMap,
  createDirectory: () => createDirectory,
  createFragmentTemplate: () => createFragmentTemplate,
  createRenderMap: () => createRenderMap,
  deleteDirectory: () => deleteDirectory,
  getFromRenderMap: () => getFromRenderMap,
  joinPath: () => joinPath,
  mapFragmentContent: () => mapFragmentContent,
  mapRenderMapContent: () => mapRenderMapContent,
  mapRenderMapContentAsync: () => mapRenderMapContentAsync,
  mergeRenderMaps: () => mergeRenderMaps,
  pathDirectory: () => pathDirectory,
  readFile: () => readFile,
  readJson: () => readJson,
  removeFromRenderMap: () => removeFromRenderMap,
  renderMapContains: () => renderMapContains,
  setFragmentContent: () => setFragmentContent,
  writeFile: () => writeFile,
  writeRenderMap: () => writeRenderMap,
  writeRenderMapVisitor: () => writeRenderMapVisitor
});
module.exports = __toCommonJS(index_exports);

// src/fragment.ts
function mapFragmentContent(fragment, mapContent) {
  return setFragmentContent(fragment, mapContent(fragment.content));
}
function setFragmentContent(fragment, content) {
  return Object.freeze({ ...fragment, content });
}
function createFragmentTemplate(template, items, isFragment, mergeFragments) {
  const fragments = items.filter(isFragment);
  const zippedItems = items.map((item, i) => {
    const itemPrefix = template[i];
    if (typeof item === "undefined") return itemPrefix;
    if (isFragment(item)) return itemPrefix + item.content;
    return itemPrefix + String(item);
  });
  return mergeFragments(fragments, () => zippedItems.join("") + template[template.length - 1]);
}

// src/fs.ts
var import_node_fs = require("fs");
var import_errors = require("@codama/errors");

// src/path.ts
var import_node_path = require("path");
function joinPath(...paths) {
  if (true) {
    return paths.join("/").replace(/\/+/g, "/");
  }
  return (0, import_node_path.join)(...paths);
}
function pathDirectory(path) {
  if (true) {
    return path.substring(0, path.lastIndexOf("/"));
  }
  return (0, import_node_path.dirname)(path);
}

// src/fs.ts
var createDirectory = (path) => {
  if (true) {
    throw new import_errors.CodamaError(import_errors.CODAMA_ERROR__NODE_FILESYSTEM_FUNCTION_UNAVAILABLE, { fsFunction: "mkdirSync" });
  }
  (0, import_node_fs.mkdirSync)(path, { recursive: true });
};
var deleteDirectory = (path) => {
  if (true) {
    throw new import_errors.CodamaError(import_errors.CODAMA_ERROR__NODE_FILESYSTEM_FUNCTION_UNAVAILABLE, { fsFunction: "rmSync" });
  }
  if ((0, import_node_fs.existsSync)(path)) {
    (0, import_node_fs.rmSync)(path, { recursive: true });
  }
};
var writeFile = (path, content) => {
  if (true) {
    throw new import_errors.CodamaError(import_errors.CODAMA_ERROR__NODE_FILESYSTEM_FUNCTION_UNAVAILABLE, { fsFunction: "writeFileSync" });
  }
  const directory = pathDirectory(path);
  if (!(0, import_node_fs.existsSync)(directory)) {
    createDirectory(directory);
  }
  (0, import_node_fs.writeFileSync)(path, content);
};
function readFile(path) {
  if (true) {
    throw new import_errors.CodamaError(import_errors.CODAMA_ERROR__NODE_FILESYSTEM_FUNCTION_UNAVAILABLE, { fsFunction: "readFileSync" });
  }
  return (0, import_node_fs.readFileSync)(path, "utf-8");
}
function readJson(path) {
  return JSON.parse(readFile(path));
}

// src/renderMap.ts
var import_errors2 = require("@codama/errors");
var import_visitors_core = require("@codama/visitors-core");
function createRenderMap(pathOrEntries, content) {
  let entries = [];
  if (typeof pathOrEntries === "string" && pathOrEntries !== void 0 && content !== void 0) {
    entries = [[pathOrEntries, typeof content === "string" ? content : content.content]];
  } else if (typeof pathOrEntries === "object" && pathOrEntries !== null) {
    entries = Object.entries(pathOrEntries).flatMap(([key, value]) => {
      if (value === void 0) return [];
      return [[key, typeof value === "string" ? value : value.content]];
    });
  }
  return Object.freeze(new Map(entries));
}
function addToRenderMap(renderMap, path, content) {
  return mergeRenderMaps([renderMap, createRenderMap(path, content)]);
}
function removeFromRenderMap(renderMap, path) {
  const newMap = new Map(renderMap);
  newMap.delete(path);
  return Object.freeze(newMap);
}
function mergeRenderMaps(renderMaps) {
  if (renderMaps.length === 0) return createRenderMap();
  if (renderMaps.length === 1) return renderMaps[0];
  const merged = new Map(renderMaps[0]);
  for (const map of renderMaps.slice(1)) {
    for (const [key, value] of map) {
      merged.set(key, value);
    }
  }
  return Object.freeze(merged);
}
function mapRenderMapContent(renderMap, fn) {
  const newMap = /* @__PURE__ */ new Map();
  for (const [key, value] of renderMap) {
    newMap.set(key, fn(value));
  }
  return Object.freeze(newMap);
}
async function mapRenderMapContentAsync(renderMap, fn) {
  const entries = await Promise.all([
    ...[...renderMap.entries()].map(async ([key, value]) => [key, await fn(value)])
  ]);
  return Object.freeze(new Map(entries));
}
function getFromRenderMap(renderMap, path) {
  const value = renderMap.get(path);
  if (value === void 0) {
    throw new import_errors2.CodamaError(import_errors2.CODAMA_ERROR__VISITORS__RENDER_MAP_KEY_NOT_FOUND, { key: path });
  }
  return value;
}
function renderMapContains(renderMap, path, value) {
  const content = getFromRenderMap(renderMap, path);
  return typeof value === "string" ? content.includes(value) : value.test(content);
}
function writeRenderMap(renderMap, basePath) {
  renderMap.forEach((content, relativePath) => {
    writeFile(joinPath(basePath, relativePath), content);
  });
}
function writeRenderMapVisitor(visitor, basePath) {
  return (0, import_visitors_core.mapVisitor)(visitor, (renderMap) => writeRenderMap(renderMap, basePath));
}
//# sourceMappingURL=index.browser.cjs.map