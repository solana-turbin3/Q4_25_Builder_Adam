{"version":3,"sources":["../src/index.ts","../src/fragment.ts","../src/fs.ts","../src/path.ts","../src/renderMap.ts"],"sourcesContent":["export * from './fragment';\nexport * from './fs';\nexport * from './path';\nexport * from './renderMap';\n","export type BaseFragment = Readonly<{ content: string }>;\n\nexport function mapFragmentContent<TFragment extends BaseFragment>(\n    fragment: TFragment,\n    mapContent: (content: string) => string,\n): TFragment {\n    return setFragmentContent(fragment, mapContent(fragment.content));\n}\n\nexport function setFragmentContent<TFragment extends BaseFragment>(fragment: TFragment, content: string): TFragment {\n    return Object.freeze({ ...fragment, content });\n}\n\nexport function createFragmentTemplate<TFragment extends BaseFragment>(\n    template: TemplateStringsArray,\n    items: unknown[],\n    isFragment: (value: unknown) => value is TFragment,\n    mergeFragments: (fragments: TFragment[], mergeContent: (contents: string[]) => string) => TFragment,\n): TFragment {\n    const fragments = items.filter(isFragment);\n    const zippedItems = items.map((item, i) => {\n        const itemPrefix = template[i];\n        if (typeof item === 'undefined') return itemPrefix;\n        if (isFragment(item)) return itemPrefix + item.content;\n        return itemPrefix + String(item as string);\n    });\n    return mergeFragments(fragments, () => zippedItems.join('') + template[template.length - 1]);\n}\n","import { existsSync, mkdirSync, readFileSync, rmSync, writeFileSync } from 'node:fs';\n\nimport { CODAMA_ERROR__NODE_FILESYSTEM_FUNCTION_UNAVAILABLE, CodamaError } from '@codama/errors';\n\nimport { Path, pathDirectory } from './path';\n\nexport const createDirectory = (path: Path): void => {\n    if (!__NODEJS__) {\n        throw new CodamaError(CODAMA_ERROR__NODE_FILESYSTEM_FUNCTION_UNAVAILABLE, { fsFunction: 'mkdirSync' });\n    }\n\n    mkdirSync(path, { recursive: true });\n};\n\nexport const deleteDirectory = (path: Path): void => {\n    if (!__NODEJS__) {\n        throw new CodamaError(CODAMA_ERROR__NODE_FILESYSTEM_FUNCTION_UNAVAILABLE, { fsFunction: 'rmSync' });\n    }\n\n    if (existsSync(path)) {\n        rmSync(path, { recursive: true });\n    }\n};\n\nexport const writeFile = (path: Path, content: string): void => {\n    if (!__NODEJS__) {\n        throw new CodamaError(CODAMA_ERROR__NODE_FILESYSTEM_FUNCTION_UNAVAILABLE, { fsFunction: 'writeFileSync' });\n    }\n\n    const directory = pathDirectory(path);\n    if (!existsSync(directory)) {\n        createDirectory(directory);\n    }\n    writeFileSync(path, content);\n};\n\nexport function readFile(path: Path): string {\n    if (!__NODEJS__) {\n        throw new CodamaError(CODAMA_ERROR__NODE_FILESYSTEM_FUNCTION_UNAVAILABLE, { fsFunction: 'readFileSync' });\n    }\n\n    return readFileSync(path, 'utf-8');\n}\n\nexport function readJson<T>(path: Path): T {\n    return JSON.parse(readFile(path)) as T;\n}\n","import { dirname, join } from 'node:path';\n\nexport type Path = string;\n\nexport function joinPath(...paths: Path[]): string {\n    if (!__NODEJS__) {\n        return paths.join('/').replace(/\\/+/g, '/');\n    }\n\n    return join(...paths);\n}\n\nexport function pathDirectory(path: Path): Path {\n    if (!__NODEJS__) {\n        return path.substring(0, path.lastIndexOf('/'));\n    }\n\n    return dirname(path);\n}\n","import { CODAMA_ERROR__VISITORS__RENDER_MAP_KEY_NOT_FOUND, CodamaError } from '@codama/errors';\nimport { NodeKind } from '@codama/nodes';\nimport { mapVisitor, Visitor } from '@codama/visitors-core';\n\nimport { BaseFragment } from './fragment';\nimport { writeFile } from './fs';\nimport { joinPath, Path } from './path';\n\nexport type RenderMap = ReadonlyMap<Path, string>;\n\nexport function createRenderMap(): RenderMap;\nexport function createRenderMap(path: Path, content: BaseFragment | string): RenderMap;\nexport function createRenderMap(entries: Record<Path, BaseFragment | string | undefined>): RenderMap;\nexport function createRenderMap(\n    pathOrEntries?: Path | Record<Path, BaseFragment | string | undefined>,\n    content?: BaseFragment | string,\n): RenderMap {\n    let entries: [Path, string][] = [];\n    if (typeof pathOrEntries === 'string' && pathOrEntries !== undefined && content !== undefined) {\n        entries = [[pathOrEntries, typeof content === 'string' ? content : content.content]];\n    } else if (typeof pathOrEntries === 'object' && pathOrEntries !== null) {\n        entries = Object.entries(pathOrEntries).flatMap(([key, value]) => {\n            if (value === undefined) return [];\n            return [[key, typeof value === 'string' ? value : value.content]] as const;\n        });\n    }\n    return Object.freeze(new Map<Path, string>(entries));\n}\n\nexport function addToRenderMap(renderMap: RenderMap, path: Path, content: BaseFragment | string): RenderMap {\n    return mergeRenderMaps([renderMap, createRenderMap(path, content)]);\n}\n\nexport function removeFromRenderMap(renderMap: RenderMap, path: Path): RenderMap {\n    const newMap = new Map(renderMap);\n    newMap.delete(path);\n    return Object.freeze(newMap);\n}\n\nexport function mergeRenderMaps(renderMaps: RenderMap[]): RenderMap {\n    if (renderMaps.length === 0) return createRenderMap();\n    if (renderMaps.length === 1) return renderMaps[0];\n    const merged = new Map(renderMaps[0]);\n    for (const map of renderMaps.slice(1)) {\n        for (const [key, value] of map) {\n            merged.set(key, value);\n        }\n    }\n    return Object.freeze(merged);\n}\n\nexport function mapRenderMapContent(renderMap: RenderMap, fn: (content: string) => string): RenderMap {\n    const newMap = new Map<Path, string>();\n    for (const [key, value] of renderMap) {\n        newMap.set(key, fn(value));\n    }\n    return Object.freeze(newMap);\n}\n\nexport async function mapRenderMapContentAsync(\n    renderMap: RenderMap,\n    fn: (content: string) => Promise<string>,\n): Promise<RenderMap> {\n    const entries = await Promise.all([\n        ...[...renderMap.entries()].map(async ([key, value]) => [key, await fn(value)] as const),\n    ]);\n    return Object.freeze(new Map<Path, string>(entries));\n}\n\nexport function getFromRenderMap(renderMap: RenderMap, path: Path): string {\n    const value = renderMap.get(path);\n    if (value === undefined) {\n        throw new CodamaError(CODAMA_ERROR__VISITORS__RENDER_MAP_KEY_NOT_FOUND, { key: path });\n    }\n    return value;\n}\n\nexport function renderMapContains(renderMap: RenderMap, path: Path, value: RegExp | string): boolean {\n    const content = getFromRenderMap(renderMap, path);\n    return typeof value === 'string' ? content.includes(value) : value.test(content);\n}\n\nexport function writeRenderMap(renderMap: RenderMap, basePath: Path): void {\n    renderMap.forEach((content, relativePath) => {\n        writeFile(joinPath(basePath, relativePath), content);\n    });\n}\n\nexport function writeRenderMapVisitor<TNodeKind extends NodeKind = NodeKind>(\n    visitor: Visitor<RenderMap, TNodeKind>,\n    basePath: Path,\n): Visitor<void, TNodeKind> {\n    return mapVisitor(visitor, renderMap => writeRenderMap(renderMap, basePath));\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACEO,SAAS,mBACZ,UACA,YACS;AACT,SAAO,mBAAmB,UAAU,WAAW,SAAS,OAAO,CAAC;AACpE;AAEO,SAAS,mBAAmD,UAAqB,SAA4B;AAChH,SAAO,OAAO,OAAO,EAAE,GAAG,UAAU,QAAQ,CAAC;AACjD;AAEO,SAAS,uBACZ,UACA,OACA,YACA,gBACS;AACT,QAAM,YAAY,MAAM,OAAO,UAAU;AACzC,QAAM,cAAc,MAAM,IAAI,CAAC,MAAM,MAAM;AACvC,UAAM,aAAa,SAAS,CAAC;AAC7B,QAAI,OAAO,SAAS,YAAa,QAAO;AACxC,QAAI,WAAW,IAAI,EAAG,QAAO,aAAa,KAAK;AAC/C,WAAO,aAAa,OAAO,IAAc;AAAA,EAC7C,CAAC;AACD,SAAO,eAAe,WAAW,MAAM,YAAY,KAAK,EAAE,IAAI,SAAS,SAAS,SAAS,CAAC,CAAC;AAC/F;;;AC3BA,qBAA2E;AAE3E,oBAAgF;;;ACFhF,uBAA8B;AAIvB,SAAS,YAAY,OAAuB;AAC/C,MAAI,MAAa;AACb,WAAO,MAAM,KAAK,GAAG,EAAE,QAAQ,QAAQ,GAAG;AAAA,EAC9C;AAEA,aAAO,uBAAK,GAAG,KAAK;AACxB;AAEO,SAAS,cAAc,MAAkB;AAC5C,MAAI,MAAa;AACb,WAAO,KAAK,UAAU,GAAG,KAAK,YAAY,GAAG,CAAC;AAAA,EAClD;AAEA,aAAO,0BAAQ,IAAI;AACvB;;;ADZO,IAAM,kBAAkB,CAAC,SAAqB;AACjD,MAAI,MAAa;AACb,UAAM,IAAI,0BAAY,kEAAoD,EAAE,YAAY,YAAY,CAAC;AAAA,EACzG;AAEA,gCAAU,MAAM,EAAE,WAAW,KAAK,CAAC;AACvC;AAEO,IAAM,kBAAkB,CAAC,SAAqB;AACjD,MAAI,MAAa;AACb,UAAM,IAAI,0BAAY,kEAAoD,EAAE,YAAY,SAAS,CAAC;AAAA,EACtG;AAEA,UAAI,2BAAW,IAAI,GAAG;AAClB,+BAAO,MAAM,EAAE,WAAW,KAAK,CAAC;AAAA,EACpC;AACJ;AAEO,IAAM,YAAY,CAAC,MAAY,YAA0B;AAC5D,MAAI,MAAa;AACb,UAAM,IAAI,0BAAY,kEAAoD,EAAE,YAAY,gBAAgB,CAAC;AAAA,EAC7G;AAEA,QAAM,YAAY,cAAc,IAAI;AACpC,MAAI,KAAC,2BAAW,SAAS,GAAG;AACxB,oBAAgB,SAAS;AAAA,EAC7B;AACA,oCAAc,MAAM,OAAO;AAC/B;AAEO,SAAS,SAAS,MAAoB;AACzC,MAAI,MAAa;AACb,UAAM,IAAI,0BAAY,kEAAoD,EAAE,YAAY,eAAe,CAAC;AAAA,EAC5G;AAEA,aAAO,6BAAa,MAAM,OAAO;AACrC;AAEO,SAAS,SAAY,MAAe;AACvC,SAAO,KAAK,MAAM,SAAS,IAAI,CAAC;AACpC;;;AE9CA,IAAAA,iBAA8E;AAE9E,2BAAoC;AAW7B,SAAS,gBACZ,eACA,SACS;AACT,MAAI,UAA4B,CAAC;AACjC,MAAI,OAAO,kBAAkB,YAAY,kBAAkB,UAAa,YAAY,QAAW;AAC3F,cAAU,CAAC,CAAC,eAAe,OAAO,YAAY,WAAW,UAAU,QAAQ,OAAO,CAAC;AAAA,EACvF,WAAW,OAAO,kBAAkB,YAAY,kBAAkB,MAAM;AACpE,cAAU,OAAO,QAAQ,aAAa,EAAE,QAAQ,CAAC,CAAC,KAAK,KAAK,MAAM;AAC9D,UAAI,UAAU,OAAW,QAAO,CAAC;AACjC,aAAO,CAAC,CAAC,KAAK,OAAO,UAAU,WAAW,QAAQ,MAAM,OAAO,CAAC;AAAA,IACpE,CAAC;AAAA,EACL;AACA,SAAO,OAAO,OAAO,IAAI,IAAkB,OAAO,CAAC;AACvD;AAEO,SAAS,eAAe,WAAsB,MAAY,SAA2C;AACxG,SAAO,gBAAgB,CAAC,WAAW,gBAAgB,MAAM,OAAO,CAAC,CAAC;AACtE;AAEO,SAAS,oBAAoB,WAAsB,MAAuB;AAC7E,QAAM,SAAS,IAAI,IAAI,SAAS;AAChC,SAAO,OAAO,IAAI;AAClB,SAAO,OAAO,OAAO,MAAM;AAC/B;AAEO,SAAS,gBAAgB,YAAoC;AAChE,MAAI,WAAW,WAAW,EAAG,QAAO,gBAAgB;AACpD,MAAI,WAAW,WAAW,EAAG,QAAO,WAAW,CAAC;AAChD,QAAM,SAAS,IAAI,IAAI,WAAW,CAAC,CAAC;AACpC,aAAW,OAAO,WAAW,MAAM,CAAC,GAAG;AACnC,eAAW,CAAC,KAAK,KAAK,KAAK,KAAK;AAC5B,aAAO,IAAI,KAAK,KAAK;AAAA,IACzB;AAAA,EACJ;AACA,SAAO,OAAO,OAAO,MAAM;AAC/B;AAEO,SAAS,oBAAoB,WAAsB,IAA4C;AAClG,QAAM,SAAS,oBAAI,IAAkB;AACrC,aAAW,CAAC,KAAK,KAAK,KAAK,WAAW;AAClC,WAAO,IAAI,KAAK,GAAG,KAAK,CAAC;AAAA,EAC7B;AACA,SAAO,OAAO,OAAO,MAAM;AAC/B;AAEA,eAAsB,yBAClB,WACA,IACkB;AAClB,QAAM,UAAU,MAAM,QAAQ,IAAI;AAAA,IAC9B,GAAG,CAAC,GAAG,UAAU,QAAQ,CAAC,EAAE,IAAI,OAAO,CAAC,KAAK,KAAK,MAAM,CAAC,KAAK,MAAM,GAAG,KAAK,CAAC,CAAU;AAAA,EAC3F,CAAC;AACD,SAAO,OAAO,OAAO,IAAI,IAAkB,OAAO,CAAC;AACvD;AAEO,SAAS,iBAAiB,WAAsB,MAAoB;AACvE,QAAM,QAAQ,UAAU,IAAI,IAAI;AAChC,MAAI,UAAU,QAAW;AACrB,UAAM,IAAI,2BAAY,iEAAkD,EAAE,KAAK,KAAK,CAAC;AAAA,EACzF;AACA,SAAO;AACX;AAEO,SAAS,kBAAkB,WAAsB,MAAY,OAAiC;AACjG,QAAM,UAAU,iBAAiB,WAAW,IAAI;AAChD,SAAO,OAAO,UAAU,WAAW,QAAQ,SAAS,KAAK,IAAI,MAAM,KAAK,OAAO;AACnF;AAEO,SAAS,eAAe,WAAsB,UAAsB;AACvE,YAAU,QAAQ,CAAC,SAAS,iBAAiB;AACzC,cAAU,SAAS,UAAU,YAAY,GAAG,OAAO;AAAA,EACvD,CAAC;AACL;AAEO,SAAS,sBACZ,SACA,UACwB;AACxB,aAAO,iCAAW,SAAS,eAAa,eAAe,WAAW,QAAQ,CAAC;AAC/E;","names":["import_errors"]}