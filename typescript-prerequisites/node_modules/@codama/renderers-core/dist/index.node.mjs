// src/fragment.ts
function mapFragmentContent(fragment, mapContent) {
  return setFragmentContent(fragment, mapContent(fragment.content));
}
function setFragmentContent(fragment, content) {
  return Object.freeze({ ...fragment, content });
}
function createFragmentTemplate(template, items, isFragment, mergeFragments) {
  const fragments = items.filter(isFragment);
  const zippedItems = items.map((item, i) => {
    const itemPrefix = template[i];
    if (typeof item === "undefined") return itemPrefix;
    if (isFragment(item)) return itemPrefix + item.content;
    return itemPrefix + String(item);
  });
  return mergeFragments(fragments, () => zippedItems.join("") + template[template.length - 1]);
}

// src/fs.ts
import { existsSync, mkdirSync, readFileSync, rmSync, writeFileSync } from "fs";
import "@codama/errors";

// src/path.ts
import { dirname, join } from "path";
function joinPath(...paths) {
  if (false) {
    return paths.join("/").replace(/\/+/g, "/");
  }
  return join(...paths);
}
function pathDirectory(path) {
  if (false) {
    return path.substring(0, path.lastIndexOf("/"));
  }
  return dirname(path);
}

// src/fs.ts
var createDirectory = (path) => {
  if (false) {
    throw new CodamaError(CODAMA_ERROR__NODE_FILESYSTEM_FUNCTION_UNAVAILABLE, { fsFunction: "mkdirSync" });
  }
  mkdirSync(path, { recursive: true });
};
var deleteDirectory = (path) => {
  if (false) {
    throw new CodamaError(CODAMA_ERROR__NODE_FILESYSTEM_FUNCTION_UNAVAILABLE, { fsFunction: "rmSync" });
  }
  if (existsSync(path)) {
    rmSync(path, { recursive: true });
  }
};
var writeFile = (path, content) => {
  if (false) {
    throw new CodamaError(CODAMA_ERROR__NODE_FILESYSTEM_FUNCTION_UNAVAILABLE, { fsFunction: "writeFileSync" });
  }
  const directory = pathDirectory(path);
  if (!existsSync(directory)) {
    createDirectory(directory);
  }
  writeFileSync(path, content);
};
function readFile(path) {
  if (false) {
    throw new CodamaError(CODAMA_ERROR__NODE_FILESYSTEM_FUNCTION_UNAVAILABLE, { fsFunction: "readFileSync" });
  }
  return readFileSync(path, "utf-8");
}
function readJson(path) {
  return JSON.parse(readFile(path));
}

// src/renderMap.ts
import { CODAMA_ERROR__VISITORS__RENDER_MAP_KEY_NOT_FOUND, CodamaError as CodamaError2 } from "@codama/errors";
import { mapVisitor } from "@codama/visitors-core";
function createRenderMap(pathOrEntries, content) {
  let entries = [];
  if (typeof pathOrEntries === "string" && pathOrEntries !== void 0 && content !== void 0) {
    entries = [[pathOrEntries, typeof content === "string" ? content : content.content]];
  } else if (typeof pathOrEntries === "object" && pathOrEntries !== null) {
    entries = Object.entries(pathOrEntries).flatMap(([key, value]) => {
      if (value === void 0) return [];
      return [[key, typeof value === "string" ? value : value.content]];
    });
  }
  return Object.freeze(new Map(entries));
}
function addToRenderMap(renderMap, path, content) {
  return mergeRenderMaps([renderMap, createRenderMap(path, content)]);
}
function removeFromRenderMap(renderMap, path) {
  const newMap = new Map(renderMap);
  newMap.delete(path);
  return Object.freeze(newMap);
}
function mergeRenderMaps(renderMaps) {
  if (renderMaps.length === 0) return createRenderMap();
  if (renderMaps.length === 1) return renderMaps[0];
  const merged = new Map(renderMaps[0]);
  for (const map of renderMaps.slice(1)) {
    for (const [key, value] of map) {
      merged.set(key, value);
    }
  }
  return Object.freeze(merged);
}
function mapRenderMapContent(renderMap, fn) {
  const newMap = /* @__PURE__ */ new Map();
  for (const [key, value] of renderMap) {
    newMap.set(key, fn(value));
  }
  return Object.freeze(newMap);
}
async function mapRenderMapContentAsync(renderMap, fn) {
  const entries = await Promise.all([
    ...[...renderMap.entries()].map(async ([key, value]) => [key, await fn(value)])
  ]);
  return Object.freeze(new Map(entries));
}
function getFromRenderMap(renderMap, path) {
  const value = renderMap.get(path);
  if (value === void 0) {
    throw new CodamaError2(CODAMA_ERROR__VISITORS__RENDER_MAP_KEY_NOT_FOUND, { key: path });
  }
  return value;
}
function renderMapContains(renderMap, path, value) {
  const content = getFromRenderMap(renderMap, path);
  return typeof value === "string" ? content.includes(value) : value.test(content);
}
function writeRenderMap(renderMap, basePath) {
  renderMap.forEach((content, relativePath) => {
    writeFile(joinPath(basePath, relativePath), content);
  });
}
function writeRenderMapVisitor(visitor, basePath) {
  return mapVisitor(visitor, (renderMap) => writeRenderMap(renderMap, basePath));
}
export {
  addToRenderMap,
  createDirectory,
  createFragmentTemplate,
  createRenderMap,
  deleteDirectory,
  getFromRenderMap,
  joinPath,
  mapFragmentContent,
  mapRenderMapContent,
  mapRenderMapContentAsync,
  mergeRenderMaps,
  pathDirectory,
  readFile,
  readJson,
  removeFromRenderMap,
  renderMapContains,
  setFragmentContent,
  writeFile,
  writeRenderMap,
  writeRenderMapVisitor
};
//# sourceMappingURL=index.node.mjs.map